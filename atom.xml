<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>기술을 기술하다</title>
  
  <subtitle>sogoagain의 기술 블로그</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sogoagain.github.io/"/>
  <updated>2019-09-27T13:01:06.246Z</updated>
  <id>https://sogoagain.github.io/</id>
  
  <author>
    <name>sogoagain</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AWS도 Setter를 사용하지 않는다</title>
    <link href="https://sogoagain.github.io/2019/09/25/AWS%EB%8F%84-Setter%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4/"/>
    <id>https://sogoagain.github.io/2019/09/25/AWS도-Setter를-사용하지-않는다/</id>
    <published>2019-09-25T14:27:05.000Z</published>
    <updated>2019-09-27T13:01:06.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AWS도-Setter를-사용하지-않는다"><a href="#AWS도-Setter를-사용하지-않는다" class="headerlink" title="AWS도 Setter를 사용하지 않는다."></a>AWS도 Setter를 사용하지 않는다.</h2><h3 id="AWS-SDK-버전을-‘1-11-x’에서-‘2-x’로"><a href="#AWS-SDK-버전을-‘1-11-x’에서-‘2-x’로" class="headerlink" title="AWS SDK 버전을 ‘1.11.x’에서 ‘2.x’로"></a>AWS SDK 버전을 ‘1.11.x’에서 ‘2.x’로</h3><p>최근 회사 프로젝트의 AWS SDK(Java) 버전을 ‘1.11.x’에서 ‘2.x’으로 올리는 작업을 진행하였다.<br>사내 시스템에 다량의 Email을 발송하는 기능이 있는데 실행 시간이 오래 걸렸기 때문에 개선이 필요하였다.</p><p>메일 발송 기능은 AWS SES 서비스를 사용하고 있었고 실행 시간을 단축하고자 메일 발송 로직 전체를 비동기로 변경하려고 알아보던 중 AWS SDK 버전이 2.x로 들어서면서 Nonblocking I/O를 지원하는 것을 알게 되었고 업데이트를 단행하였다.</p><blockquote><p>The AWS SDK for Java 2.x utilizes a new, nonblocking SDK architecture built on Netty to support true nonblocking I/O. <a href="https://aws.amazon.com/ko/blogs/developer/aws-sdk-for-java-2-x-released/" rel="external nofollow noopener noreferrer" target="_blank">(AWS SDK for Java 2.x released)</a></p></blockquote><p>시스템에서는 AWS의 SES뿐만 아니라 다른 서비스도 사용하고 있었기에 수정 범위가 꽤 커졌지만, 코드 리팩토링과 함께 AWS SDK가 어떻게 달라졌나를 코드로 느끼며 진행했기에 흥미로운 경험이 되었다.</p><h3 id="‘2-x’는-Setter를-사용하지-않는다"><a href="#‘2-x’는-Setter를-사용하지-않는다" class="headerlink" title="‘2.x’는 Setter를 사용하지 않는다."></a>‘2.x’는 Setter를 사용하지 않는다.</h3><p>전체적으로 AWS SDK 2.0의 코드는 1.11.x보다 세련되었고 많은 부분이 변화하였다. 그중 내게 눈에 띈 변화는 바로 <strong>Setter를 없앤 사실</strong>이다.</p><blockquote><p>In the SDK for Java 2.x, setter method names don’t include the “set” or “with” prefix. <a href="https://docs.aws.amazon.com/en_pv/sdk-for-java/v2/migration-guide/whats-different.html" rel="external nofollow noopener noreferrer" target="_blank">(What’s Different between the SDK for Java 1.11.x and 2.x)</a></p></blockquote><p>생성자 호출 대신 Builder를 통해 객체를 생성하는 등 좋은 변화는 당연히 많았지만 나는 유독 Setter를 없앴다는 사실이 굉장히 반가웠다.</p><p>그동안 Setter를 사용하지 않고 프로그램을 작성할 수 있으며 더 좋은 코드를 위해서는 Setter는 사용하지 말아야 한다는 이야기를 종종 하고 다녔다. 하지만, 이 이야기를 하면 대부분 의심의 눈초리와 함께 예시를 요구한다.</p><p>사실 내가 예시를 들어도 의심의 눈초리는 쉽게 사그라지지 않는다. 하지만 그 예시가 AWS라면 다를 것이라 생각이 들었다. 이 생각은 정확히 맞아 들었다. 최근 모각코를 함께하는 분들께 AWS SDK 사례와 함께 ‘Getter, Setter’에 대한 유해성을 말씀드렸더니 큰 관심을 두고 이야기를 들어주었다.</p><p>일단 Getter와 Setter에 대해 자세한 이야기를 하기 전에 AWS SDK에서 Setter가 어떻게 없어졌고 Setter 없이 코드를 어떻게 작성하는지 살펴보자.</p><p>예를 들어 SDK 1.11.x에서 request를 업데이트하는 코드는 다음과 같았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DescribeAlarmsRequest request = <span class="keyword">new</span> DescribeAlarmsRequest();</span><br><span class="line">DescribeAlarmsResult response = cw.describeAlarms(request);</span><br><span class="line"></span><br><span class="line">request.setNextToken(response.getNextToken());</span><br></pre></td></tr></table></figure><p>하지만, SDK 2.x에서 request를 업데이트 하는 코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DescribeAlarmsRequest request = DescribeAlarmsRequest.builder().build();</span><br><span class="line">DescribeAlarmsResponse response = cw.describeAlarms(request);</span><br><span class="line"></span><br><span class="line">request = DescribeAlarmsRequest.builder()</span><br><span class="line">        .nextToken(new_token)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>SDK 2.x에서는 Setter 메서드를 제공하지 않기 때문에 request에 할당된 객체의 상태를 변경할 수 없다. request를 업데이트 하기 위해서는 객체를 새로 생성하여 할당하는 방법 뿐이다. 즉, 한번 생성된 객체는 변경 불가능한(Immutable POJO) 것이다.</p><p>바로 뒤 캡슐화 이야기를 하면서 자세히 설명하겠지만, 변경 불가능한 성질은 request 객체가 외부에서 예상치 못하게 변경될 수 있는 여지 자체를 없애주기 때문에 더욱 견고한 프로그램을 작성할 수 있도록 도와준다.</p><h2 id="Getter-Setter의-유해성"><a href="#Getter-Setter의-유해성" class="headerlink" title="Getter, Setter의 유해성"></a>Getter, Setter의 유해성</h2><p>AWS SDK는 왜 Setter를 제공하지 않도록 바뀐 것일까? 이에 대한 답이 우리가 Getter와 Setter를 피해야 하는 이유다.<br>결론부터 말하면 Getter와 Setter를 사용하는 순간 우리는 <strong>객체지향적</strong> 코드와 멀어지게 되며 객체지향이 주는 장점을 누릴 수 없게 된다.<br>객체지향적 코드와 멀어진다는 것은 데이터를 직접 조작하는 <strong>절차지향적</strong>으로 프로그램을 작성하게 된다는 것이다.</p><p>Getter, Setter의 유해성을 말하기 전에 Getter, Setter가 불필요한 이유를 간단히 살펴보자.<br>객체 안에 있는 것들을 꺼내서(Getter) 밖에서 처리한 뒤 다시 객체에 넣는(Setter) 행위는 조금만 생각해보면 굉장히 번거로운 작업임을 알 수 있다.<br>객체 내부에서 바로 처리하면 될 것을 굳이 왜 꺼내고 넣고 해야 하는가. 처리하는 행위를 객체 안에서 하면 ‘Getter’와 ‘Setter’는 자연스레 필요가 없어진다.</p><p>객체지향적인 사고로는 자연스레 Getter와 Setter가 필요 없는 것이다.<br>Getter와 Setter가 불필요한 이유 중 이만큼 중요하고 간단한 설명은 없는 것 같다.</p><p>조금 더 자세히 들여다보면 Getter와 Setter를 쓴다는 것은 외부에 객체가 어떻게 구현되어 있는지를 드러내는 것이다. 이는 구현을 내부로 숨기는 캡슐화에 어긋나는 것이다. 즉, Getter와 Setter를 사용하게 되면 캡슐화의 장점을 누릴 수 없게 된다.</p><p>객체지향은 캡슐화를 통해서 변경의 범위를 객체 내부로 한정 지을 수 있다. 그러나, Getter와 Setter가 사용되는 순간 객체 자신도 모르는 사이 자신의 내부 속성들이 외부 어디선가 사용되게 된다.</p><p>이렇게 외부에서 객체의 속성들을 사용하고 변경하는 환경에서 객체의 내부 구현이 변경되면 그 여파가 굉장히 커진다. 그리고 이러한 여파로 기능 추가 및 개선이 어렵게 되며 이는 곧 유지보수 비용이 커지는 결과를 초래한다.</p><p>특히, Setter는 Getter보다 더 위험하다. 외부에 객체의 상태를 변경할 방법을 제공하는 것이기 때문에 객체의 상태가 언제 어디서 어떻게 변할지 예측할 수 없다. 복잡한 비즈니스 로직을 제공하는 서비스나 협업하는 상황에서는 setter를 제공하는 객체의 상태 변화에 대한 추적이 더욱 어려워진다.</p><h2 id="객체가-해야할-일은-객체가-스스로-할-수-있도록-책임을-부여하자"><a href="#객체가-해야할-일은-객체가-스스로-할-수-있도록-책임을-부여하자" class="headerlink" title="객체가 해야할 일은 객체가 스스로 할 수 있도록 책임을 부여하자"></a>객체가 해야할 일은 객체가 스스로 할 수 있도록 책임을 부여하자</h2><p>그렇다면 우리는 어떻게 해야 할까? 당연히 앞서 말했다시피 AWS를 본받아 Getter와 Setter가 사용된 로직을 찾고 그 로직을 객체 내부로 옮겨야 한다.<br>이렇게 객체 외부에서 내부로 옮겨진 로직은 객체가 제공하는 책임이 되며 캡슐화된 로직이 된다.<br>캡슐화된 로직은 구현 변경에 있어서 유연함이 생긴다. 객체 외부에 존재하던 로직보다 변경의 여파가 적으며 중복된 코드도 줄여줄 수 있다. 또한 코드의 가독성도 올라간다.</p><h3 id="Getter를-제거한-리팩토링-사례"><a href="#Getter를-제거한-리팩토링-사례" class="headerlink" title="Getter를 제거한 리팩토링 사례"></a>Getter를 제거한 리팩토링 사례</h3><p>실제로 나는 리팩토링 할 곳을 찾을 때 중점적으로 보는 것 중 하나가 Getter와 Setter가 사용되는 곳이다.</p><p>사내 시스템에 데이터를 Excel 형식으로 추출하여 다운받을 수 있는 기능이 있다. 기존에는 Excel로 추출할 수 있는 도메인 각각에 대응되는 Excel 파일 작성 로직이 존재하였다. 즉 A라는 데이터를 추출하기 위한 로직 하나, B라는 데이터를 추출하기 위한 로직 하나 등등 여러 개의 Excel 파일 작성 로직이 존재하였다.</p><p>Excel 파일 작성 로직은 도메인 모델의 getter를 호출하여 Excel 파일을 만들고 있었다. 나는 이 로직들을 보고 Getter를 없애자는 목표로 리팩토링을 수행하였다.</p><p>먼저 Excel 파일 작성에 필요한 데이터를 나타내는 ExcelData라는 객체를 새로 만들고 Excel로 추출할 수 있는 객체들 내부에서 데이터를 조합하여 ExcelData를 반환토록 하였다. (Getter의 제거)<br>그리고 Excel로 추출할 수 있는 객체들을 공통된 인터페이스로 묶었다. (추상화/다형성)<br>그 결과 도메인 별로 1:1 매핑되어 존재하던 Excel 파일 작성 로직을 단 하나로 간추릴 수 있었다.</p><h2 id="Tell-Don’t-Ask"><a href="#Tell-Don’t-Ask" class="headerlink" title="Tell, Don’t Ask"></a>Tell, Don’t Ask</h2><p>객체지향 캡슐화와 관련되어 유명한 규칙 중 하나가 ‘Tell, Don’t Ask’다. 객체에게 ‘넌 뭘 갖고 있니?’라고 묻지 말고 ‘이것 좀 해줘’라고 말하라는 규칙이다.<br>객체가 갖고 있는 데이터를 읽는 순간 우리는 객체지향이 아닌 절차지향을 만나게 된다. 객체에 대해서 파고들지 말고 객체를 믿고 객체에게 묻는 것이 객체지향의 출발점이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AWS도-Setter를-사용하지-않는다&quot;&gt;&lt;a href=&quot;#AWS도-Setter를-사용하지-않는다&quot; class=&quot;headerlink&quot; title=&quot;AWS도 Setter를 사용하지 않는다.&quot;&gt;&lt;/a&gt;AWS도 Setter를 사용하지 않는다.
      
    
    </summary>
    
      <category term="객체지향" scheme="https://sogoagain.github.io/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
    
      <category term="java" scheme="https://sogoagain.github.io/tags/java/"/>
    
      <category term="OOP" scheme="https://sogoagain.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>코틀린(Kotlin)에서의 null 안전 처리</title>
    <link href="https://sogoagain.github.io/2019/08/20/%EC%BD%94%ED%8B%80%EB%A6%B0-Kotlin-%EC%97%90%EC%84%9C%EC%9D%98-null-%EC%95%88%EC%A0%84-%EC%B2%98%EB%A6%AC/"/>
    <id>https://sogoagain.github.io/2019/08/20/코틀린-Kotlin-에서의-null-안전-처리/</id>
    <published>2019-08-20T12:33:32.000Z</published>
    <updated>2019-08-21T14:56:55.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="코틀린-타입-시스템에서의-null"><a href="#코틀린-타입-시스템에서의-null" class="headerlink" title="코틀린 타입 시스템에서의 null"></a>코틀린 타입 시스템에서의 null</h2><p> 코틀린의 타입은 기본적으로 null 불가능(non-nullable)이다. 코틀린의 타입 시스템은 코드에서 NPE(NullPointerException)가 발생하지 않도록 설계되었다. 아래의 코틀린 Reference를 살펴보면 NPE가 발생하는 경우가 한정 되어 있다는 것을 확인할 수 있다.</p><blockquote><p><a href="https://kotlinlang.org/docs/reference/null-safety.html" rel="external nofollow noopener noreferrer" target="_blank">Kotlin Reference - Null Safety</a></p></blockquote><h2 id="명시적-null-타입"><a href="#명시적-null-타입" class="headerlink" title="명시적 null 타입"></a>명시적 null 타입</h2><p> 코틀린 시스템에서 기본적으로 null이 불가능하도록 강제하고 있지만, 자바와의 상호 운용성 등의 이유로 코틀린에서도 null이 사용되므로 null이 가능한(nullable)한 타입을 제공하고 있다. 일반 타입 뒤에 ‘?’를 붙이면 null을 할당할 수 있는 타입을 의미한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nonNullableText: String = <span class="string">"null을 할당할 수 없다."</span></span><br><span class="line">nonNullableText = <span class="literal">null</span> <span class="comment">// 컴파일 에러</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="string">"null을 할당할 수 있다."</span></span><br><span class="line">nullableText = <span class="literal">null</span> <span class="comment">// 컴파일 성공</span></span><br></pre></td></tr></table></figure><h2 id="nullable한-타입이-있어도-JAVA-보다는-괜찮다"><a href="#nullable한-타입이-있어도-JAVA-보다는-괜찮다" class="headerlink" title="nullable한 타입이 있어도 JAVA 보다는 괜찮다."></a>nullable한 타입이 있어도 JAVA 보다는 괜찮다.</h2><p>위의 예에서 보듯 코틀린의 타입은 기본적으로 non-nullable하므로 명시적 null 타입이 아닌 이상 null을 할당하려고 하면 <strong>컴파일 에러</strong>를 발생시킨다. 자바는 null로 인한 컴파일 에러는 발생하지 않는다. 자바에서의 null 오류는 <strong>런타임 에러</strong>다.</p><h3 id="JAVA보다-낫다지만-null이-가능한데…"><a href="#JAVA보다-낫다지만-null이-가능한데…" class="headerlink" title="JAVA보다 낫다지만 null이 가능한데…"></a>JAVA보다 낫다지만 null이 가능한데…</h3><p>위에서 보듯 어찌 되었든 코틀린에서는 null을 할당할 수 있는 타입을 사용할 수 있고 우리는 null에 대비를 해야한다. 우리가 사용하는 라이브러리가 nullable한 타입을 반환할 수 있다. 그럼, 코틀린에서는 어떤 방식으로 null을 안전하게 처리하는지 크게 4가지로 알아보자.</p><hr><h2 id="1-if로-null인지-검사하기"><a href="#1-if로-null인지-검사하기" class="headerlink" title="1. if로 null인지 검사하기"></a>1. if로 null인지 검사하기</h2><p>제일 쉽게 떠올릴 수 있는 방법이다. 다른 프로그래밍 언어에서와 마찬가지로 if를 사용해 변수에 null이 할당되었는지 확인하는 방법이다. </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nullableText != <span class="literal">null</span>) &#123;</span><br><span class="line">    println(nullableText)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">"null입니다."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 간단한 방법이기는 하나 그리 세련되지는 않은 것 같다. 이후 방법들에서는 코틀린에서 제공하는 연산자를 통해 null을 처리해보자</p><h2 id="2-double-bang-연산자-non-null-단언-연산자"><a href="#2-double-bang-연산자-non-null-단언-연산자" class="headerlink" title="2. double-bang 연산자 (non-null 단언 연산자)"></a>2. double-bang 연산자 (non-null 단언 연산자)</h2><p>double-bang 연산자라고 불리는 ‘!!’ non-null 단언 연산자를 이용하여 null을 처리할 수 있다. 이 연산자 이름에 단언(assertion)이 붙은것과 형태가 강한 느낌을 주는 느낌표 두개인 것을 통해 유추할 수 있듯이 이 연산자 nullable 변수에 쓰면 다음의 의미를 뜻한다. ‘비록 nullable 변수이지만 여기에 null이 절대 할당되지 않았음을 내가 단언한다.’ 사용은 아래와 같이 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> lengthOfText = nullableText!!.length</span><br></pre></td></tr></table></figure><p>그런데, double-bang 연산자는 치명적인 단점이 있다. 단언한 것 처럼 null이 아니면 상관 없는데, 단언과 다르게 null이 할당되어 있으면 NPE를 발생시킨다. double-bang 연산자는 nullable 타입이 호출할 수 없는 메서드를 강제로 호출하려고 할때 사용되는 느낌이다.</p><p> NPE를 발생시킬 수 있으므로 주의 깊게 사용해야 하는데, 미리 어디선가 해당 변수에 대해 null값을 검사하여 null이 절대 할당되지 않는다고 보장될 때 사용하면 될 것 같다.<br>또는 역발상으로 NPE가 어디서 발생하는지 디버깅 하는 용도로 사용될 수도 있을 것 같다.</p><h2 id="3-안전-호출-연산자-safe-call-operator"><a href="#3-안전-호출-연산자-safe-call-operator" class="headerlink" title="3. 안전 호출 연산자 (safe call operator)"></a>3. 안전 호출 연산자 (safe call operator)</h2><p>코틀린에서 nullable한 변수를 처리할 때 가장 자주 사용되는 방법인 것 같다. 안전 호출 연산자는 ‘?.’이며 null 값을 검사하여 null이면 건너뛰고 null이 아닐 때는 호출된 연산을 실행한다. 사용 방법은 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line">nullableText = nullableText?.capitalize()</span><br></pre></td></tr></table></figure><blockquote><p>String이 제공하는 메서드 중 capitalize()는 첫글자만 영문 대문자로 변경해준다.</p></blockquote><p>안전 호출 연산자를 사용하면 null 검사 후 null이 아닐 때만 로직을 실행하므로 NPE가 발생하지 않는다.</p><h2 id="4-Elvis-연산자-null-복합-연산자"><a href="#4-Elvis-연산자-null-복합-연산자" class="headerlink" title="4. Elvis 연산자 (null 복합 연산자)"></a>4. Elvis 연산자 (null 복합 연산자)</h2><p>null 복합 연산자는 ‘?:’ 이다. 연산자 모양이 가수 ‘엘비스 프레슬리’와 닮았다고 하여 Elvis 연산자라고도 불린다. Elvis 연산자는 Java에서 삼항 연산자로 null을 체크하는 로직을 단축한 것과 유사하다. Elvis 연산자의 왼쪽 피연산자가 null이면 오른쪽 피연산자를 실행하고 아니면 왼쪽 피연산자의 결과를 반환한다. 예로 살펴보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> nonNullableText: String = nullableText ?: <span class="string">"nullableText에 null이 할당되어 이게 반환됩니다."</span></span><br></pre></td></tr></table></figure><p>위 예에서 nullableText가 null이므로 오른쪽 피연산자인 “nullableText”가 반환된다. 엘비스 연산자의 동작 방식을 Java의 삼항 연산자로 표현하면 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String nullableText = <span class="keyword">null</span>;</span><br><span class="line">String nonNullableText = (nullableText != <span class="keyword">null</span> ? nullableText : <span class="string">"nullableText에 null이 할당되어 이게 반환됩니다."</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="위-4가지-방식-중-어떤-것을-사용해야-할까"><a href="#위-4가지-방식-중-어떤-것을-사용해야-할까" class="headerlink" title="위 4가지 방식 중 어떤 것을 사용해야 할까?"></a>위 4가지 방식 중 어떤 것을 사용해야 할까?</h2><p>정답은 없고 상황에 따라 다르겠지만 주로 세 번째 방법(안전 호출 연산자)와 네 번째 방법(Elvis 연산자)를 사용하면 보다 kotlin스럽게 코드를 작성할 수 있을 것 같다. 추가적으로 첫 번째 방법으로 소개했던 if로 null을 검사하는 로직도 ‘안전 호출 연산자’, ‘Elvis 연산자’, 그리고 ‘let’ 함수를 사용하여 동일한 로직을 아래와 같이 표현할 수 있다.</p><ul><li><p>if로 null 검사하기</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nullableText != <span class="literal">null</span>) &#123;</span><br><span class="line">    println(nullableText)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">"null입니다."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>‘안전 호출 연산자’, ‘Elvis 연산자’, ‘let’ 함수로 동일하게</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">nullableText?.let &#123;</span><br><span class="line">    println(nullableText)</span><br><span class="line">&#125; ?: println(<span class="string">"null입니다."</span>)</span><br></pre></td></tr></table></figure></li></ul><p>이렇게 if로 null을 검사하는 코드도 kotlin의 방법으로 대체할 수 있으니 되도록이면 kotlin에서 제공하는 방법으로 null을 처리해보는 것이 어떨까?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;코틀린-타입-시스템에서의-null&quot;&gt;&lt;a href=&quot;#코틀린-타입-시스템에서의-null&quot; class=&quot;headerlink&quot; title=&quot;코틀린 타입 시스템에서의 null&quot;&gt;&lt;/a&gt;코틀린 타입 시스템에서의 null&lt;/h2&gt;&lt;p&gt; 코틀린의 
      
    
    </summary>
    
      <category term="Kotlin" scheme="https://sogoagain.github.io/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="https://sogoagain.github.io/tags/Kotlin/"/>
    
      <category term="null처리" scheme="https://sogoagain.github.io/tags/null%EC%B2%98%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 메시지 - HTTP Requests</title>
    <link href="https://sogoagain.github.io/2019/08/03/HTTP-%EB%A9%94%EC%8B%9C%EC%A7%80-HTTP-Requests/"/>
    <id>https://sogoagain.github.io/2019/08/03/HTTP-메시지-HTTP-Requests/</id>
    <published>2019-08-03T14:02:16.000Z</published>
    <updated>2019-08-03T14:30:03.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-요청"><a href="#HTTP-요청" class="headerlink" title="HTTP 요청"></a>HTTP 요청</h2><p>웹에서 서버와 클라이언트 간 데이터를 주고받기 위해 HTTP 통신 규약을 사용한다. 오늘은 그중 클라이언트가 서버로 요청을 보내 어떤 행위가 일어나게끔 하는 HTTP 메시지 중 하나인 <strong>HTTP 요청 메시지</strong>에 대해 알아보기로 한다.</p><h2 id="HTTP-Requests"><a href="#HTTP-Requests" class="headerlink" title="HTTP Requests"></a>HTTP Requests</h2><ul><li>예시<figure class="highlight"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/user/create</span> HTTP/1.1</span><br><span class="line"><span class="attribute">HOST</span>: localhost:8080</span><br><span class="line"><span class="attribute">Connection-Length</span>: 59</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"></span><br><span class="line">userId=testUser&amp;password=testPassword</span><br></pre></td></tr></table></figure></li></ul><h3 id="요청-라인-Request-Line"><a href="#요청-라인-Request-Line" class="headerlink" title="요청 라인 (Request Line)"></a>요청 라인 (Request Line)</h3><p>Http request 메시지의 첫 줄을 요청 라인(Request Line)이라고 부른다. 요청 라인의 첫 번째는 HTTP 메서드(GET, PUT, POST 등)가 작성되며 그 뒤를 따라 URI, 마지막으로 HTTP 버전 정보가 작성된다.</p><h3 id="요청-헤더-Request-Header"><a href="#요청-헤더-Request-Header" class="headerlink" title="요청 헤더 (Request Header)"></a>요청 헤더 (Request Header)</h3><p>요청 라인 이후부터 공백 줄 사이까지 요청 헤더(Request Header)라고 부른다. 예시에서 2번째 줄 부터 5번재 줄이 요청 헤더다. 요청 헤더는 HTTP 헤더의 기본 구조를 따르는데 ‘&lt;필드 이름&gt; : &lt;필드 값&gt;’ 쌍으로 이루어져 있다. 필드 이름은 대소문자 구분 없는 문자열이며 필드 값이 여러 개일 경우 ‘,’로 구분한다.</p><h3 id="요청-본문-Request-Body"><a href="#요청-본문-Request-Body" class="headerlink" title="요청 본문 (Request Body)"></a>요청 본문 (Request Body)</h3><p>요청 헤더 이후 공백 줄 다음을 요청 헤더(Request Header)라고 부른다. 예시에서는 7번째 줄이 요청 본문에 해당한다. 모든 요청에 본문이 들어가는 것은 아니며 보통 POST 요청 시 요청 본문에 데이터를 적재하여 전송한다. 보통 GET과 같이 리소스를 가져오는 요청은 본문이 필요하지 않다.</p><blockquote><p>참고자료</p><ol><li>박재성, 자바 웹 프로그래밍 Next Step, 로드북(2016), p118~p119</li><li>MDN web docs, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages" rel="external nofollow noopener noreferrer" target="_blank">HTTP Messages</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP-요청&quot;&gt;&lt;a href=&quot;#HTTP-요청&quot; class=&quot;headerlink&quot; title=&quot;HTTP 요청&quot;&gt;&lt;/a&gt;HTTP 요청&lt;/h2&gt;&lt;p&gt;웹에서 서버와 클라이언트 간 데이터를 주고받기 위해 HTTP 통신 규약을 사용한다. 오늘은
      
    
    </summary>
    
      <category term="WEB" scheme="https://sogoagain.github.io/categories/WEB/"/>
    
    
      <category term="WEB" scheme="https://sogoagain.github.io/tags/WEB/"/>
    
      <category term="HTTP" scheme="https://sogoagain.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JUnit5, @ParameterizedTest 사용 예</title>
    <link href="https://sogoagain.github.io/2019/06/17/JUnit5-ParameterizedTest-%EC%82%AC%EC%9A%A9-%EC%98%88/"/>
    <id>https://sogoagain.github.io/2019/06/17/JUnit5-ParameterizedTest-사용-예/</id>
    <published>2019-06-16T18:25:04.000Z</published>
    <updated>2019-07-28T14:28:56.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUnit5에서-ParameterizedTest를-사용하여-여러번의-테스트-케이스-수행하기"><a href="#JUnit5에서-ParameterizedTest를-사용하여-여러번의-테스트-케이스-수행하기" class="headerlink" title="JUnit5에서 ParameterizedTest를 사용하여 여러번의 테스트 케이스 수행하기"></a>JUnit5에서 ParameterizedTest를 사용하여 여러번의 테스트 케이스 수행하기</h2><ul><li><p>테스트 메서드에 입력값만 전달할 경우</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource</span>(strings = &#123;</span><br><span class="line">        <span class="string">"123"</span>,</span><br><span class="line">        <span class="string">"1 - 2"</span>,</span><br><span class="line">        <span class="string">"1 + 2 + 3"</span>,</span><br><span class="line">        <span class="string">"2 + 3 * 4 / 2"</span>,</span><br><span class="line">        <span class="string">"1343 + 231 * 2 / 4"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">void</span> 올바른_형식의_수식으로_다항식_생성_테스트(String expression) &#123;</span><br><span class="line">Polynomial polynomial = Polynomial.createPolynomialWithExpression(expression);</span><br><span class="line"></span><br><span class="line">assertThat(polynomial).isInstanceOf(Polynomial.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>테스트 메서드에 입력값 뿐만 아니라 결과값도 전달할 필요가 있을 때</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource</span>(&#123;</span><br><span class="line">        <span class="string">"'1 - 2', -1"</span>,</span><br><span class="line">        <span class="string">"'1 + 2 + 3', 6"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">void</span> 다항식_연산_수행_테스트(String expression, <span class="keyword">int</span> expectedResult) &#123;</span><br><span class="line">Polynomial polynomial = Polynomial.createPolynomialWithExpression(expression);</span><br><span class="line"></span><br><span class="line">assertThat(polynomial.calculate()).isEqualTo(expectedResult);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JUnit5에서-ParameterizedTest를-사용하여-여러번의-테스트-케이스-수행하기&quot;&gt;&lt;a href=&quot;#JUnit5에서-ParameterizedTest를-사용하여-여러번의-테스트-케이스-수행하기&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="테스트주도개발" scheme="https://sogoagain.github.io/categories/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C/"/>
    
    
      <category term="junit" scheme="https://sogoagain.github.io/tags/junit/"/>
    
      <category term="TDD" scheme="https://sogoagain.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>가볍게 정리하는 git 기본</title>
    <link href="https://sogoagain.github.io/2019/06/12/%EA%B0%80%EB%B3%8D%EA%B2%8C-%EC%A0%95%EB%A6%AC%ED%95%98%EB%8A%94-git-%EA%B8%B0%EB%B3%B8/"/>
    <id>https://sogoagain.github.io/2019/06/12/가볍게-정리하는-git-기본/</id>
    <published>2019-06-11T18:18:16.000Z</published>
    <updated>2019-07-26T18:57:46.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-기본-내용-정리"><a href="#Git-기본-내용-정리" class="headerlink" title="Git 기본 내용 정리"></a>Git 기본 내용 정리</h2><p>Git과 Github를 사용하고 있지만 단순히 commit, pull/push, branch 정도의 기능만 사용하고 있었을 뿐 아니라 Git GUI 도구를 활용했기에 명령줄 환경에서 git을 잘 다루지 못하였다. Git의 여러 기능을 명령줄 환경에서 능숙하게 사용하여 버전관리 및 협업을 제대로 하고 싶은 바람이 마음속 깊숙이 자리 잡고 있었다. 미루고 미루다 이번에 기회가 되어 Git의 내용을 정리해보는 시간을 가졌다.</p><p>명령어 중심으로 정리를 한 것이라 Git을 처음 사용하시는 분들은 포스팅에 참고한 아래 2개의 링크를 통해 Git의 기본적인 사용법을 익히는 것을 추천한다.<br>생활코딩의 <a href="https://www.opentutorials.org/course/2708" rel="external nofollow noopener noreferrer" target="_blank">지옥에서 온 Git</a>강의와 <a href="http://rogerdudler.github.io/git-guide/index.ko.html" rel="external nofollow noopener noreferrer" target="_blank">git - 간편 안내서</a>를 참고하였다.</p><h2 id="Git-이란"><a href="#Git-이란" class="headerlink" title="Git 이란?"></a>Git 이란?</h2><ul><li>버전관리 시스템 중 하나 (구체적인 제품)</li><li>소스코드의 ‘백업’, ‘복원’, ‘협업’을 효율적으로 할 수 있도록 해주는 프로그램이다.</li></ul><h3 id="git-환경설정"><a href="#git-환경설정" class="headerlink" title="git 환경설정"></a>git 환경설정</h3><ul><li>git을 사용하는 사용자 이름이나 email 주소를 설정해놓을 수 있다. 이런 설정을 해놓아야 협업을 할 때 작업한 사람을 식별하는데 용이하다.</li></ul><ol><li>config 정보 확인<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li></ol><ul><li>config list를 확인한 후 exit를 하고 싶을 땐 ‘:q’를 입력하면 된다.</li></ul><ol start="2"><li><p>config 설정하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "이름"</span><br><span class="line">git config --global user.email "이메일"</span><br></pre></td></tr></table></figure></li><li><p>config 삭제하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --unset --global user.name</span><br><span class="line">git config --unset --global user.email</span><br></pre></td></tr></table></figure></li></ol><h3 id="저장소-만들기"><a href="#저장소-만들기" class="headerlink" title="저장소 만들기"></a>저장소 만들기</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>위 명령어를 실행하면 현재 디렉터리에 ‘.git’ 이라는 디렉터리가 생성된다.</li><li>‘.git’ 디렉터리는 버전정보와 관련된 내용들이 저장되는 디렉터리다.</li></ul><h3 id="저장소-상태보기"><a href="#저장소-상태보기" class="headerlink" title="저장소 상태보기"></a>저장소 상태보기</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="버전관리"><a href="#버전관리" class="headerlink" title="버전관리"></a>버전관리</h2><h3 id="파일을-인덱스에-추가하기-파일-tracking"><a href="#파일을-인덱스에-추가하기-파일-tracking" class="headerlink" title="파일을 인덱스에 추가하기 (파일 tracking)"></a>파일을 인덱스에 추가하기 (파일 tracking)</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file name&gt;</span><br></pre></td></tr></table></figure><ul><li>commit을 하기전에 하나의 버전으로 묶을 파일들을 add를 통해 인덱스에 추가해 놓아야 한다.</li><li>add는 프로젝트의 수많은 수정사항들 중에 하나의 작업 단위에 속하는 파일들끼리 묶어서 commit할 수 있도록 도와준다.</li><li>git add된 파일들은 “staging area”에 속하게 된다.</li></ul><h3 id="변경내용-확정하기-버전-만들기"><a href="#변경내용-확정하기-버전-만들기" class="headerlink" title="변경내용 확정하기 (버전 만들기)"></a>변경내용 확정하기 (버전 만들기)</h3><ul><li>버전은 ‘의미 있는 변화, 변화가 완결된 상태’ 정도로 이해할 수 있으며, 좋은 버전의 단위는 고민해봐야할 사항이다.</li><li>commit은 하나의 작업을 담고 있는 것이 좋다.</li><li>commit된 파일들은 “repository”에 속하게 된다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><ul><li>git index에 추가된 파일이 존재할 경우 위 명령어를 실행하면 vi 편집기가 실행된다. 맨 윗줄에 버전에 대한 설명을 적고 저장하면 commit이 완료된다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "버전에 대한 설명"</span><br></pre></td></tr></table></figure><ul><li>vi 편집기를 사용하지 않고 ‘m’ 옵션을  이용해서 바로 commit할 수 있다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m "버전에 대한 설명"</span><br></pre></td></tr></table></figure><ul><li>매번 git add 후에 git commit을 하는 것이 번거로울 수 있다. 그럴땐 ‘a’ 옵션을 통해 add와 commit을 동시에 할 수 있다.</li><li>‘a’ 옵션은 변경된 파일을 인덱스에 추가한 뒤 커밋한다. 이때, 신규로 추가된 파일(한번도 add를 하지 않은 파일)은 제외된다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><ul><li>amend 옵션을 통해 커밋 메세지를 수정할 수 있다.</li><li>단, 원격 저장소에 올리기 전에 수정해야한다.</li></ul><h3 id="commit-로그-확인"><a href="#commit-로그-확인" class="headerlink" title="commit 로그 확인"></a>commit 로그 확인</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><ul><li>commit 로그를 확인할 수 있다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><ul><li>reset 기록을 확인할 수 있다.</li></ul><h3 id="변경사항-확인하기"><a href="#변경사항-확인하기" class="headerlink" title="변경사항 확인하기"></a>변경사항 확인하기</h3><ol><li>차이점 확인</li></ol><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure><ul><li>각각의 커밋과 커밋 사이의 소스 차이를 확인 할 수 있다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit id&gt;..&lt;commit id&gt;</span><br></pre></td></tr></table></figure><ul><li>특정한 두 커밋 사이의 차이점을 확인 할 수 있다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><ul><li>제일 최근의 커밋된 버전과 현재 작업한 수정 내역과의 차이점을 확인할 수 있다.</li><li>수정된 파일들을 git add하게 되면 확인할 수 없다.</li></ul><h3 id="변경내용-되돌리기"><a href="#변경내용-되돌리기" class="headerlink" title="변경내용 되돌리기"></a>변경내용 되돌리기</h3><ol><li>reset<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit id&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>reset은 되돌리려는 commit으로 상태가 돌아간다. 되돌리려는 commit 이후의 이력은 숨겨진다.</p></li><li><p>reset 명령어에서 사용할 수 있는 옵션은 ‘soft, mixed, hard’ 등이 있다.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard ORIG_HEAD</span><br></pre></td></tr></table></figure></li><li><p>reset 하기 전으로 되돌리고 싶다면 ‘ORIG_HEAD’로 reset 하면 된다.</p></li></ul><ol start="2"><li>revert<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert</span><br></pre></td></tr></table></figure></li></ol><ul><li>revert는 돌아가려는 commit을 기반으로 새로운 commit을 생성하며 작업 상태를 되돌리는 명령어다.</li><li>즉, commit 이력을 유지하면서 내용을 되돌린다고 볼 수 있다.</li></ul><ol start="3"><li>checkout<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit id&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>checkout은 본래 branch를 변경할 때 사용하는 명령어인데, 아래와 같은 방법으로 변경 내용을 되돌릴 수 있다.</li><li>HEAD가 branch를 가리키는 것이 아닌 직접 commit을 가리키게 된다.</li><li>git branch 명령어를 통해서 위 내용을 확인할 수 있다.</li></ul><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><h3 id="가지-branch-치기"><a href="#가지-branch-치기" class="headerlink" title="가지(branch) 치기"></a>가지(branch) 치기</h3><ul><li>branch는 원래 버전관리 되던 작업을 통째로 복사한 뒤 독립적으로 개발하여 또 다른 버전의 줄기를 만드는 것이다.</li></ul><ol><li><p>branch 확인하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>branch 생성하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch name&gt;</span><br><span class="line">git checkout -b &lt;branch name&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>checkout 명령어에 ‘b’ 옵션을 통해 branch를 생성하면서 바로 생성된 branch로 checkout 할 수 있다.</li></ul><ol start="3"><li><p>branch 갈아타기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch name&gt;</span><br></pre></td></tr></table></figure></li><li><p>모든 branch의 커밋 로그 확인하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --branches --decorate --graph --oneline</span><br></pre></td></tr></table></figure></li><li><p>branch 사이의 commit 차이점 확인하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;branch1 name&gt;..&lt;branch2 name&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>branch1에는 없고 branch2에는 있는 commit 로그를 보여준다.</li><li>‘p’ 옵션을 통해 소스코드의 차이점도 볼 수 있다.</li></ul><ol start="6"><li>diff 명령어를 이용하여 branch 사이의 상태 비교<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;branch1 name&gt;..&lt;branch2 name&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>diff 명령어를 통해서 branch1과 branch2의 현재 상태들을 비교할 수 있다.</li></ul><h3 id="branch-병합하기"><a href="#branch-병합하기" class="headerlink" title="branch 병합하기"></a>branch 병합하기</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch2 name&gt;</span><br></pre></td></tr></table></figure><ul><li>branch2에서 branch1으로 병합을 하기 위해선 아래의 절차를 밟아야 한다.</li></ul><ol><li>branch1으로 checkout</li><li>branch1에서 merge 명령을 한다.</li><li>병합된 commit이 새로 생성된다.</li></ol><ul><li>merge tool을 이용한 병합</li></ul><ol><li><p>git 설정</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool &lt;tool name&gt;</span><br></pre></td></tr></table></figure></li><li><p>merge 후 conflict가 발생</p></li><li><p>mergetool 실행 후 conflict 해결</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mergetool</span><br></pre></td></tr></table></figure></li><li><p>conflict를 해결하면 바로 commit 되는데, <filename>.orig 라는 백업 파일이 생성되므로 차후에 삭제를 권장한다.</filename></p></li></ol><h3 id="branch-삭제하기"><a href="#branch-삭제하기" class="headerlink" title="branch 삭제하기"></a>branch 삭제하기</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch name&gt;</span><br></pre></td></tr></table></figure><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash --help</span><br></pre></td></tr></table></figure><ul><li>현재 branch에서 작업을 하는 중에 다른 branch로 변경하여 작업을 해야할 일이 있을 때 사용하는 명령어다.</li><li>작업중이었던 내용을 어딘가 저장하여 감추는 기능을 한다.</li><li>git stash 명령은 버전관리가 되고 있는 파일에 대해서만 사용 가능하다.</li></ul><ol><li><p>작업 내용 숨기기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save</span><br></pre></td></tr></table></figure></li><li><p>stash 목록 확인하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure></li><li><p>숨겼던 작업 내용 적용하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure></li><li><p>가장 최신 stash 삭제하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop</span><br></pre></td></tr></table></figure></li><li><p>stash 했던 작업 내용을 적용한 뒤 바로 삭제하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li></ol><h3 id="원격-저장소"><a href="#원격-저장소" class="headerlink" title="원격 저장소"></a>원격 저장소</h3><ul><li>원격 저장소는 지역(local) 저장소 반대에 있는 개념으로 ‘소스 백업’ 및 ‘협업’을 가능케 한다.</li></ul><ol><li>원격 저장소 생성<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init --bare &lt;remote directory&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>원격 저장소를 만드려는 디렉터리에 위 명령어를 입력한다.</li><li>init의 bare 옵션은 작업이 불가능한(working directory가 없는) 저장소를 생성한다.</li><li>즉, 순수한 저장의 기능을 하는 저장소가 생성된다.</li></ul><ol start="2"><li>원격 저장소 연결<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;원격 저장소 별칭&gt; &lt;원격 저장소 경로&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>지역(local) 저장소와 원격 저장소를 연결한다.</li><li>보통 원격 저장소 별칭은 ‘origin’을 사용한다.</li></ul><ol start="3"><li><p>원격 저장소 확인</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li><li><p>연결된 원격 저장소 제거</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove &lt;원격 저장소 별칭&gt;</span><br></pre></td></tr></table></figure></li><li><p>원격 저장소 복제</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;원격 저장소 주소&gt; &lt;로컬 저장소 경로&gt;</span><br></pre></td></tr></table></figure></li><li><p>원격 저장소로 전송</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;원격 저장소 별칭&gt; &lt;branch 이름&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>‘–set-upstream’ 옵션을 사용하면 현재 branch와 원격저장소의 branch를 연결하여 다음 명령 부터는 원격 저장소와 원격 저장소의 branch를 명시할 필요가 없도록 해주는 옵션이다.</li><li>즉, 첫 push에 ‘–set-upstream’ 옵션을 주면 이후부터는 ‘git push’를 통해 원격 저장소로 전송이 가능하다.</li></ul><ol start="7"><li>원격 저장소 내용 가져오기<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>pull 명령어는 원격 저장소의 내용을 로컬 저장소로 가져와 병합 작업 후 작업 내용을 반영한다.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure></li><li><p>fetch 명령어는 원격 저장소의 내용을 로컬 저장소로 가져오기는 하지만 새로운 브랜치로 가져오기 때문에 로컬 저장소에 반영이 되지 않는다.</p></li><li><p>fetch로 가져온 새로운 브랜치는 ‘FETCH_HEAD’ 이름으로 체크아웃 가능하다.</p></li></ul><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;branch name&gt;</span><br></pre></td></tr></table></figure><ul><li>서로 다른 브랜치를 병합하는 기능을 하는 명령어다.</li><li>merge 명령어와 다르게 병합하는 브랜치의 커밋 이력을 유지할 수 있다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><ul><li>rebase 명령어 실행 중 conflict가 일어나면 해결 후 continue 옵션을 통해 계속해서 병합을 실행한다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-기본-내용-정리&quot;&gt;&lt;a href=&quot;#Git-기본-내용-정리&quot; class=&quot;headerlink&quot; title=&quot;Git 기본 내용 정리&quot;&gt;&lt;/a&gt;Git 기본 내용 정리&lt;/h2&gt;&lt;p&gt;Git과 Github를 사용하고 있지만 단순히 comm
      
    
    </summary>
    
      <category term="도구Tip" scheme="https://sogoagain.github.io/categories/%EB%8F%84%EA%B5%ACTip/"/>
    
    
      <category term="git" scheme="https://sogoagain.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>문화와 기술</title>
    <link href="https://sogoagain.github.io/2019/06/07/%EB%AC%B8%ED%99%94%EC%99%80-%EA%B8%B0%EC%88%A0/"/>
    <id>https://sogoagain.github.io/2019/06/07/문화와-기술/</id>
    <published>2019-06-06T18:16:35.000Z</published>
    <updated>2019-07-26T18:17:27.216Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문화와-기술"><a href="#문화와-기술" class="headerlink" title="문화와 기술"></a>문화와 기술</h3><p>최근 읽고 있는 ‘임백준의 대살개문’에서 다음과 같은 문구를 접하게 되었다.</p><blockquote><p>문화는 흙이고 기술은 꽃이다. - 임백준의 대살개문 中</p></blockquote><p>책 제목 자체가 ‘대한민국을 살리는 개발자 문화’의 약자다.<br>기술의 꽃이 필 수 있도록 좋은 개발 문화를 만드는데 일조를 하고 싶다.<br>그렇기에, 나와 내 주변으로부터 시작해 어제보다 한 걸음 더 앞서 있을 수 있도록 노력할 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문화와-기술&quot;&gt;&lt;a href=&quot;#문화와-기술&quot; class=&quot;headerlink&quot; title=&quot;문화와 기술&quot;&gt;&lt;/a&gt;문화와 기술&lt;/h3&gt;&lt;p&gt;최근 읽고 있는 ‘임백준의 대살개문’에서 다음과 같은 문구를 접하게 되었다.&lt;/p&gt;
&lt;blockq
      
    
    </summary>
    
      <category term="개발잡담" scheme="https://sogoagain.github.io/categories/%EA%B0%9C%EB%B0%9C%EC%9E%A1%EB%8B%B4/"/>
    
    
      <category term="etc" scheme="https://sogoagain.github.io/tags/etc/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm 문제 Java Code Snippet</title>
    <link href="https://sogoagain.github.io/2019/05/01/Algorithm-%EB%AC%B8%EC%A0%9C%EC%97%90%EC%84%9C-%EB%82%B4%EA%B0%80-%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-Java-Code-Snippet/"/>
    <id>https://sogoagain.github.io/2019/05/01/Algorithm-문제에서-내가-자주-사용하는-Java-Code-Snippet/</id>
    <published>2019-04-30T18:13:54.000Z</published>
    <updated>2019-07-26T18:16:02.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="알고리즘-문제-풀이-시-자주-사용-되는-Code-Snippet-정리"><a href="#알고리즘-문제-풀이-시-자주-사용-되는-Code-Snippet-정리" class="headerlink" title="알고리즘 문제 풀이 시 자주 사용 되는 Code Snippet 정리"></a>알고리즘 문제 풀이 시 자주 사용 되는 Code Snippet 정리</h2><p>한동안 풀었던 알고리즘 문제들의 소스 코드를 스스로 리뷰해보는 시간을 가졌다.<br>알고리즘 문제를 풀 때면 비슷한 코드 조각들을 작성하게 되는데, 그때그때 찾아보거나 생각해서 작성하려니 시간 소요가 생각보다 커지게 되었다. 이와 같은 이유로 이제껏 작성한 코드에서 자주 사용되는 조각들을 추출하여 정리해보았다.</p><p>정리해보니 자료구조의 사용과 관련된 코드들이 많았다. 앞으로 Collection과 람다를 깊게 공부하여 더 좋은 방법이 있으면 바로바로 업데이트할 생각이다.</p><h2 id="HashMap-사용"><a href="#HashMap-사용" class="headerlink" title="HashMap 사용"></a>HashMap 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">results.putIfAbsent(rank, <span class="number">0</span>);</span><br><span class="line">results.computeIfPresent(rank, (k, v) -&gt; ++v);</span><br></pre></td></tr></table></figure><hr><h2 id="List-사용"><a href="#List-사용" class="headerlink" title="List 사용"></a>List 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allCases.removeIf(i -&gt; !Arrays.equals(result, simulate(i, ball)));</span><br></pre></td></tr></table></figure><hr><h2 id="우선순위-큐-사용"><a href="#우선순위-큐-사용" class="headerlink" title="우선순위 큐 사용"></a>우선순위 큐 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumAverageProcessingTime</span><span class="params">(<span class="keyword">int</span>[][] jobs)</span> </span>&#123;</span><br><span class="line">Queue&lt;Job&gt; scheduleQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparing(j -&gt; j.requestedTime));</span><br><span class="line">Arrays.stream(jobs).forEach(j -&gt; scheduleQueue.add(<span class="keyword">new</span> Job(j[<span class="number">0</span>], j[<span class="number">1</span>])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.naturalOrder());</span><br><span class="line">Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.reverseOrder());</span><br></pre></td></tr></table></figure><hr><h2 id="Array를-List로"><a href="#Array를-List로" class="headerlink" title="Array를 List로"></a>Array를 List로</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; participantList = Arrays.asList(participant);</span><br><span class="line">List&lt;Integer&gt; lostStudents = Arrays.stream(lost)</span><br><span class="line">                        .boxed()</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">List&lt;Integer&gt; lostStudents = IntStream.of(lost)</span><br><span class="line">                        .boxed()</span><br><span class="line">                        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; peopleList = Arrays.stream(people)</span><br><span class="line">                    .boxed()</span><br><span class="line">                    .sorted(Comparator.reverseOrder())</span><br><span class="line">                    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><h2 id="List를-Array로"><a href="#List를-Array로" class="headerlink" title="List를 Array로"></a>List를 Array로</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> numbers.stream()</span><br><span class="line">            .mapToInt(i -&gt; i)</span><br><span class="line">            .toArray();</span><br></pre></td></tr></table></figure><h2 id="Array를-Queue로"><a href="#Array를-Queue로" class="headerlink" title="Array를 Queue로"></a>Array를 Queue로</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; dateQueue = Arrays.stream(dates)</span><br><span class="line">                    .boxed()</span><br><span class="line">                    .collect(Collectors.toCollection(LinkedList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><hr><h2 id="Array-정렬"><a href="#Array-정렬" class="headerlink" title="Array 정렬"></a>Array 정렬</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(cubes, Collections.reverseOrder());</span><br><span class="line">Arrays.sort(costs, Comparator.comparing(cost -&gt; cost[<span class="number">2</span>]));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] sorted = IntStream.of(a)</span><br><span class="line">            .boxed()</span><br><span class="line">            .sorted(Comparator.reverseOrder())</span><br><span class="line">            .mapToInt(i -&gt; i)</span><br><span class="line">            .toArray();</span><br><span class="line"><span class="keyword">int</span>[] sortedNumbers = Arrays.stream(numbers)</span><br><span class="line">            .boxed()</span><br><span class="line">            .sorted((Integer o1, Integer o2) -&gt; Integer.valueOf(o2 + <span class="string">""</span> + o1) - Integer.valueOf(o1 + <span class="string">""</span> + o2))</span><br><span class="line">            .mapToInt(i -&gt; i)</span><br><span class="line">            .toArray();</span><br></pre></td></tr></table></figure><hr><h2 id="List에서-최대-최소값-찾기"><a href="#List에서-최대-최소값-찾기" class="headerlink" title="List에서 최대/최소값 찾기"></a>List에서 최대/최소값 찾기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer max = listOfIntegers</span><br><span class="line">            .stream()</span><br><span class="line">            .mapToInt(v -&gt; v)</span><br><span class="line">            .max().orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person minByAge = people</span><br><span class="line">            .stream()</span><br><span class="line">            .min(Comparator.comparing(Person::getAge))</span><br><span class="line">            .orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;알고리즘-문제-풀이-시-자주-사용-되는-Code-Snippet-정리&quot;&gt;&lt;a href=&quot;#알고리즘-문제-풀이-시-자주-사용-되는-Code-Snippet-정리&quot; class=&quot;headerlink&quot; title=&quot;알고리즘 문제 풀이 시 자주 사용
      
    
    </summary>
    
      <category term="개발Tip" scheme="https://sogoagain.github.io/categories/%EA%B0%9C%EB%B0%9CTip/"/>
    
    
      <category term="java" scheme="https://sogoagain.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ에서 Docker로 Web App 배포하기</title>
    <link href="https://sogoagain.github.io/2019/03/08/IntelliJ%EC%97%90%EC%84%9C-Docker%EB%A1%9C-Web-App-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/"/>
    <id>https://sogoagain.github.io/2019/03/08/IntelliJ에서-Docker로-Web-App-배포하기/</id>
    <published>2019-03-07T18:11:20.000Z</published>
    <updated>2019-07-26T18:12:48.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WAR-artifact-빌드"><a href="#WAR-artifact-빌드" class="headerlink" title="WAR artifact 빌드"></a>WAR artifact 빌드</h2><ul><li><p>Project Settings(⌘;) &gt; Artifacts 메뉴 진입</p></li><li><p>(+) 버튼 &gt; Web Application: Archive &gt; For ‘[Project Name]:war exploded’ 클릭</p></li><li><p>생성된 Artifacts의 속성 설정 후 Apply</p><blockquote><p>Output Layout에서 ‘.war’ 파일의 파일명이 Context Root 명이 되므로 원하는 Context Root가 있을 경우 .war 파일명을 변경합니다.<br>.war의 기본 파일명은 [Project Name]_war.war</p></blockquote></li><li><p>Build 메뉴 &gt; Build Artifacts &gt; 위에서 생성한 Artifacts로 빌드</p></li></ul><h2 id="Docker에-올려진-Tomcat-서버로-배포"><a href="#Docker에-올려진-Tomcat-서버로-배포" class="headerlink" title="Docker에 올려진 Tomcat 서버로 배포"></a>Docker에 올려진 Tomcat 서버로 배포</h2><ul><li><p>IntelliJ 하단 Docker 윈도우로 이동</p><blockquote><p>사전에 IntelliJ와 Docker를 연결해야 합니다.</p></blockquote></li><li><p>Docker에 있는 Tomcat 이미지 우클릭 &gt; Create container &gt; Create…</p></li><li><p>팝업된 ‘Create Docker Configuration’에서 컨테이너 정보를 설정</p><ol><li><p>Container name 설정: 차후에 어떤 프로젝트의 컨테이너인지 식별하기 편합니다.</p></li><li><p>Bind ports</p><ul><li>Host port: 8080</li><li>Container port: 8080</li><li>Host IP: 127.0.0.1</li></ul></li><li><p>Bind mounts</p><ul><li>본 글 첫번째 단계에서 빌드한 WAR artifact과 tomcat 배포 경로를 바인딩합니다.</li><li>Host path: [PROJECT_PATH]/out/artifacts/[WAR File Directory]/<blockquote><p>WAR File Directory: WAR artifact 생성 시 특별한 설정을 하지 않았다면, 기본 디렉터리명은 ‘[Project Name]_war’ 입니다. </p></blockquote></li><li>Container path: /usr/local/tomcat/webapps/</li></ul></li><li><p>Run 클릭</p></li></ol></li></ul><h2 id="배포한-Web-Application으로-접속"><a href="#배포한-Web-Application으로-접속" class="headerlink" title="배포한 Web Application으로 접속"></a>배포한 Web Application으로 접속</h2><ul><li>접속 URL: <a href="http://127.0.0.1:8080/[WAR" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:8080/[WAR</a> artifact File Name]/</li></ul><blockquote><p>참고: <a href="https://www.jetbrains.com/help/idea/deploying-a-web-app-into-an-app-server-container.html" rel="external nofollow noopener noreferrer" target="_blank">Deploy a Java web application inside a Tomcat server container</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WAR-artifact-빌드&quot;&gt;&lt;a href=&quot;#WAR-artifact-빌드&quot; class=&quot;headerlink&quot; title=&quot;WAR artifact 빌드&quot;&gt;&lt;/a&gt;WAR artifact 빌드&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Project S
      
    
    </summary>
    
      <category term="도구Tip" scheme="https://sogoagain.github.io/categories/%EB%8F%84%EA%B5%ACTip/"/>
    
    
      <category term="Docker" scheme="https://sogoagain.github.io/tags/Docker/"/>
    
      <category term="IntelliJ" scheme="https://sogoagain.github.io/tags/IntelliJ/"/>
    
  </entry>
  
  <entry>
    <title>ORA-12505 오류 해결</title>
    <link href="https://sogoagain.github.io/2019/02/22/ORA-12505-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/"/>
    <id>https://sogoagain.github.io/2019/02/22/ORA-12505-오류-해결/</id>
    <published>2019-02-21T18:08:57.000Z</published>
    <updated>2019-07-26T18:09:45.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ORA-12505-오류-발생과-해결"><a href="#ORA-12505-오류-발생과-해결" class="headerlink" title="ORA-12505 오류 발생과 해결"></a>ORA-12505 오류 발생과 해결</h2><ul><li>오류 내용: ORA-12505, TNS:listener does not currently know of SID given in connect descriptor</li><li>업무 중 타 시스템의 Oracle DB와 연동하는 작업을 진행 하였습니다. 이전까지 진행했던 Oracle DB 연결 작업의 절차를 따라 진행 하였음에도 ORA-12505 오류가 발생하며 연결에 차질이 생겼습니다. 이 문제를 해결하며 알게된 SID와 Service Name에 대해서 정리해 보았습니다.</li><li>연결에 차질이 생긴 원인은 SID를 이용한 연결과 Service Name을 이용한 연결의 경우 Connection String이 다르기 구성되기 때문이었습니다.</li><li>즉, 이전까지 진행했던 Oracle DB 연동은 SID를 이용하였으나 이번에는 Service Name을 이용하여 연동 작업을 진행했습니다. 그러나, Connection String을 SID 연동하던 사례를 바탕으로 작성하여 Service Name에 맞게 구성하지 못했기 때문에 ORA-12505오류가 발생하였습니다.<blockquote><p>물론 ORA-12505 오류가 발생하는 케이스는 훨씬 다양합니다. 그러나, 저와 같은 상황에 놓인 분들에게 이 글이 도움이 되었으면 좋겠습니다.</p></blockquote></li></ul><h2 id="SID와-Service-Name"><a href="#SID와-Service-Name" class="headerlink" title="SID와 Service Name"></a>SID와 Service Name</h2><ul><li>SID: System Identifier의 약자로 하나의 특정 DB 인스턴스를 식별하는 ID입니다. 즉, 각 데이터베이스 인스턴스에 부여되는 ID입니다.</li><li>Service Name: 여러개의 인스턴스를 모아 하나의 서비스를 구성한 것을 식별하는 이름입니다.</li></ul><h2 id="Connection-String"><a href="#Connection-String" class="headerlink" title="Connection String"></a>Connection String</h2><ul><li>SID를 통한 연결</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username/password@host:port:SID</span><br></pre></td></tr></table></figure><ul><li>Service Name을 통한 연결</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username/password@host:port/SERVICE_NAME</span><br></pre></td></tr></table></figure><ul><li>즉, SID는 “:”를 통해서 Service Name은 “/“을 통해서 연결합니다.</li><li>문자 하나 차이로 간단하지만 막상 이러한 상황을 만나면 해결하는데 꽤 오랜 시간이 걸립니다. Connection String에 오류가 있다고 깨닫는데는 시간이 조금 걸리기 때문입니다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ORA-12505-오류-발생과-해결&quot;&gt;&lt;a href=&quot;#ORA-12505-오류-발생과-해결&quot; class=&quot;headerlink&quot; title=&quot;ORA-12505 오류 발생과 해결&quot;&gt;&lt;/a&gt;ORA-12505 오류 발생과 해결&lt;/h2&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="데이터베이스" scheme="https://sogoagain.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="DB" scheme="https://sogoagain.github.io/tags/DB/"/>
    
      <category term="Oracle" scheme="https://sogoagain.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D에서 Observer패턴을 이용한 연산량 감소</title>
    <link href="https://sogoagain.github.io/2019/02/06/Unity3D%EC%97%90%EC%84%9C-Observer%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%B0%EC%82%B0%EB%9F%89-%EA%B0%90%EC%86%8C/"/>
    <id>https://sogoagain.github.io/2019/02/06/Unity3D에서-Observer패턴을-이용한-연산량-감소/</id>
    <published>2019-02-05T18:03:59.000Z</published>
    <updated>2019-07-26T18:07:51.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><ul><li>도플러 효과를 이용한 실감 음향 기술을 제안하는 프로젝트를 Unity3D와 아두이노(움직이는 스피커)를 이용하여 진행.</li><li>음원의 이동에 따른 도플러 효과를 고려(계산)하기 위하여 Unity3D내 주요 개체들이 음원 개체의 위치를 매순간 참조</li><li>Unity3D내 주요 개체들이 음원 개체를 매번 참조하는 것이 아닌, 음원 개체의 위치가 변경될 때만 위치를 참조하여 계산을 하도록 설계하면 프로그램 연산량이 감소될 것이라 기대</li></ul><h2 id="기존-구현-방법-및-문제점"><a href="#기존-구현-방법-및-문제점" class="headerlink" title="기존 구현 방법 및 문제점"></a>기존 구현 방법 및 문제점</h2><ul><li><p>Unity3D의 MonoBehaviour 클래스의 Update() 메소드를 이용하여 구현</p><ul><li>Update() 메소드는 매 프레임마다 호출되는 이벤트 함수</li><li>주요 개체(Listener, LeftSpeaker, RightSpeaker, RealSoundEffector 등)들의 Update() 메소드에서 매 프레임마다 음원 개체의 위치를 참조하여 연산</li><li>프레임마다 주요 개체들이 음원 개체와의 거리, 출력량, 회전각도, 도플러 효과 적용 등의 연산을 수행</li></ul></li><li><p>위의 방법은 연산 중복으로 인한 비효율 발생</p><ul><li><p>음원 개체가 정지되어 있거나, 움직이는 속도가 느리면 아래의 그림과 같이 연산 중복이 발생</p><p><img src="/images/Unity3D%EC%97%90%EC%84%9C-Observer%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%B0%EC%82%B0%EB%9F%89-%EA%B0%90%EC%86%8C/Operation_Duplication.png" alt="Operation_Duplication"></p><ul><li>음원 개체가 이전과 같은 위치이기 때문에 연산 결과가 동일함에도 프레임이 변경되었기 때문에 불필요 연산 수행</li></ul></li></ul></li></ul><h2 id="Observer-패턴-적용"><a href="#Observer-패턴-적용" class="headerlink" title="Observer 패턴 적용"></a>Observer 패턴 적용</h2><ul><li><p>Observer 패턴</p><ul><li>Subject의 상태가 변할 때 Observer 객체들이 변화를 통지 받고 연산 수행</li></ul></li><li><p>Observer 패턴 적용</p><ul><li>Subject: 음원 개체 (SoundSource)</li><li>Observer: 청자 개체 (Listener), 스피커 개체 (LeftSpeaker, RightSpeaker), 음향 효과 개체 (RealSoundEffector)</li></ul></li><li><p>음원의 위치가 변경되었을 때에만 연산 수행</p><ul><li>성능 향상 기대</li><li>불필요 데이터 제거로 인한 데이터 분석의 편리함 기대</li></ul></li></ul><h2 id="클래스-관계도"><a href="#클래스-관계도" class="headerlink" title="클래스 관계도"></a>클래스 관계도</h2><p><img src="/images/Unity3D%EC%97%90%EC%84%9C-Observer%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%B0%EC%82%B0%EB%9F%89-%EA%B0%90%EC%86%8C/Class_Diagram.png" alt="Class_Diagram"></p><h2 id="주요-소스코드"><a href="#주요-소스코드" class="headerlink" title="주요 소스코드"></a>주요 소스코드</h2><ul><li>음원 개체 (SoundSource) 클래스<ul><li>List를 이용해 Observer 관리</li><li>RegisterObserver, RemoveObserver, NotifyObservers 구현</li><li>Update() 메소드를 이용해 프레임마다 위치 변화 확인</li></ul></li><li>Observer<ul><li>청자 개체 (Listener), 스피커 개체 (LeftSpeaker, RightSpeaker), 음향 효과 개체 (RealSoundEffector) 등</li><li>OnNotify() 메소드를 통해 상태 변화 전달받음</li><li>기존 Update() 메소드에서 연산 불필요</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    if (OnKeyDown())</span><br><span class="line">    &#123;</span><br><span class="line">        audio.Play();</span><br><span class="line">        command.Execute();</span><br><span class="line">    &#125;</span><br><span class="line">    if (position != gameObject.transform.position)</span><br><span class="line">    &#123;</span><br><span class="line">        position = gameObject.transform.position;</span><br><span class="line">        NotifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul><li>동일 기능 수행 시 비교 결과</li></ul><p><img src="/images/Unity3D%EC%97%90%EC%84%9C-Observer%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%B0%EC%82%B0%EB%9F%89-%EA%B0%90%EC%86%8C/result1.png" alt="result1"></p><ul><li>동일 연산량 수행 시 비교 결과</li></ul><p><img src="/images/Unity3D%EC%97%90%EC%84%9C-Observer%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%B0%EC%82%B0%EB%9F%89-%EA%B0%90%EC%86%8C/result2.png" alt="result1"></p><ul><li>결과 분석<ul><li>동일 수행에 대한 연산량이 약 7배 감소</li><li>FPS (초당 프레임 수) 평균값 증가<ul><li>성능 향상</li></ul></li><li>FPS 표준 편차 감소<ul><li>FPS 안정화</li></ul></li></ul></li><li>기대효과<ul><li>Unity3D를 사용하는 다른 프로젝트에도 적용 가능</li><li>Gamer의 캐릭터를 추적해 쫓는 몬스터<ul><li>몬스터 시야에 Gamer가 들어왔을 때 쫓는 기능을 Observer 패턴으로 구현</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;도플러 효과를 이용한 실감 음향 기술을 제안하는 프로젝트를 Unity3D와 아두이노(움직이는 스피커)를 이용하여 진
      
    
    </summary>
    
      <category term="객체지향" scheme="https://sogoagain.github.io/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
    
      <category term="Unity3D" scheme="https://sogoagain.github.io/tags/Unity3D/"/>
    
      <category term="Design Pattern" scheme="https://sogoagain.github.io/tags/Design-Pattern/"/>
    
      <category term="C#" scheme="https://sogoagain.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>가볍게 정리하는 DB 기본</title>
    <link href="https://sogoagain.github.io/2019/01/22/%EA%B0%80%EB%B3%8D%EA%B2%8C-%EC%A0%95%EB%A6%AC%ED%95%98%EB%8A%94-DB-%EA%B8%B0%EB%B3%B8-%EB%82%B4%EC%9A%A9/"/>
    <id>https://sogoagain.github.io/2019/01/22/가볍게-정리하는-DB-기본-내용/</id>
    <published>2019-01-21T17:59:35.000Z</published>
    <updated>2019-07-26T18:02:19.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h2><ul><li>여러 사용자에 의해 공유되어 사용될 목적으로 통합 관리되는 구조화된 데이터의 집합체</li><li>대표적인 데이터베이스<blockquote><ul><li>관계형 데이터베이스</li><li>개체 지향형 데이터베이스</li><li>개체 관계형 데이터베이스</li></ul></blockquote></li></ul><h3 id="데이터베이스-관리-시스템-DBMS"><a href="#데이터베이스-관리-시스템-DBMS" class="headerlink" title="데이터베이스 관리 시스템 (DBMS)"></a>데이터베이스 관리 시스템 (DBMS)</h3><ul><li>데이터베이스를 쉽고 빠르게 관리(입력, 조회, 수정 및 삭제 등)할 수 있도록 도와주는 소프트웨어(응용 프로그램)</li><li>대표적인 RDBMS<blockquote><ul><li>SQL Server</li><li>Oracle</li><li>Sybase</li><li>Informix</li><li>DB2</li></ul></blockquote></li></ul><h3 id="DB-클라이언트-도구"><a href="#DB-클라이언트-도구" class="headerlink" title="DB 클라이언트 도구"></a>DB 클라이언트 도구</h3><ul><li>DBMS는 기본적으로 서버 프로그램이며, DBMS에 접속하여 데이터 관련 작업을 하는 클라이언트 프로그램이 필요<blockquote><ul><li>MS의 SQL Server Management Studio</li></ul></blockquote></li></ul><hr><h2 id="RDB-관계"><a href="#RDB-관계" class="headerlink" title="RDB 관계"></a>RDB 관계</h2><ul><li>테이블은 다음의 세 가지 방식으로 관계를 맺음<ol><li>1:1</li><li>1:N</li><li>N:N<blockquote><p>1:N(일대다) 관계가 가장 많이 사용됨<br>1:N 관계는 부모:자식 관계 특성을 가짐</p></blockquote></li></ol></li></ul><hr><h2 id="용어-및-TIP"><a href="#용어-및-TIP" class="headerlink" title="용어 및 TIP"></a>용어 및 TIP</h2><ol><li>선택한 영역 주석 처리 / 해제: Ctrl + K, C / Ctrl + K, U</li><li>*는 애스터리스크 또는 별표라고 읽는다.</li><li>레코드(record): RDB에서 하나의 정보는 하나의 행으로 저장되는 데 이 행을 레코드라고 함.</li><li>ERD: Entity Relationship Diagram, 테이블(개체) 간의 관계를 나타낸 다이어그램</li></ol><hr><h2 id="SQL-Structured-Query-Language"><a href="#SQL-Structured-Query-Language" class="headerlink" title="SQL (Structured Query Language)"></a>SQL (Structured Query Language)</h2><blockquote><p> 발음: 시퀄 또는 에스큐엘</p><ul><li>사용자가 DBMS와 의사소통 할 때 사용하는 프로그래밍 언어</li></ul></blockquote><h3 id="INSERT-문"><a href="#INSERT-문" class="headerlink" title="INSERT 문"></a>INSERT 문</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 테이블(열<span class="number">1</span>, 열<span class="number">2</span>, ..., 열n)</span><br><span class="line"><span class="keyword">VALUES</span> (값<span class="number">1</span>, 값<span class="number">2</span>, ..., 값n)</span><br></pre></td></tr></table></figure><h3 id="SELECT-문"><a href="#SELECT-문" class="headerlink" title="SELECT 문"></a>SELECT 문</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 열<span class="number">1</span>, 열<span class="number">2</span>, ..., 열n</span><br><span class="line"><span class="keyword">FROM</span> 테이블</span><br><span class="line">[<span class="keyword">WHERE</span> 조건]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> 정렬기준_열 [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>]]</span><br></pre></td></tr></table></figure><h3 id="UPDATE-문"><a href="#UPDATE-문" class="headerlink" title="UPDATE 문"></a>UPDATE 문</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 테이블</span><br><span class="line"><span class="keyword">SET</span> 열<span class="number">1</span> = <span class="string">'값1'</span>, 열<span class="number">2</span> = <span class="string">'값2'</span>, ..., 열n = <span class="string">'값n'</span></span><br><span class="line">[<span class="keyword">WHERE</span> 조건]</span><br></pre></td></tr></table></figure><h3 id="DELETE-문"><a href="#DELETE-문" class="headerlink" title="DELETE 문"></a>DELETE 문</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 테이블</span><br><span class="line">[<span class="keyword">WHERE</span> 조건]</span><br></pre></td></tr></table></figure><h3 id="JOIN-문"><a href="#JOIN-문" class="headerlink" title="JOIN 문"></a>JOIN 문</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.열<span class="number">1</span>, a.열<span class="number">2</span>, ..., a.열n, b.열<span class="number">1</span>, b.열<span class="number">2</span>, ..., b.열<span class="number">3</span></span><br><span class="line"><span class="keyword">FROM</span> A a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B b</span><br><span class="line"><span class="keyword">ON</span> a.열x = b.열x</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.열<span class="number">1</span>, a.열<span class="number">2</span>, ..., a.열n, b.열<span class="number">1</span>, b.열<span class="number">2</span>, ..., b.열<span class="number">3</span></span><br><span class="line"><span class="keyword">FROM</span> A a <span class="keyword">LEFT</span>[<span class="keyword">RIGHT</span>] <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> B b</span><br><span class="line"><span class="keyword">ON</span> a.열x = b.열x</span><br></pre></td></tr></table></figure><hr><h2 id="저장-프로시저-Stored-Procedure"><a href="#저장-프로시저-Stored-Procedure" class="headerlink" title="저장 프로시저 (Stored Procedure)"></a>저장 프로시저 (Stored Procedure)</h2><ul><li>일련의 SQL 구문을 마치 하나의 함수처럼 실행하기 위해 만들어 둔 SQL 구문의 집합</li><li>장점<ol><li>성능 향상: 캐시 메모리에 저장된 결과를 사용 -&gt; 실행 속도 향상</li><li>보안 강화: 저장 프로시저 실행 권한만 부여하는 등 권한 제어 가능</li><li>네트워크 전송량 감소: SQL문 전체를 전송하지 않고 필요한 매개변수만 전달</li><li>모듈식 프로그래밍: 재사용 용이</li></ol></li></ul><hr><h2 id="트랜잭션-Transaction"><a href="#트랜잭션-Transaction" class="headerlink" title="트랜잭션 (Transaction)"></a>트랜잭션 (Transaction)</h2><ul><li>DB에서 더 이상 쪼갤 수 없는 하나로 묶여진 프로세스 처리(조회, 입력, 수정, 삭제) 단위<blockquote><ul><li>트랜잭션 시작:  BEGIN TRANSACTION</li><li>트랜잭션 적용: COMMIT</li><li>트랜잭션 취소: ROLLBACK</li><li>트랜잭션 예외 처리: TRY…CATCH (SQL Server 2005 이후)</li></ul></blockquote></li></ul><h3 id="저장-프로시저-생성-및-트랜잭션-처리"><a href="#저장-프로시저-생성-및-트랜잭션-처리" class="headerlink" title="저장 프로시저 생성 및 트랜잭션 처리"></a>저장 프로시저 생성 및 트랜잭션 처리</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 프로시저명</span><br><span class="line">    @매개변수 데이터형식</span><br><span class="line"><span class="keyword">AS</span>  <span class="comment">-- 매개변수와 실제 실행될 SQL 구문 구분</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">    <span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span>   <span class="comment">-- 트랜잭션 시작</span></span><br><span class="line"></span><br><span class="line">    (처리 내용)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">COMMIT</span>  <span class="comment">-- 트랜잭션에 존재하는 프로세스의 처리 결과 적용</span></span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> CATCH <span class="comment">-- TRY 블럭의 오류 캐치</span></span><br><span class="line">    <span class="keyword">IF</span>(@@TRANCOUNT &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">ROLLBACK</span>    <span class="comment">--  트랜잭션 처리 내용 취소 (이전 상태로 복원)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- TRY 블럭에서 발생한 오류 로깅</span></span><br><span class="line">    <span class="keyword">DECLARE</span> @ErrorMsg <span class="keyword">nvarchar</span>(<span class="number">4000</span>)    <span class="comment">-- 오류 메시지</span></span><br><span class="line">            , @ErrorSeverity <span class="built_in">int</span>        <span class="comment">-- 오류의 심각도</span></span><br><span class="line">    <span class="keyword">SELECT</span> @ErrorMsg = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY()</span><br><span class="line">    RAISERROR(@ErrorMsg, @ErrorSeverity, <span class="number">1</span>) <span class="comment">-- 오류 정보 등록</span></span><br><span class="line"><span class="keyword">END</span> CATCH</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DB&quot;&gt;&lt;a href=&quot;#DB&quot; class=&quot;headerlink&quot; title=&quot;DB&quot;&gt;&lt;/a&gt;DB&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;여러 사용자에 의해 공유되어 사용될 목적으로 통합 관리되는 구조화된 데이터의 집합체&lt;/li&gt;
&lt;li&gt;대표적인 데이터
      
    
    </summary>
    
      <category term="데이터베이스" scheme="https://sogoagain.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="DB" scheme="https://sogoagain.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>가볍게 구분하는 개체, 객체, 인스턴스</title>
    <link href="https://sogoagain.github.io/2019/01/12/%EA%B0%80%EB%B3%8D%EA%B2%8C-%EA%B5%AC%EB%B6%84%ED%95%98%EB%8A%94-%EA%B0%9C%EC%B2%B4-%EA%B0%9D%EC%B2%B4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4/"/>
    <id>https://sogoagain.github.io/2019/01/12/가볍게-구분하는-개체-객체-인스턴스/</id>
    <published>2019-01-11T17:56:16.000Z</published>
    <updated>2019-07-26T17:57:38.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개체"><a href="#개체" class="headerlink" title="개체"></a>개체</h2><p> 프로그래밍에서 이르는 모든 요소<br> OOP에서는 Class의 Instance</p><h2 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h2><p>개체를 취급할 때 주체 측에서 상대적으로 이르는 말</p><h2 id="인스턴스"><a href="#인스턴스" class="headerlink" title="인스턴스"></a>인스턴스</h2><p>추상화 기법 중 분류/인스턴스화(classification/instantiation) 개념으로 접근<br>인스턴스: 추상적인 개념과 구체적인 실체 사이 <em>관계</em>에 초점</p><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><blockquote><ol><li><a href="https://social.msdn.microsoft.com/Forums/ko-KR/c095ed0e-0f92-4c1b-8251-5950b4a1ca14/ctip-4406052404204913963650752-4406152404234583963651032?forum=visualcsharpko" rel="external nofollow noopener noreferrer" target="_blank">https://social.msdn.microsoft.com/Forums/ko-KR/c095ed0e-0f92-4c1b-8251-5950b4a1ca14/ctip-4406052404204913963650752-4406152404234583963651032?forum=visualcsharpko</a></li><li><a href="https://www.slipp.net/questions/126" rel="external nofollow noopener noreferrer" target="_blank">https://www.slipp.net/questions/126</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개체&quot;&gt;&lt;a href=&quot;#개체&quot; class=&quot;headerlink&quot; title=&quot;개체&quot;&gt;&lt;/a&gt;개체&lt;/h2&gt;&lt;p&gt; 프로그래밍에서 이르는 모든 요소&lt;br&gt; OOP에서는 Class의 Instance&lt;/p&gt;
&lt;h2 id=&quot;객체&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="객체지향" scheme="https://sogoagain.github.io/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
    
      <category term="OOP" scheme="https://sogoagain.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>SourceTree &#39;Permission denied (publickey)&#39; 에러</title>
    <link href="https://sogoagain.github.io/2019/01/08/SourceTree-Permission-denied-publickey-%EC%97%90%EB%9F%AC/"/>
    <id>https://sogoagain.github.io/2019/01/08/SourceTree-Permission-denied-publickey-에러/</id>
    <published>2019-01-07T17:49:48.000Z</published>
    <updated>2019-07-26T17:54:56.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="상황"><a href="#상황" class="headerlink" title="상황"></a>상황</h2><p>SourceTree에서 원격저장소에 접근(푸쉬/풀/클론 등)을 할 때 ‘ ‘Permission denied (publickey)’ 에러 발생</p><h2 id="원인"><a href="#원인" class="headerlink" title="원인"></a>원인</h2><p>PC SSH Agent에 key가 등록되어 있지 않았을 때 발생</p><h2 id="확인-방법"><a href="#확인-방법" class="headerlink" title="확인 방법"></a>확인 방법</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Putty실행 후 등록된 key 리스트 확인</p><h3 id="On-GitBash-OSX-or-Linux"><a href="#On-GitBash-OSX-or-Linux" class="headerlink" title="On GitBash, OSX or Linux"></a>On GitBash, OSX or Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -l</span><br></pre></td></tr></table></figure><h2 id="등록된-key가-없을-때-해결법"><a href="#등록된-key가-없을-때-해결법" class="headerlink" title="등록된 key가 없을 때 해결법"></a>등록된 key가 없을 때 해결법</h2><h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h3><p>Putty실행 후 ‘Add Key’ 버튼을 이용해 키 추가</p><h3 id="On-GitBash-OSX-or-Linux-1"><a href="#On-GitBash-OSX-or-Linux-1" class="headerlink" title="On GitBash, OSX or Linux"></a>On GitBash, OSX or Linux</h3><p>아래의 명령어를 통해 키 추가<br>(identity는 자신의 키 파일명으로 대체)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/identity</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;상황&quot;&gt;&lt;a href=&quot;#상황&quot; class=&quot;headerlink&quot; title=&quot;상황&quot;&gt;&lt;/a&gt;상황&lt;/h2&gt;&lt;p&gt;SourceTree에서 원격저장소에 접근(푸쉬/풀/클론 등)을 할 때 ‘ ‘Permission denied (publickey
      
    
    </summary>
    
      <category term="도구Tip" scheme="https://sogoagain.github.io/categories/%EB%8F%84%EA%B5%ACTip/"/>
    
    
      <category term="SourceTree" scheme="https://sogoagain.github.io/tags/SourceTree/"/>
    
      <category term="SSH" scheme="https://sogoagain.github.io/tags/SSH/"/>
    
      <category term="git" scheme="https://sogoagain.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>SimpleScalar를 이용한 Cache Simulation</title>
    <link href="https://sogoagain.github.io/2017/06/27/SimpleScalar%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Cache-Simulation/"/>
    <id>https://sogoagain.github.io/2017/06/27/SimpleScalar를-이용한-Cache-Simulation/</id>
    <published>2017-06-26T17:31:50.000Z</published>
    <updated>2019-07-26T17:48:06.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p> Matrix Multiplication을 IJK, IKJ, InnerTile, OuterTile의 4가지 방법으로 구현한 후 각 프로그램의 수행 시간을 측정한다. 프로그램들의 성능 차이를 SimpleScalar를 이용한 cache simulation을 통해 도출된 cache miss rate를 바탕으로 설명한다.</p><h2 id="SimpleScalar-설치-및-시뮬레이션-환경-구축"><a href="#SimpleScalar-설치-및-시뮬레이션-환경-구축" class="headerlink" title="SimpleScalar 설치 및 시뮬레이션 환경 구축"></a>SimpleScalar 설치 및 시뮬레이션 환경 구축</h2><h3 id="SimpleScalar-설치"><a href="#SimpleScalar-설치" class="headerlink" title="SimpleScalar 설치"></a>SimpleScalar 설치</h3><p> SimpleScalar 홈페이지에서 simplesim(3.0v), simpletools(2.0v), simpleutils를 내려받아 설치하였다. 해당 설치파일에서 크로스컴파일을 위해 제공되는 gcc 2.6.3버전은 Ubuntu 16.04에서 원활히 설치되지 않는다. 따라서, gcc 2.7.2.3을 이용해 크로스컴파일 환경을 구축하였다.</p><h3 id="SimpleScalar-설치-과정-중-문제-해결"><a href="#SimpleScalar-설치-과정-중-문제-해결" class="headerlink" title="SimpleScalar 설치 과정 중 문제 해결"></a>SimpleScalar 설치 과정 중 문제 해결</h3><p> SimpleScalar의 메인 프로그램인 simplesim을 설치하는 과정에서는 큰 문제가 없었다. simplesim을 설치하는 과정에서는 환경변수를 설정하고 압축을 풀고 make를 해주면 설치가 완료되었다. 그러나, GCC cross-compiler를 설치하는 과정에서 많은 문제가 일어났다. GCC 7.1버전이 나온 지금 GCC 2.6.3을 설치하려고 하니 쉽지 않았다. 프로젝트를 진행하는 환경에는 GCC 5.4.0버전이 설치되어 있었는데, 해당 버전으로 GCC 2.6.3을 컴파일하려니 많은 문법 오류가 발생했다. 문법 오류가 발생하면 오류가 발생한 소스코드를 찾아 문제를 해결하고 다시 컴파일하는 과정을 반복해야만 했다. cross-compiler를 설치하는 과정 중 대부분은 다음의 사이트에서 도움을 받았다.</p><blockquote><p>“Installing simplescalar on Ubuntu 16.04”</p><p>(<a href="http://io.wxa.me/simulation/2017/03/13/simplescalar_installation" rel="external nofollow noopener noreferrer" target="_blank">http://io.wxa.me/simulation/2017/03/13/simplescalar_installation</a>)</p></blockquote><h3 id="sim-cache-환경설정-파일"><a href="#sim-cache-환경설정-파일" class="headerlink" title="sim-cache 환경설정 파일"></a>sim-cache 환경설정 파일</h3><p>cache크기: 64Kb, cache line size: 32bytes, 블록 교체 방식: LRU</p><ul><li><ol><li>Direct_mapped_cache.cfg</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-cache:il1 dl1</span><br><span class="line">-cache:dl1 dl1:2048:32:1:l</span><br><span class="line"># Instruction L1 cache,</span><br><span class="line"># # of sets = 2048, block size = 32, No of sets = 1 so Cache size = 2048*32*1 = 64 Kbytes,</span><br><span class="line"># Replacement = LRU</span><br><span class="line">-cache:il2 none</span><br><span class="line">-cache:dl2 none</span><br><span class="line">-tlb:itlb none</span><br><span class="line">-tlb:dtlb none</span><br></pre></td></tr></table></figure></li><li><ol start="2"><li>4way_set_associative.cfg</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-cache:il1 dl1</span><br><span class="line">-cache:dl1 dl1:512:32:4:l</span><br><span class="line"># Instruction L1 cache,</span><br><span class="line"># # of sets = 512, block size = 32, No of sets = 4 so Cache size = 512*32*4 = 64 Kbytes,</span><br><span class="line"># Replacement = LRU</span><br><span class="line">-cache:il2 none</span><br><span class="line">-cache:dl2 none</span><br><span class="line">-tlb:itlb none</span><br><span class="line">-tlb:dtlb none</span><br></pre></td></tr></table></figure></li><li><p>환경설정 파일을 이용한 sim-cache 실행</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sim-cache -config direct_mapped_cache.cfg ./IJK 256</span><br><span class="line">sim-cache -config 4way_set_associative.cfg ./IJK 64</span><br></pre></td></tr></table></figure></li></ul><h2 id="Matrix-Multiplication-구현"><a href="#Matrix-Multiplication-구현" class="headerlink" title="Matrix Multiplication 구현"></a>Matrix Multiplication 구현</h2><p> Matrix Multiplication을 IJK, IKJ, InnerTile, OuterTile의 4가지 방법으로 구현한 후 각 프로그램의 수행 시간을 측정한다.</p><h3 id="공통-소스코드"><a href="#공통-소스코드" class="headerlink" title="공통 소스코드"></a>공통 소스코드</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 행렬 초기화</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;size*size; i++) &#123;</span><br><span class="line">        a[i] = <span class="number">1</span>;</span><br><span class="line">        b[i] = <span class="number">1</span>;</span><br><span class="line">        c[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 행렬 곱셈</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">multiply</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">(생략)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;              <span class="comment">// 행렬 사이즈</span></span><br><span class="line">    <span class="keyword">long</span> cpu_time;    <span class="comment">// 실행 시간</span></span><br><span class="line">    <span class="keyword">int</span> *a, *b, *c;     <span class="comment">// 행렬</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 입력 예외처리</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s [size]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    n = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 행렬 생성</span></span><br><span class="line">    a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n*n);</span><br><span class="line">    b = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n*n);</span><br><span class="line">    c = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n*n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 행렬 초기화</span></span><br><span class="line">    <span class="comment">// 값에 따른 연산 차이를 최소화하기 위해 상수로 초기화</span></span><br><span class="line">    init(a, b, c, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 행렬 곱셈</span></span><br><span class="line">    cpu_time = multiply(a, b, c, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cpu_time: %ldms\n"</span>, cpu_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 자원반납</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IJK-c"><a href="#IJK-c" class="headerlink" title="IJK.c"></a>IJK.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 행렬 곱셈</span></span><br><span class="line"><span class="comment">// IJK</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">multiply</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start, end;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">                c[i*size+j] += a[i*size+k] * b[k*size+j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IKJ-c"><a href="#IKJ-c" class="headerlink" title="IKJ.c"></a>IKJ.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 행렬 곱셈</span></span><br><span class="line"><span class="comment">// IKJ</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">multiply</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start, end;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                c[i*size+j] += a[i*size+k] * b[k*size+j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InnetTile-c"><a href="#InnetTile-c" class="headerlink" title="InnetTile.c"></a>InnetTile.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 행렬 곱셈</span></span><br><span class="line"><span class="comment">// InnerTile</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">multiply</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c, <span class="keyword">int</span> size, <span class="keyword">int</span> s1, <span class="keyword">int</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start, end;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t1, t2;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span>(t1 = <span class="number">0</span>; t1 &lt; size; t1+=s1) &#123;</span><br><span class="line">        <span class="keyword">for</span>(t2 = <span class="number">0</span>; t2 &lt; size; t2+=s2) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(k = t1; k &lt; MIN(size, t1+s1); k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(j = t2; j &lt; MIN(size, t2+s2); j++) &#123;</span><br><span class="line">                        c[i*size+j] += a[i*size+k] * b[k*size+j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OuterTile-c"><a href="#OuterTile-c" class="headerlink" title="OuterTile.c"></a>OuterTile.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 행렬 곱셈</span></span><br><span class="line"><span class="comment">// OuterTile</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">multiply</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c, <span class="keyword">int</span> size, <span class="keyword">int</span> s1, <span class="keyword">int</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start, end;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t1, t2;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span>(t1 = <span class="number">0</span>; t1 &lt; size; t1+=s1) &#123;</span><br><span class="line">        <span class="keyword">for</span>(t2 = <span class="number">0</span>; t2 &lt; size; t2+=s2) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = t1; i &lt; MIN(size, t1+s1); i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(k = t2; k &lt; MIN(size, t2+s2); k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                        c[i*size+j] += a[i*size+k] * b[k*size+j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="수행시간-측정"><a href="#수행시간-측정" class="headerlink" title="수행시간 측정"></a>수행시간 측정</h2><p> 행렬의 크기가 1024 이상이 되면 프로그램 실행시간이 측정하기 힘들 정도로 긴 시간동안 프로그램이 수행되었다. 따라서 1024 이하 크기에 대한 연산 수행시간을 측정하였다.</p><p><img src="/images/SimpleScalar%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Cache-Simulation/summary_exec_time.png" alt="summary_exec_time"></p><h2 id="Cache-miss-rate-측정"><a href="#Cache-miss-rate-측정" class="headerlink" title="Cache miss rate 측정"></a>Cache miss rate 측정</h2><p> sim-cache를 이용해 Cache miss rate를 측정하였다. 시뮬레이션 환경은 Direct mapped cache와 4-way set associative의 2가지 환경이다. 각각의 환경은 미리 정의한 환경설정 파일(.cfg)를 통해 불러온다. sim-cache를 통해 프로그램을 시뮬레이션하면 기존의 환경보다 수행 속도가 더뎠다. 따라서 IJK와 IKJ경우에는 300이하의 크기에 대해서 시뮬레이션을 실시하였고, InnerTile과 OuterTile의 경우에는 256, 300, 512 크기에 대해 시뮬레이션을 진행하였다.</p><ul><li>InnerTile과 OuterTile의 시뮬레이션 조건은 다음과 같다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">N=256, 300, 512</span><br><span class="line">N=256: inner tile의 t1=8, t2=8</span><br><span class="line">        outer tile t1=8, t2=1 (direct), t1=6, t2=1(4-way)</span><br><span class="line">N=300: inner tile의 t1=40, t2=40</span><br><span class="line">        outer tile t1=6, t2=1 (direct), t1=4, t2=1(4-way)</span><br><span class="line">N=512: inner tile의 t1=4, t2=4</span><br><span class="line">        outer tile t1=4, t2=1 (direct), t1=2, t2=1(4-way)</span><br></pre></td></tr></table></figure><h3 id="Direct-Mapped-Cache"><a href="#Direct-Mapped-Cache" class="headerlink" title="Direct Mapped Cache"></a>Direct Mapped Cache</h3><p><img src="/images/SimpleScalar%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Cache-Simulation/direct_cache.png" alt="direct_cache"></p><h3 id="4-way-Set-Associate"><a href="#4-way-Set-Associate" class="headerlink" title="4-way Set Associate"></a>4-way Set Associate</h3><p><img src="/images/SimpleScalar%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Cache-Simulation/4way_cache.png" alt="4way_cache"></p><h2 id="분석-및-고찰"><a href="#분석-및-고찰" class="headerlink" title="분석 및 고찰"></a>분석 및 고찰</h2><h3 id="IJK와-IKJ의-비교"><a href="#IJK와-IKJ의-비교" class="headerlink" title="IJK와 IKJ의 비교"></a>IJK와 IKJ의 비교</h3><p> 행렬의 크기가 커질수록 IJK의 수행시간보다 IKJ의 수행시간이 훨씬 짧아졌다. cache miss rate 또한 IJK보다 IKJ가 낮았다. 행렬의 크기가 512 이상으로 커질 경우 simplescalar 시뮬레이션하지 못할 만큼 걸리는 시간이 매우 길어 측정하지 못하였지만, cache miss rate의 변화 추세를 보아 IKJ가 IJK보다 낮을 것으로 예상한다.</p><p> 프로그램에서 행렬을 표현하기 위해 2차원 배열을 사용한다. 그런데, 실제 프로그램 내부에서 2차원 배열은 메모리에 순차적으로 나열된다. 따라서, 같은 행에 있는 행렬의 원소들이 메모리상 근처에 위치한다. IKJ가 수행되는 과정을 보면 IJK와 달리 행을 변경하며 연산하지 않기 때문에 cache miss rate가 낮고 수행시간이 빠르다. cache miss가 자주 일어나면 교체작업에 대한 시간 지연이 발생하므로 대체로 cache miss rate가 낮으면 수행시간 또한 빠를 것이라 예상한다.</p><h3 id="InnerTile과-OuterTile의-비교"><a href="#InnerTile과-OuterTile의-비교" class="headerlink" title="InnerTile과 OuterTile의 비교"></a>InnerTile과 OuterTile의 비교</h3><p> InnerTile과 OuterTile 모두 블록화 알고리즘이다. 블록화 알고리즘은 블록 단위로 배열을 처리함으로써 캐시에 적재된 데이터가 교체되기 전에 최대한 사용하도록 함으로써 Cache miss rate를 줄이는 것이 목표다. 실험 결과 InnerTile과 OuterTile모두 IJK/IKJ보다 Cache miss rate가 낮다는 것을 확인할 수 있었다.</p><p> InnerTile과 OuterTile의 수행시간을 비교해보면 OuterTile이 InnerTile보다 연산에 걸리는 시간이 짧았다. OuterTile은 제일 내부 반복문에서 행단위 연산을 수행하기 때문에 InnerTile에 비해 수행시간이 짧은 것으로 생각한다.</p><h3 id="Direct-Mapped-Cache와-4-way-Set-Associative-Cache-비교"><a href="#Direct-Mapped-Cache와-4-way-Set-Associative-Cache-비교" class="headerlink" title="Direct Mapped Cache와 4-way Set Associative Cache 비교"></a>Direct Mapped Cache와 4-way Set Associative Cache 비교</h3><p> 같은 알고리즘에 대하여 Direct mapped cache와 4-way set associative cache의 cache miss rate를 비교했을 때 4-way set associative cache가 더 낮았다. 이를 통해 직접 사상방식을 사용하는 것보다 집합 연관 방식을 사용하는 것이 cache 실패율을 줄일 수 있다는 것을 확인할 수 있었다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt; Matrix Multiplication을 IJK, IKJ, InnerTile, OuterTile의 4가지 방법으로 구현한 후
      
    
    </summary>
    
      <category term="컴퓨터구조" scheme="https://sogoagain.github.io/categories/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/"/>
    
    
      <category term="Computer architecture" scheme="https://sogoagain.github.io/tags/Computer-architecture/"/>
    
      <category term="SimpleScalar" scheme="https://sogoagain.github.io/tags/SimpleScalar/"/>
    
      <category term="Cache memory" scheme="https://sogoagain.github.io/tags/Cache-memory/"/>
    
  </entry>
  
  <entry>
    <title>나의 vimrc</title>
    <link href="https://sogoagain.github.io/2017/01/29/%EB%82%98%EC%9D%98-vimrc/"/>
    <id>https://sogoagain.github.io/2017/01/29/나의-vimrc/</id>
    <published>2017-01-28T17:24:55.000Z</published>
    <updated>2019-07-26T17:26:35.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="나의-Vimrc-설정"><a href="#나의-Vimrc-설정" class="headerlink" title="나의 Vimrc 설정"></a>나의 Vimrc 설정</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible</span><br><span class="line">filetype off</span><br><span class="line"></span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line"></span><br><span class="line">Plugin 'VundleVim/Vundle.vim'</span><br><span class="line">Plugin 'tpope/vim-fugitive'</span><br><span class="line">Plugin 'tpope/vim-sensible'         " vim 세팅을 표준으로 설정하는 플러그인</span><br><span class="line">Plugin 'scrooloose/nerdtree'     " 파일 네비게이션 바 :NERDTree</span><br><span class="line">Plugin 'scrooloose/syntastic'     " 문법 highlighting</span><br><span class="line">Plugin 'scrooloose/nerdcommenter'     " 코맨트를 쉽고 간편하게 만들어주는 플러그인</span><br><span class="line">Plugin 'mattn/emmet-vim'</span><br><span class="line">Plugin 'nathanaelkane/vim-indent-guides'" indent 깊이 표현</span><br><span class="line">Plugin 'Shougo/neocomplcache.vim'    " 자동완성 플러그인</span><br><span class="line">Plugin 'altercation/vim-colors-solarized'" Solarized 테마</span><br><span class="line">Plugin 'bling/vim-airline'</span><br><span class="line">Plugin 'vim-airline/vim-airline-themes'</span><br><span class="line">Plugin 'Raimondi/delimitMate'</span><br><span class="line"></span><br><span class="line">call vundle#end()</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">set nu  "add line numbers</span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">" Solarized 테마</span><br><span class="line">set background=dark</span><br><span class="line">colorscheme solarized</span><br><span class="line">let g:airline_theme='solarized'</span><br><span class="line"></span><br><span class="line">" TAB SIZE 설정</span><br><span class="line">set ts=4 sw=4 et</span><br><span class="line"></span><br><span class="line">" Indent Guides 설정</span><br><span class="line">let g:indent_guides_start_level=2</span><br><span class="line">let g:indent_guides_guide_size=1</span><br><span class="line">au VimEnter * IndentGuidesEnable</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;나의-Vimrc-설정&quot;&gt;&lt;a href=&quot;#나의-Vimrc-설정&quot; class=&quot;headerlink&quot; title=&quot;나의 Vimrc 설정&quot;&gt;&lt;/a&gt;나의 Vimrc 설정&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="도구Tip" scheme="https://sogoagain.github.io/categories/%EB%8F%84%EA%B5%ACTip/"/>
    
    
      <category term="vim" scheme="https://sogoagain.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>C++에서 대입 연산자를 오버로딩 하는 괜찮은 방법</title>
    <link href="https://sogoagain.github.io/2017/01/14/C-%EC%97%90%EC%84%9C-%EB%8C%80%EC%9E%85-%EC%97%B0%EC%82%B0%EC%9E%90%EB%A5%BC-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9-%ED%95%98%EB%8A%94-%EA%B4%9C%EC%B0%AE%EC%9D%80-%EB%B0%A9%EB%B2%95/"/>
    <id>https://sogoagain.github.io/2017/01/14/C-에서-대입-연산자를-오버로딩-하는-괜찮은-방법/</id>
    <published>2017-01-13T17:17:08.000Z</published>
    <updated>2019-07-26T17:22:58.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-로-LinkedList를-구현할-때의-고민"><a href="#C-로-LinkedList를-구현할-때의-고민" class="headerlink" title="C++로 LinkedList를 구현할 때의 고민"></a>C++로 LinkedList를 구현할 때의 고민</h2><p> LinkedList 구현에서 =연산자 오버 로딩을 어떻게 할까 봐 고민하던 중 굉장히 멋진 방법을 찾았다. 이 방법은 깊은 복사를 하는 복사 생성자가 제대로 구현되어 있어야 하고 소멸자 또한 메모리 정리를 깔끔히 한다는 것을 전제로 한다. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkedList&lt;T&gt;&amp; LinkedList&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> LinkedList&lt;T&gt;&amp; reference) &#123;</span><br><span class="line">    LinkedList&lt;T&gt; temp = reference;</span><br><span class="line">    size = temp.getSize();</span><br><span class="line">    <span class="built_in">std</span>::swap(temp.head, head);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h2><p> 방법은 다음과 같다. LinkedList의 임시 객체를 복사 생성자를 통해 생성한 뒤 swap을 통해 임시 객체의 head 포인터 값과 현재 객체의 head 포인터 값을 변경한 뒤 현재 객체를 반환한다. </p><h2 id="Nice한-요소"><a href="#Nice한-요소" class="headerlink" title="Nice한 요소"></a>Nice한 요소</h2><p>임시 객체를 복사 생성자를 통해 만들었으므로 임시 객체가 가진 데이터는 피연산 객체의 데이터와 완전히 같다. 그 뒤 head 포인터를 변경함으로써 현재 객체가 그 데이터를 갖게 되고 임시 객체는 현재 객체가 원래 가지고 있었던 데이터를 갖게 된다. 함수가 끝날 때 임시객체의 소멸 자가 호출되므로 임시 객체가 가지고 있던 정리 해야 할 데이터들이 말끔히 정리된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C-로-LinkedList를-구현할-때의-고민&quot;&gt;&lt;a href=&quot;#C-로-LinkedList를-구현할-때의-고민&quot; class=&quot;headerlink&quot; title=&quot;C++로 LinkedList를 구현할 때의 고민&quot;&gt;&lt;/a&gt;C++로 Linke
      
    
    </summary>
    
      <category term="코드Tip" scheme="https://sogoagain.github.io/categories/%EC%BD%94%EB%93%9CTip/"/>
    
    
      <category term="C++" scheme="https://sogoagain.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>르블랑의 법칙</title>
    <link href="https://sogoagain.github.io/2017/01/06/%EB%A5%B4%EB%B8%94%EB%9E%91%EC%9D%98-%EB%B2%95%EC%B9%99/"/>
    <id>https://sogoagain.github.io/2017/01/06/르블랑의-법칙/</id>
    <published>2017-01-05T17:11:17.000Z</published>
    <updated>2019-07-26T17:23:33.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="나는-현재-충분히-아름다운-코드를-짜고-있는가"><a href="#나는-현재-충분히-아름다운-코드를-짜고-있는가" class="headerlink" title="나는 현재 충분히 아름다운 코드를 짜고 있는가?"></a>나는 현재 충분히 아름다운 코드를 짜고 있는가?</h1><p>우리 모두는 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이 있다. 우리 모두는 대충 짠 프로그램이 돌아간다는 사실에 안도감을 느끼며 그래도 안 돌아가는 프로그램보다 돌아가는 쓰레기가 좋다고 스스로를 위로한 경험이 있다. 다시 돌아와 나중에 정리하겠다고 다짐했었다. 물론 그때 그 시절 우리는 <em>르블랑의 법칙</em>을 몰랐다. <strong>나중은 결코 오지 않는다.</strong></p><blockquote><p>Clean Code (로버트 C.마틴)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;나는-현재-충분히-아름다운-코드를-짜고-있는가&quot;&gt;&lt;a href=&quot;#나는-현재-충분히-아름다운-코드를-짜고-있는가&quot; class=&quot;headerlink&quot; title=&quot;나는 현재 충분히 아름다운 코드를 짜고 있는가?&quot;&gt;&lt;/a&gt;나는 현재 충분히 
      
    
    </summary>
    
      <category term="개발잡담" scheme="https://sogoagain.github.io/categories/%EA%B0%9C%EB%B0%9C%EC%9E%A1%EB%8B%B4/"/>
    
    
      <category term="etc" scheme="https://sogoagain.github.io/tags/etc/"/>
    
  </entry>
  
  <entry>
    <title>가상함수와 가상상속</title>
    <link href="https://sogoagain.github.io/2017/01/05/%EA%B0%80%EC%83%81%ED%95%A8%EC%88%98%EC%99%80-%EA%B0%80%EC%83%81%EC%83%81%EC%86%8D/"/>
    <id>https://sogoagain.github.io/2017/01/05/가상함수와-가상상속/</id>
    <published>2017-01-04T17:05:53.000Z</published>
    <updated>2019-07-26T17:14:33.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="가상-함수"><a href="#가상-함수" class="headerlink" title="가상 함수"></a>가상 함수</h2><h3 id="배경-및-필요성"><a href="#배경-및-필요성" class="headerlink" title="배경 및 필요성"></a>배경 및 필요성</h3><ul><li>비가상함수의 경우 부모 클래스형 포인터로 자식 클래스의 멤버 함수를 호출할 때 컴파일러는 포인터의 자료형을 기준으로 멤버 함수를 호출한다. 즉, 실제 가리키는 객체의 자료형을 기준으로 판단하지 않는다. 자식 클래스에서 부모 클래스 함수를 오버라이딩 했다는 것은, 해당 객체에서 호출되어야 하는 함수의 행위가 바뀐다는 것인데 비가상함수의 경우 이를 지원하지 못한다. 이는 다형성 개념과 충돌된다. 따라서 객체지향에서는 가상 함수라는 개념을 제공한다. 가상 함수를 이용하면 포인터의 자료형을 기반으로 호출대상을 결정하지 않고, 포인터 변수가 실제로 가리키는 객체를 참조하여 호출의 대상을 결정한다. 이 개념은 객체 지향 프로그래밍의 다형성에서 중요한 부분이다.</li></ul><h3 id="동적-바인딩"><a href="#동적-바인딩" class="headerlink" title="동적 바인딩"></a>동적 바인딩</h3><ul><li>바인딩이란 함수 호출문에 대해 실제 호출될 함수가 위치한 메모리 번지를 연결해주는 것을 말한다. 바인딩 시간에 따라 정적 바인딩과 동적 바인딩으로 분류된다. 정적 바인딩은 컴파일 시간에 프로그래밍 문법을 바탕으로 함수 호출문과 함수가 위치한 메모리 번지를 연결한다. 동적 바인딩은 프로그램이 실행되고 있는 런타임 시간에 함수 호출문과 실제 함수의 메모리 번지와의 결합이 일어난다. 동적 바인딩은 가상함수 테이블을 이용하며 포인터(또는 레퍼런스)로 호출할 때만 일어난다. 동적 바인딩은 점프할 메모리 번지를 저장하기 위한 메모리 공간을 가지고 있다가 런타임에 결정되므로 타입 검사로 인한 수행 속도 저하와 메모리가 낭비된다는 단점을 가지고 있다. 하지만 이러한 단점에도 불구하고 동적 바인딩은 정확히 실 객체의 멤버 함수와 결합해주기 때문에 사용된다. 이렇게 동적 바인딩이 된 함수를 가상 함수라고 한다.</li></ul><h3 id="가상-함수-테이블"><a href="#가상-함수-테이블" class="headerlink" title="가상 함수 테이블"></a>가상 함수 테이블</h3><ul><li>가상 함수 테이블은 동적 바인딩을 지원하기 위해 프로그래밍 언어에서 사용되는 메커니즘이다. 동적 바인딩을 구현하는 여러 다른 방법들이 있지만, 가상 함수 테이블 방법은 C++과 관련된 언어들에서 주로 사용된다. 클래스가 가상 함수를 정의할 때마다, 클래스에 숨겨진 멤버 변수가 추가되는데, 이것은 함수들에 대한 포인터들의 배열(가상 함수 테이블)을 가리킨다. 컴파일 타임에는 부모 클래스의 함수가 호출될 것인지 자식 클래스에 의해 구현된 함수가 호출될 것인지 알려지지 않았기 때문에 가상 함수 테이블을 이용해 실행 기간 도중에 정확한 함수를 가리키게 된다.</li></ul><h3 id="프로그래밍-언어에서의-지원"><a href="#프로그래밍-언어에서의-지원" class="headerlink" title="프로그래밍 언어에서의 지원"></a>프로그래밍 언어에서의 지원</h3><ul><li>가상함수라는 개념은 객체지향의 개념이다. 따라서 여러 객체지향 언어에서 가상함수 개념의 문법이 제공된다. 적용하는 방법에는 약간의 차이를 보인다. 예를 들어 C++의 경우 virtual 키워드를 함수 선언부에 추가한다. JAVA의 경우 디폴트가 가상함수이므로 따로 키워드를 적어줄 필요가 없다. C++의 경우 부모 클래스에서 가상함수가 선언되고 나면, 이 함수를 오버라이딩 하는 함수도 가상함수가 된다.</li></ul><h3 id="추상-클래스와-순수-가상-함수"><a href="#추상-클래스와-순수-가상-함수" class="headerlink" title="추상 클래스와 순수 가상 함수"></a>추상 클래스와 순수 가상 함수</h3><ul><li>순수 가상 함수란 함수의 몸체가 정의되지 않은 함수를 의미한다. 순수 가상 함수는 일반적으로 선언은 하지만 정의는 갖지 않는다. 즉 유도 클래스에 의해 구체적인 행위가 구현되는 가상함수다. 순수 가상 함수를 포함하는 클래스를 추상 클래스라고 하며 객체를 생성할 수 없다. 오직 추상 클래스의 하위 클래스만이 직접 인스턴스화 될 수 있다.</li></ul><h3 id="가상-소멸자"><a href="#가상-소멸자" class="headerlink" title="가상 소멸자"></a>가상 소멸자</h3><ul><li>일반적으로 JAVA와 같은 객체 지향 언어들은 객체가 생성되거나 소멸될 때 자동적으로 메모리 할당과 회수를 관리한다. 그러나 C++과 같은 몇몇 객체 지향 언어들은 프로그래머가 직접 소멸자 함수를 구현해 메모리 할당과 회수를 관리해야 한다. 수동으로 메모리를 관리해야 하는 상황에서 다형성을 이용해 참조한 객체를 소멸할 때 가상 소멸자를 이용하지 않으면 부모 클래스의 소멸자만 호출되어 메모리 누수가 발생한다. 따라서 이러면 virtual과 같은 가상 함수 키워드를 이용하여 소멸자를 가상 소멸자로 선언한다. 가상 소멸자가 호출되면, 하위 클래스의 소멸자부터 상위 클래스의 소멸자가 순차적으로 호출된다.</li></ul><h2 id="가상-상속"><a href="#가상-상속" class="headerlink" title="가상 상속"></a>가상 상속</h2><h3 id="다중상속"><a href="#다중상속" class="headerlink" title="다중상속"></a>다중상속</h3><ul><li>다중상속이란, 둘 이상의 클래스를 동시에 상속하는 것을 말한다. JAVA는 다중 상속을 지원하지 않지만 C+++은 다중상속을 지원하는 객체지향 언어다. 일반적으로 다중상속은 다양한 문제를 동반하므로 다중상속에 대한 프로그래머들의 다양한 견해가 있다.</li></ul><h3 id="다중상속의-모호성"><a href="#다중상속의-모호성" class="headerlink" title="다중상속의 모호성"></a>다중상속의 모호성</h3><ul><li>다중상속의 대상이 되는 두 기초 클래스에 같은 이름의 멤버가 존재하는 경우에 문제가 발생할 수 있다. 이러면 유도 클래스 내에서 멤버의 이름만으로 멤버에 접근할 경우 두 기초 클래스 중 어떤 클래스의 멤버에 접근하는 것인지에 대한 모호성이 발생한다. 다중상속의 모호성을 해결하기 위해서는 어느 클래스에 정의된 함수의 호출을 원하는지 명시를 통해 해결할 수 있다.</li></ul><h3 id="가상상속"><a href="#가상상속" class="headerlink" title="가상상속"></a>가상상속</h3><ul><li>클래스의 상속 과정에서 같은 클래스가 두 번 이상 나타나 불필요한 자원이 소모되는 것을 방지하기 위해 나온 것으로 같은 클래스군에서 두 번 이상 나타나는 클래스를 가상으로 지정하면 상속 구조에서 몇 번이 나오더라도 오직 한 번만 서브 객체를 생성하게 하는 것이다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;가상-함수&quot;&gt;&lt;a href=&quot;#가상-함수&quot; class=&quot;headerlink&quot; title=&quot;가상 함수&quot;&gt;&lt;/a&gt;가상 함수&lt;/h2&gt;&lt;h3 id=&quot;배경-및-필요성&quot;&gt;&lt;a href=&quot;#배경-및-필요성&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="객체지향" scheme="https://sogoagain.github.io/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
    
      <category term="C++" scheme="https://sogoagain.github.io/tags/C/"/>
    
      <category term="OOP" scheme="https://sogoagain.github.io/tags/OOP/"/>
    
      <category term="Software engineering" scheme="https://sogoagain.github.io/tags/Software-engineering/"/>
    
  </entry>
  
  <entry>
    <title>애자일 소프트웨어 개발</title>
    <link href="https://sogoagain.github.io/2017/01/05/%EC%95%A0%EC%9E%90%EC%9D%BC-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C/"/>
    <id>https://sogoagain.github.io/2017/01/05/애자일-소프트웨어-개발/</id>
    <published>2017-01-04T16:41:18.000Z</published>
    <updated>2019-07-26T17:14:27.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><ul><li>신속하고 변화에 유연하며 적응적인(adaptive) 소프트웨어 개발을 목표로 하는 다양한 경량 개발 방법론 전체를 일컫는 총칭으로, 반복(iteration)이라 불리는 단기 단위를 채용함으로 위험을 최소화하는 개발방법이다.</li></ul><h2 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h2><h3 id="소프트웨어-위기와-대응-방안"><a href="#소프트웨어-위기와-대응-방안" class="headerlink" title="소프트웨어 위기와 대응 방안"></a>소프트웨어 위기와 대응 방안</h3><ul><li>과거에서 현재로 올수록 시스템의 대규모화에 의해서 컴퓨터 계산 용량과 문제의 복잡성이 급격히 증가하게 되었고 이에 따라 소프트웨어의 신뢰성 저하, 개발비의 증대, 계획의 지연 등의 현상이 현저하게 발생되었다. 또한, 개발 계획의 수행을 매우 어렵게 만드는 상황이 빈번하게 발생하게 되었다.</li><li>소프트웨어 위기를 극복하기 위해 90년대 후반까지의 소프트웨어 공학과 개발방법론은 장기간에 걸쳐 많은 사람들을 투입하고 충분한 비용을 투입하여 진행하는 다른 공학의 프로세스와 비슷한 맥락에서 진행되었다. 이때의 전통적인 개발 프로세스들은 폭포수 모델과 계획 기반 개발 기법들을 따랐다. 그러나 계획 기반 개발은 너무 계획에 치중을 하다 보니 개발 방법 자체가 형식에만 신경을 쓰고 얽매이게 되었다. 소프트웨어는 유동적이고 개방적이며 요구사항의 변경에 따른 작업량을 예측하기 힘들다. 따라서 고전적인 소프트웨어 공학이나 관리 기법만으로는 소프트웨어 위기에 대해 대처할 수 없게 되었다.</li></ul><h3 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h3><ul><li>전통적인 개발 프로세스에 대응하여 소프트웨어 위기에 대해 대처하는 기술적인 해결책으로 객체지향이 있다. 객체지향 기술은 그동안의 개발 문제를 적절 하게 대처해 주었다. 그러나 객체지향은 전통적인 개발 프로세스에 적합하지 않기 때문에 그에 맞는 개발 프로세스가 필요했다. 애자일 개발 프로세스가 이러한 필요에 따라 만들어졌다. 그렇기 때문에 애자일 개발 프로세스의 상당수는 객체 지향 기술을 기반으로 한다.</li></ul><h2 id="본문"><a href="#본문" class="headerlink" title="본문"></a>본문</h2><h3 id="애자일-개발-방법론"><a href="#애자일-개발-방법론" class="headerlink" title="애자일 개발 방법론"></a>애자일 개발 방법론</h3><ul><li>소프트웨어 개발 방법의 하나로, 개발 대상을 다수의 작은 기능으로 분할하여 하나의 기능을 하나의 반복 주기 내에 개발하는 개발 방법을 말한다. 하나의 반복 기간은 프로젝트마다 다르지만 일반적으로 1주에서 4주 정도인 경우가 많다. 이 반복 주기를 계속해 나가며 하나씩 기능을 추가 개발하는 것이다. 각각의 반복은 소규모 소프트웨어 개발 프로젝트와 비슷하며, 각 반복은 지금까지 개발된 성과물에 하나의 작은 기능을 추가하는 역할을 한다. 계획, 요구분석, 설계, 구현 (코딩), 테스트 및 문서화 등 소프트웨어 프로젝트에 필요한 모든 공정이 하나의 반복 내에서 모두 실시된다. 각 반복이 끝날 때마다 기능이 추가된 새로운 소프트웨어(빌드, build)를 출시하는 것을 목표로 하며, 각 반복이 끝나면 프로젝트 팀은 프로젝트의 우선 순위를 재평가하여 다음 반복을 실시한다.</li><li>애자일 개발 프로세스는 제한된 시간과 비용 안에서 정보는 불완전하고 예측 불가능하다는 전제를 가진다. 그리고 그 전제 아래에서 합리적인 답을 내도록 하는 것이 애자일 개발 프로세스이다.</li></ul><h3 id="애자일-개발방법론-특징"><a href="#애자일-개발방법론-특징" class="headerlink" title="애자일 개발방법론 특징"></a>애자일 개발방법론 특징</h3><ul><li>짧은 기간 단위의 반복 절차를 통해 리스크를 줄이며 개발 주기(계획, 개발, 출시)가 여러번 반복된다. 고객의 피드백에 민첩하게 반응한다. 문서를 통한 의사소통 및 인수인계를 지양하여 문서작업을 최소한으로 줄이고 프로그래밍에 집중한다. 고전적인 개발방법론인 폭포수 모형의 반대개념이다. 일정한 주기를 가지고 끊임없이 프로토타입을 작성하며 상시적으로 요구를 추가, 수정하는 과정을 통해 적응적인(adaptive) 소프트웨어 개발을 한다.</li></ul><h3 id="기존-개발-방법과-애자일-개발-방법의-차이"><a href="#기존-개발-방법과-애자일-개발-방법의-차이" class="headerlink" title="기존 개발 방법과 애자일 개발 방법의 차이"></a>기존 개발 방법과 애자일 개발 방법의 차이</h3><ul><li>기존의 문서 기반 개발 방법과는 달리 프로젝트 관계자 사이에서 필요할 때 직접 얼굴을 맞대고 즉각적으로 의사소통하는 것을 강조한다. 일반적으로 애자일 개발팀은 소프트웨어 개발에 필요한 모든 참가자가 한 곳의 작업장에서 일한다. 즉, 소프트웨어 개발자와 필요한 소프트웨어를 정의하는 고객, 테스터, 사용자 인터페이스 설계자, 기술문서 기록자 등을 모두 포함한다. 또한 결함을 조기에 식별하기 위해 테스트를 강화하고, 개발 초기부터 테스트를 수행하며, 자동화된 테스트 및 배포 환경을 구축함으로써 지속적인 시스템 통합을 수행하고자 한다.</li></ul><h3 id="애자일-개발-프로세스"><a href="#애자일-개발-프로세스" class="headerlink" title="애자일 개발 프로세스"></a>애자일 개발 프로세스</h3><ul><li>동적 시스템 개발 방법(DSDM), 익스트림 프로그래밍(Extreme Programming, XP), 스크럼, 크리스털 패밀리, Feature-Driven Development, Adaptive Software Development(ASD), 익스트림 모델링 등이 있다.</li><li>애자일 개발 프로세스들은 각자 다른 특징과 적용 범위가 있으며, 서로 조합도 가능하다. 여러 방법중에서 자신의 프로젝트에 맞는 부분을 취사 선택하여 조합하고, 또 독자적인 방법을 만들어 냄으로써 큰 효과를 올리고 있다.</li></ul><h3 id="애자일-개발-적용-대상"><a href="#애자일-개발-적용-대상" class="headerlink" title="애자일 개발 적용 대상"></a>애자일 개발 적용 대상</h3><ol><li>첫 번째는 목표 달성을 위한 프로세스를 가지지 않고, 임기응변적인 소프트웨어 개발로 인해 혼란에 빠져있는 조직이다. 애자일 개발 프로세스는 쉽게 도입 할 수 있으며, 들어가는 비용과 위험도 낮다.</li><li>두 번째는 이미 전통적인 소프트웨어 프로세스를 도입하고 있지만, 제대로 동작하지 않는(또는 프로세스 실시를 위한 오버헤드가 너무 커서 오히려 업무에 부담을 주고 있는) 조직이다.</li></ol><h3 id="애자일-선언문과-애자일-연합"><a href="#애자일-선언문과-애자일-연합" class="headerlink" title="애자일 선언문과 애자일 연합"></a>애자일 선언문과 애자일 연합</h3><ul><li><p>2001년 켄트 벡(Kent Beck)을 포함한 이 분야의 저명한 소프트웨어 개발자 17명이 미국 유타의 스노우버드(snow bird) 리조트에서 모여, 애자일 소프트웨어 개발 선언을 발표하였다.</p><ol><li>절차와 도구보다는 상호작용 (개성과 화합)</li><li>종합적인 문서보다는 소프트웨어 자체</li><li>계약과 협상보다는 고객과의 협력</li><li>계획 준수보다는 변화에 대한 대응</li></ol></li><li><p>애자일 개발 프로세스의 제창자들은 애자일 연합이라는 자유로운 조직을 만들고, 애자일 개발 프로세스의 보급에 힘쓰고 있다.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;신속하고 변화에 유연하며 적응적인(adaptive) 소프트웨어 개발을 목표로 하는 다양한 경량 개발 방법론 전체를 
      
    
    </summary>
    
      <category term="소프트웨어공학" scheme="https://sogoagain.github.io/categories/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99/"/>
    
    
      <category term="Software engineering" scheme="https://sogoagain.github.io/tags/Software-engineering/"/>
    
  </entry>
  
</feed>
