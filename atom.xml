<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>기술을 기술하다</title>
  
  <subtitle>sogoagain의 기술 블로그</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sogoagain.github.io/"/>
  <updated>2020-07-22T16:14:51.346Z</updated>
  <id>https://sogoagain.github.io/</id>
  
  <author>
    <name>sogoagain</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>개발자의 아침</title>
    <link href="https://sogoagain.github.io/2020/07/23/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EC%95%84%EC%B9%A8/"/>
    <id>https://sogoagain.github.io/2020/07/23/개발자의-아침/</id>
    <published>2020-07-22T15:46:38.000Z</published>
    <updated>2020-07-22T16:14:51.346Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&apos;따르릉, 따르릉&apos; 알람 소리다;</span><br><span class="line">아침 알람은 오전 6시에 시작되어 15분 간격으로 총 세 번 울린다;</span><br><span class="line"></span><br><span class="line">아침에 알람이 세 번 울리는 동안 아래를 반복한다;</span><br><span class="line">    첫 번재 알람이라면:</span><br><span class="line">        알람을 끄고 눈을 감는다;</span><br><span class="line">        나에게 첫 번째 알람은 아침이 되었다는 것을 인지시켜주는 역할을 할 뿐이다;</span><br><span class="line">        이 알람에 바로 일어나면 좋겠지만 꽤 오랜 기간 연습했음에도 도통 쉽지 않았다;</span><br><span class="line">        그래서 첫 번째 알람에 일어날 수 없다는 것을 받아들이기로 했다;</span><br><span class="line">        대신, 다시 자는 것이 아닌 눈을 감는다;</span><br><span class="line">        잠이 들 듯 말 듯 다음 알람이 울리길 기다린다;</span><br><span class="line">        반복 계속;</span><br><span class="line"></span><br><span class="line">    두 번째 알람이라면:</span><br><span class="line">        일어난다면:</span><br><span class="line">            물을 마신다;</span><br><span class="line">            꽤 오랜 습관이다;</span><br><span class="line">            일어나자마자 물을 마시면 소화 기능이 활성화되어 훨씬 상쾌한 아침을 보낼 수 있다고 한다;</span><br><span class="line">            이를 실천해 보았는데, 실제 효과가 있는 듯하다;</span><br><span class="line">            반복 종료;</span><br><span class="line">        일어나지 못한다면:</span><br><span class="line">            첫 알람을 듣고 눈을 감고 있다가 다시 잠이 들어 버린 것이다;</span><br><span class="line">            다음 알람 때 일어나야 한다;</span><br><span class="line">            반복 계속;</span><br><span class="line"></span><br><span class="line">    세 번째 알람이라면:</span><br><span class="line">        마지막 알람이다;</span><br><span class="line">        이때 제대로 일어나지 못하면 지각이다;</span><br><span class="line">        제발 부디 그런 일은 없어야 한다;</span><br><span class="line">        일어나!;</span><br><span class="line">        반복 계속;</span><br><span class="line"></span><br><span class="line">이제 일어났으니 간단히 아침 식사를 해보자;</span><br><span class="line">아침을 거르면 힘이 생기지 않아 오전 업무 시간에 제대로 집중할 수가 없다;</span><br><span class="line">그럼 일이 밀리게 되고 퇴근 시간이 다가올 수록 힘들어지기 때문에 아침 식사를 소홀히 할 수 없다;</span><br><span class="line"></span><br><span class="line">냉장고를 열고 훑어보자;</span><br><span class="line">    과일이 있다면 ? 그릇에 담는다;</span><br><span class="line">    우유가 있다면 ? 컵에 우유를 따른다 : 그렇지 않다면 물을 따른다;</span><br><span class="line">    계란이 있다면 ? 프라이팬에 기름을 두르고 계란을 깐다;</span><br><span class="line">    식빵이 있다면 ? 토스트기에 식빵을 올린다 : 그렇지 않다면 컵에 따른 우유를 그릇으로 옮기고 시리얼을 붇는다;</span><br><span class="line">    냉장고에 아무 것도 없다면 ? 일단 물로 배를 채운 뒤 회사 근처에서 먹도록 하자;</span><br><span class="line">    냉장고 문을 닫는다;</span><br><span class="line"></span><br><span class="line">오늘은 다행히 먹을 것이 있다;</span><br><span class="line">아침 식사로 계란 프라이, 식빵 토스트, 오렌지, 우유를 준비했다;</span><br><span class="line">풍족하다;</span><br><span class="line">밥을 먹으며 간단히 기술 공부를 하자;</span><br><span class="line"></span><br><span class="line">아침 식사를 하며 다음을 반복한다;</span><br><span class="line">    공부할 주제가 정해질 때까지 다음을 반복한다;</span><br><span class="line">        책장을 살펴보거나 인터넷 서핑을 통해 공부할 주제를 선정한다;</span><br><span class="line">        </span><br><span class="line">        선정한 주제가 깊은 이해를 요구한다면:</span><br><span class="line">            아침은 상쾌해야 한다;</span><br><span class="line">            너무 방대한 내용을 다루는 것보다는 가볍게 읽을 거리를 다시 찾아보자;</span><br><span class="line">            그렇지 않으면 아침밥 먹다가 체할 수도 있다;</span><br><span class="line">            반복 계속;</span><br><span class="line">        </span><br><span class="line">        깊은 이해를 요구하는 것이 아니라면:</span><br><span class="line">            아침 공부에는 짧은 호흡으로 구성된 책이나 강의를 선호한다;</span><br><span class="line">            책장에서 프로그램을 작성할 때 도움이 되는 간단한 내용이 담긴 책을 발견했다;</span><br><span class="line">            남은 시간 동안 이 책에서 약 3개의 팁을 읽을 수 있을 것 같다;</span><br><span class="line">            이 책으로 오늘 아침 공부를 해보자;</span><br><span class="line">            반복 종료;</span><br><span class="line">    </span><br><span class="line">    오전 7시 30분이 될 때까지 공부한다;</span><br><span class="line"></span><br><span class="line">어느덧 씻고 나갈 준비를 해야 할 시간이다;</span><br><span class="line">8시에 집에서 나서야 하니 30분의 시간 동안 출근 준비를 마쳐야 한다;</span><br><span class="line">이때 시간을 맞추기 위해 타이머를 설정하는데, 나는 타이머로 시리를 이용한다;</span><br><span class="line"></span><br><span class="line">시리야, 30분 뒤에 출근하라고 알려줘;</span><br><span class="line">    30분 뒤에 해야 할 행동은 다음과 같다:</span><br><span class="line">        핸드폰, 지갑, 가방, 손소독제를 챙긴다;</span><br><span class="line">        마스크를 쓴다;</span><br><span class="line">        신발을 신고 밖으로 나간다;</span><br><span class="line"></span><br><span class="line">타이머를 맞춰놓으니 안심이 된다;</span><br><span class="line">이제 남은 시간 동안 샤워를 한 뒤 옷을 입고 간단히 집 정리를 한다;</span><br><span class="line">그리고 시리가 30분이 지났다는 것을 알려줄 때까지 기다린다;</span><br><span class="line"></span><br><span class="line">개발자의 아침 종료;</span><br><span class="line"></span><br><span class="line">평일 오전 6시 마다 &apos;개발자의 아침&apos; 프로그램을 실행한다;</span><br></pre></td></tr></table></figure><p>이런, 오늘 또 프로그램이 제대로 동작하지 못했다.<br>최근 들어 오류가 잦아졌는데, 얼른 고쳐서 정상으로 만들자.<br>인생은 디버깅의 연속이구나.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="생각" scheme="https://sogoagain.github.io/categories/%EC%83%9D%EA%B0%81/"/>
    
    
      <category term="생각" scheme="https://sogoagain.github.io/tags/%EC%83%9D%EA%B0%81/"/>
    
      <category term="에세이" scheme="https://sogoagain.github.io/tags/%EC%97%90%EC%84%B8%EC%9D%B4/"/>
    
  </entry>
  
  <entry>
    <title>삶에 적용해야 할 견습 과정 패턴</title>
    <link href="https://sogoagain.github.io/2020/04/30/%EC%82%B6%EC%97%90-%EC%A0%81%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0-%EA%B2%AC%EC%8A%B5-%EA%B3%BC%EC%A0%95-%ED%8C%A8%ED%84%B4/"/>
    <id>https://sogoagain.github.io/2020/04/30/삶에-적용해야-할-견습-과정-패턴/</id>
    <published>2020-04-30T13:50:51.000Z</published>
    <updated>2020-04-30T14:02:02.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="우리는-멘토가-필요해요"><a href="#우리는-멘토가-필요해요" class="headerlink" title="우리는 멘토가 필요해요."></a>우리는 멘토가 필요해요.</h2><p>여러분은 자신의 커리어와 관련된 멘토가 있으신가요? 현재 자신이 처한 상황을 들어주고 앞으로 나아가야 할 ‘길’을 제시해주는 멘토가 지금 있으시다면 정말 축복받으셨다고 말씀드리고 싶습니다. 주변에 훌륭하신 분들은 쉽게 찾을 수 있지만, 나의 이야기에 진심으로 귀 기울여주는 사람을 만나기는 쉽지 않으니까요.</p><p>인생을 살면서 수없이 새롭고 힘든 상황을 마주하게 됩니다. 개발자의 삶 역시 마찬가지죠. 저는 새롭고 어려운 상황을 마주할 때면 ‘어떻게 행동해야 최선일까?’라는 생각을 합니다. 혼자 나름대로 분석도 해보고 시뮬레이션도 해보지만, 한계가 있는 것 같아요. 이럴 때 마다 정답이 없다는 것을 알면서도 정답을 찾고 싶어지더라고요. 아이러니한 상황입니다. 당장 조언을 구할 멘토가 없다면, 어떻게 하는 것이 좋을까요?</p><p>다행히, 이러한 상황에서 도움이 될만한 책을 찾았습니다. ‘프로그래머의 길, 멘토에게 묻다’라는 책입니다. 책 제목처럼 개발자의 삶과 관련해서 마치 멘토와 같은 도움을 줄 수 있는 책이라고 할 수 있겠네요.</p><h2 id="견습-과정-패턴-Apprenticeship-Patterns"><a href="#견습-과정-패턴-Apprenticeship-Patterns" class="headerlink" title="견습 과정 패턴 (Apprenticeship Patterns)"></a>견습 과정 패턴 (Apprenticeship Patterns)</h2><p>이 책의 원제목은 ‘견습 과정 패턴(Apprenticeship Patterns)’ 입니다. 개발자라면 ‘디자인 패턴’을 아시리라 생각합니다. ‘패턴’이란 특정한 상황의 문제를 해결하기 위한 방법을 보편적으로 적용할 수 있도록 일반화시킨 것입니다. ‘디자인 패턴’이 코드 설계를 할 때 발생하는 문제에 도움을 주는 것이라면 ‘견습 과정 패턴’은 개발자의 삶을 살아갈 때 발생하는 문제에 도움을 줄 수 있는 것이라 말할 수 있겠네요.</p><p>이 책에는 35가지의 패턴을 제공하고 있으며 각각의 패턴은 ‘상황’, ‘문제’, ‘해결책’, ‘실천방안’으로 구성되어 있습니다. 저는 패턴들이 ‘상황’을 다루고 있다는 점이 인상 깊었습니다. 모든 패턴이 개발자라면 한 번쯤 겪을만한 현실적인 상황을 다루고 있습니다. 그리고 이에 대해 분석하고 해결책을 제시해주죠. 더 나아가 당장 실천할 수 있는 행동들까지 조언해줍니다.</p><p>위와 같은 이유로 이 책이 멘토와 같이 도움을 줄 수 있다고 앞서 언급한 것입니다. 개발자로서 고민이 되는 것이 있다면 이 책을 펴들고 자신의 상황과 밀접한 패턴을 고릅니다. 그리고 그 패턴을 자신의 삶에 적용해 보는 것이죠. 실제로 이 패턴들은 저자 ‘데이브 후버’와 ‘애디웨일 오시나이’를 중심으로 수많은 선배 개발자분들의 경험에서 탄생한 것이기에 이 책 한 권으로 수많은 선배 개발자들을 자신의 멘토단으로 만들 수 있습니다. :)</p><h2 id="나에게-적용한-패턴"><a href="#나에게-적용한-패턴" class="headerlink" title="나에게 적용한 패턴"></a>나에게 적용한 패턴</h2><h3 id="‘독서-목록’-패턴과-‘배운-것을-공유하라’-패턴"><a href="#‘독서-목록’-패턴과-‘배운-것을-공유하라’-패턴" class="headerlink" title="‘독서 목록’ 패턴과 ‘배운 것을 공유하라’ 패턴"></a>‘독서 목록’ 패턴과 ‘배운 것을 공유하라’ 패턴</h3><p>읽고 싶은 책들은 계속 늘어만 가는데 읽은 책들은 제자리걸음 이었습니다. 그때, 이 책에서 ‘독서 목록’ 패턴을 발견하였고 제 삶에 적용해보았습니다. 이 책의 실천 방안대로 소스 관리 시스템을 이용해 텍스트 파일을 하나 만들고 읽고 싶은 책의 목록을 타이핑해 넣었습니다. 그리고 이를 Github에 공개하였죠.</p><blockquote><p><a href="https://github.com/sogoagain/bookshelf" rel="external nofollow noopener noreferrer" target="_blank">Bookshelf - 나의 독서 목록 📖</a></p></blockquote><p>위 독서 목록은 기본적으로 우선순위 큐 형태이지만 그때 그때 상황에 따라 순위를 변경하며 책을 읽어 나가고 있습니다. 가끔은 병렬로 여러 책을 동시에 읽기도 하고요. 아직 완독한 수는 많지 않지만, 확실히 독서 목록을 유지하고 있으니 이전에 느낀 막연함은 사라졌습니다.</p><p>그뿐만 아니라 ‘독서 목록’ 패턴에서 더 나아가 각 책에 대해 간단히 독후감을 남기는 활동도 함께 하고 있습니다. 독후감 활동은 책에서 소개하고 있는 ‘배운 것을 공유하라’ 패턴을 ‘독서 목록’ 패턴과 결합하여 제 삶에 적용해 본 것이라고 할 수 있겠네요.</p><h3 id="‘실패하는-법을-배워라’-패턴"><a href="#‘실패하는-법을-배워라’-패턴" class="headerlink" title="‘실패하는 법을 배워라’ 패턴"></a>‘실패하는 법을 배워라’ 패턴</h3><p>저는 최근 블로그에 ‘실수 노트’를 작성하고 있습니다. ‘실수 노트’는 김창준 님의 저서인 ‘함께 자라기’에서 실수 관리의 중요성을 이야기하면서 언급된 개념입니다. 순서상으론 ‘함께 자라기’를 보고 ‘실수 노트’를 알게 되었지만, 실제 작성하기 시작한 것은 ‘실패하는 법을 배워라’ 패턴을 읽은 순간부터입니다. 실수와 실패 관리의 중요성을 두 책에서 이야기 하는 것을 보면 정말 중요하지 않을까 생각이 들어 작성하게 되었죠. 참고로 저의 ‘실수 노트’는 각 패턴의 형식을 따라 ‘상황’, ‘문제’, ‘해결책’, ‘실천방안’으로 구성되어 있습니다.</p><blockquote><p><a href="https://sogoagain.github.io/2020/01/12/%EC%82%B6%EC%97%90-%EC%95%A0%EC%9E%90%EC%9D%BC-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0/">김창준님의 ‘함께 자라기’ 독후감 - 삶에 애자일 도입하기</a></p></blockquote><h2 id="견습생에게-필요한-책"><a href="#견습생에게-필요한-책" class="headerlink" title="견습생에게 필요한 책"></a>견습생에게 필요한 책</h2><p>이 책에서는 ‘견습생’이 어떤 태도를 가져야 하는지 잘 말해주고 있습니다. 특히 저는 ‘겸손함’에 대해 중요하게 다루고 있다고 생각합니다. 책은 ‘겸손함’이라는 자세에서 출발하여 ‘정확한 자기 평가’와 ‘끊임없는 학습’ 그리고 ‘긴 여정’에 대해서 이야기하고 있죠.</p><p>책에서 이야기하는 겸손함을 바탕으로 자신을 수련하고 있는 견습생이라면 이 책이 도움이 되리라 생각합니다. 수련 과정에서 수많은 어려움이 있을 겁니다. 저 또한 그러고 있고요. 그런 상황에 처할때 마다 이 책을 한 번씩 보게 되네요. 저와 같은 견습생 과정을 겪고 있는 개발자분들이라면 한 번쯤 읽어보길 권합니다. 우리 모두 화이팅입니다!</p><h2 id="참고문헌"><a href="#참고문헌" class="headerlink" title="참고문헌"></a>참고문헌</h2><p><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=6332442" rel="external nofollow noopener noreferrer" target="_blank">데이브 후버, 애디웨일 오시나이, 『프로그래머의 길, 멘토에게 묻다』, 강중빈 옮김, 인사이트(2010),</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;우리는-멘토가-필요해요&quot;&gt;&lt;a href=&quot;#우리는-멘토가-필요해요&quot; class=&quot;headerlink&quot; title=&quot;우리는 멘토가 필요해요.&quot;&gt;&lt;/a&gt;우리는 멘토가 필요해요.&lt;/h2&gt;&lt;p&gt;여러분은 자신의 커리어와 관련된 멘토가 있으신가요?
      
    
    </summary>
    
      <category term="독서" scheme="https://sogoagain.github.io/categories/%EB%8F%85%EC%84%9C/"/>
    
    
      <category term="생각" scheme="https://sogoagain.github.io/tags/%EC%83%9D%EA%B0%81/"/>
    
      <category term="독서" scheme="https://sogoagain.github.io/tags/%EB%8F%85%EC%84%9C/"/>
    
      <category term="소프트웨어 장인정신" scheme="https://sogoagain.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%9E%A5%EC%9D%B8%EC%A0%95%EC%8B%A0/"/>
    
      <category term="견습 과정 패턴" scheme="https://sogoagain.github.io/tags/%EA%B2%AC%EC%8A%B5-%EA%B3%BC%EC%A0%95-%ED%8C%A8%ED%84%B4/"/>
    
  </entry>
  
  <entry>
    <title>[실수노트] JavaScript에서 동일한 이벤트 리스너는 단 한 번만 등록하자</title>
    <link href="https://sogoagain.github.io/2020/04/29/%EC%8B%A4%EC%88%98%EB%85%B8%ED%8A%B8-JavaScript%EC%97%90%EC%84%9C-%EB%8F%99%EC%9D%BC%ED%95%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A6%AC%EC%8A%A4%EB%84%88%EB%8A%94-%EB%8B%A8-%ED%95%9C-%EB%B2%88%EB%A7%8C-%EB%93%B1%EB%A1%9D%ED%95%98%EC%9E%90/"/>
    <id>https://sogoagain.github.io/2020/04/29/실수노트-JavaScript에서-동일한-이벤트-리스너는-단-한-번만-등록하자/</id>
    <published>2020-04-28T15:20:39.000Z</published>
    <updated>2020-04-28T15:40:31.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="상황"><a href="#상황" class="headerlink" title="상황"></a>상황</h2><p>어느 날, 동료 직원분께서 시스템을 이용하는데 데이터 조회가 가끔가다 한 번씩 이상하다고 제게 문의를 해왔습니다. 어떤 문제가 있었을까요?</p><p>데이터 조회는 데이터들이 있는 테이블에서 한 행을 클릭해 나타나는 모달창을 통해 이루어졌습니다. 동료분께서 조회를 원하는 데이터를 테이블에서 클릭했는데, 간혹 클릭한 데이터가 아닌 다른 데이터가 출력된다는 것이었습니다. 그뿐만 아니라 어떨 때는 아예 모달 창이 뜨지도 않았다고 하더라고요.</p><p>제일 큰 문제는 이와 같은 상황이 항상 발생하는 것이 아니라 ‘간혹’가다 발생한다는 것이었습니다. 평소에는 잘 동작하다가 간혹 문제가 발생한다는 것에서 문제를 처음 들었을 때부터 디버깅이 쉽지 않겠다는 생각이 들었습니다.</p><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>예상한 것과 같이 디버깅은 쉽지 않았습니다. ‘console.log()’ 신공으로 의심 가는 모든 곳에 디버깅 로그를 찍고 동작하는 상황을 유심히 관찰했습니다. 여러 시행착오 끝에 문제를 해결할 만한 단서를 발견합니다.</p><p>특정한 동작을 한 뒤에 테이블의 행을 클릭하면 로그가 중복해 찍히는 현상을 찾아낸 것이죠. 문제가 발생하는 동작을 수행한 횟수만큼 로그도 동일한 횟수로 중복되어 찍히고 있었습니다. 예를 들어, 이상 동작을 5번 반복하면 테이블의 행을 클릭했을 때 동일한 로그가 5번 반복해서 찍혔던 것이죠.</p><p>위와 같은 상황이 발생한 원인은 테이블의 행을 클릭한 이벤트에 대해 동일한 이벤트 리스너가 중복해서 등록되었기 때문입니다. 문제가 발생하는 동작을 수행하면 테이블의 데이터를 지웠다가 다시 그리게 됩니다. 이때, 테이블을 다시 그리면서 테이블 행 클릭 이벤트에 대한 리스너가 중복해서 등록되었던 것이죠.</p><p>그리고 이로 인해 ‘3페이지 첫 번째 행의 데이터’를 조회하고자 했는데 중복된 이벤트 리스너들 중 하나가 오동작하여 ‘1페이지 첫 번째 행의 데이터’를 조회해버리는 이상 동작이 발생했습니다. 그리고 리스너가 너무 많이 호출될 때에는 데이터 조회가 제대로 동작하지 않았습니다.</p><p>아래의 코드가 위의 상황을 단순화시킨 예입니다. 테이블의 데이터를 지웠다 그리는 것은 생략하고 동일한 이벤트 리스너가 5번 중복해서 등록되는 상황을 최대한 단순화 시켜 작성해보았습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn-favorites"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line">    Add to favorites</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    var el = document.getElementById("btn-favorites");</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        el.addEventListener("click", () =&gt; &#123;</span><br><span class="line">            console.log('onClickBtn');</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위의 페이지에서 ‘Add to favorites’ 버튼을 클릭하면 콘솔에는 ‘onClickBtn’이라는 텍스트가 5번 연속해서 출력하는 것을 확인할 수 있습니다. </p><h2 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h2><p>이에 대한 해결책을 찾다가 ‘MDN web docs’의 ‘EventTarget.addEventListener()’ 항목을 읽게 되었습니다.</p><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" rel="external nofollow noopener noreferrer" target="_blank">EventTarget.addEventListener() - MDN web docs</a></p></blockquote><p>그런데, 위 문서에서는 동일한 파라미터를 갖는 리스너가 동일한 EventTarget에 중복되어 등록된다면 중복된 것들은 제거되고 오직 하나만 등록된다고 합니다. 그럼 위의 예제에서는 왜 콘솔에 5번 로그가 찍혔을까요? 그 이유는 저의 상황과 위의 예제에서는 ‘익명 함수’로 이벤트 리스너를 등록했기 때문입니다. 조금 더 알아볼까요?</p><p>JavaScript에서는 함수도 레퍼런스를 갖는 객체입니다. 동일한 레퍼런스를 갖는 이벤트 리스너가 여러 번 등록된다면 중복 처리되어 하나만 남게 됩니다. 그런데, 위의 예제에서 익명 함수로 작성된 이벤트 리스너는 이벤트에 대해 등록될 때마다 새로운 객체로 생성됩니다. 즉, 5번 등록된 리스너의 레퍼런스는 모두 다 다르죠. 그렇기 때문에 중복처리가 따로 안 되고 5개의 리스너 모두가 등록되어 버린 것입니다.</p><p>한번 함께 확인해보겠습니다. 아래의 코드에서 이벤트 리스너를 미리 변수에 저장한 뒤 중복해서 다섯 번 등록했습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn-favorites"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line">    Add to favorites</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    const onClickBtn = () =&gt; &#123;</span><br><span class="line">        console.log('onClickBtn');</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const el = document.getElementById("btn-favorites");</span><br><span class="line">    for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        el.addEventListener("click", onClickBtn);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>얼핏 보아서는 처음 예제와 동일하게 동작할 것 같은 느낌도 듭니다. 이번엔 ‘Add to favorites’ 버튼을 누르면 로그가 몇 번 출력될까요? 예상대로 단 한 번의 로그만 출력됩니다.</p><h2 id="실천방안"><a href="#실천방안" class="headerlink" title="실천방안"></a>실천방안</h2><p>위의 내용을 알게 된 후 기존에 익명 함수로 정의된 이벤트 리스너를 선언적 함수로 정의하여 리스너로 등록하였습니다. 그뿐만 아니라 더욱 근본적으로 이벤트 리스너를 등록하는 과정이 페이지 초기화 단계에서 명확히 한번만 수행될 수 있도록 코드의 구조를 잡아야겠다는 생각도 했습니다. JavaScript는 이벤트가 중심이 되어 로직을 처리하는 흥미로운 언어입니다. 그래서 저는 커스텀 이벤트도 종종 쓰는데요. 이번 기회를 통해 이벤트에 대해 간과하고 있었던 부분을 짚고 넘어갈 수 있었습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;상황&quot;&gt;&lt;a href=&quot;#상황&quot; class=&quot;headerlink&quot; title=&quot;상황&quot;&gt;&lt;/a&gt;상황&lt;/h2&gt;&lt;p&gt;어느 날, 동료 직원분께서 시스템을 이용하는데 데이터 조회가 가끔가다 한 번씩 이상하다고 제게 문의를 해왔습니다. 어떤 문제가
      
    
    </summary>
    
      <category term="실수노트" scheme="https://sogoagain.github.io/categories/%EC%8B%A4%EC%88%98%EB%85%B8%ED%8A%B8/"/>
    
    
      <category term="실수노트" scheme="https://sogoagain.github.io/tags/%EC%8B%A4%EC%88%98%EB%85%B8%ED%8A%B8/"/>
    
      <category term="JavaScript" scheme="https://sogoagain.github.io/tags/JavaScript/"/>
    
      <category term="익명 함수" scheme="https://sogoagain.github.io/tags/%EC%9D%B5%EB%AA%85-%ED%95%A8%EC%88%98/"/>
    
      <category term="이벤트" scheme="https://sogoagain.github.io/tags/%EC%9D%B4%EB%B2%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>레거시 코드를 점진적으로 개선한 경험</title>
    <link href="https://sogoagain.github.io/2020/03/08/%EB%A0%88%EA%B1%B0%EC%8B%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%A0%90%EC%A7%84%EC%A0%81%EC%9C%BC%EB%A1%9C-%EA%B0%9C%EC%84%A0%ED%95%9C-%EA%B2%BD%ED%97%98/"/>
    <id>https://sogoagain.github.io/2020/03/08/레거시-코드를-점진적으로-개선한-경험/</id>
    <published>2020-03-07T17:00:00.000Z</published>
    <updated>2020-03-07T17:44:13.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="프로젝트를-이어받다"><a href="#프로젝트를-이어받다" class="headerlink" title="프로젝트를 이어받다."></a>프로젝트를 이어받다.</h2><p>저는 작년(2019년) 6월 말에 새로운 회사로 이직하였습니다. 첫 번째로 받은 업무는 새롭게 개발 중이던 관리자용 시스템을 이어받아 완성 시키는 것이었습니다. 기존에 개발자 한 분께서 맡아 개발해왔지만, 관리자용 시스템이라 우선순위가 다른 프로젝트들보다 낮아 꽤 오랜 기간 미완성 상태로 남겨졌던 프로젝트였습니다. 그러나, 이미 기존 시스템 기반으로 어느 정도 구현이 된 상태였고 실제 배포되어 일부 기능들은 업무 담당자들이 사용하고 있었습니다. 그렇기에 해당 프로젝트는 이미 작성된 코드량이 꽤 되었죠. 이 글에서는 제가 이어받은 프로젝트에 기능을 추가하며 완성하는 동시에 기존 코드들을 함께 개선한 경험을 공유하고자 합니다.</p><h2 id="레거시-코드란"><a href="#레거시-코드란" class="headerlink" title="레거시 코드란?"></a>레거시 코드란?</h2><p>앞서 말씀드렸다시피 제가 이어받은 프로젝트에는 이미 꽤 많은 양의 코드가 작성되어 있었습니다. 레거시 코드를 다양하게 정의할 수 있지만, 이 글에서는 아래의 이유로 기존에 작성된 코드들을 레거시 코드라고 칭하겠습니다. 2, 3번의 이유는 뒤에 소개해드릴 소스코드 정적 분석 툴인 SonarQube의 분석 결과로 확인할 수 있습니다.</p><ol><li>다른 사람이 “처음” 작성한 코드다.</li><li>테스트 코드가 없었다.</li><li>JAVA의 Best Practice가 지켜지지 않았다. (‘LocalDate’ 대신 ‘Date’ 사용 등)</li></ol><p>저는 이 글에서 기존의 코드를 레거시 코드라 일컫고 있지만 1번의 이유로 기존 코드가 나쁜 코드라던가 코드를 작성한 분께 탓을 돌리든지 하는 생각은 하지 않습니다. 같이 업무를 하는 입장에서 기존에 코드를 작성하신 분은 굉장한 실력자십니다. 1번 이유에 ‘처음’이라는 단어를 강조하고 있는데요. 정보가 없는 상태에서 요구사항을 만족하는 기능을 ‘처음’ 만들어 내는 것 자체가 굉장한 성과라고 생각하기 때문입니다. 제가 읽었던 책들 중 ‘프로그래머의 길, 멘토에게 묻다’라는 책에서 오픈소스를 읽는 것이 도움 된다는 내용을 소개하며 아래의 문장을 언급하고 있습니다.</p><blockquote><p>소스가 별로 훌륭해 보이지 않아서 다소간 실망할 수도 있겠지만, <strong>그 코드를 작성한 사람들은 도움 받을 커뮤니티 같은 것도 없이 모든 것을 새로 만들어 내야 하는 처지였음을 잊지 말아야 한다.</strong> 소스를 보다가 버그를 발견했다면, 수정 패치를 만들어서 제작자에게 보내 보라.</p><ul><li>데이브 후버 외 1명, 『프로그래머의 길, 멘토에게 묻다』, 강중빈 옮김, 인사이트(2010), p72-73.</li></ul></blockquote><p>책에서는 레거시 코드를 대하는 태도에 대해서도 말하고 있는 것 같습니다. 레거시 코드를 만난다고 실망에 그칠 것이 아닌 적극적으로 개선 시키는 태도가 필요하다고 말이죠.</p><h2 id="클린코드를-향해-가다"><a href="#클린코드를-향해-가다" class="headerlink" title="클린코드를 향해 가다."></a>클린코드를 향해 가다.</h2><p>SonarQube 환경을 제 노트북인 로컬 환경에 구축하다 보니 관리 미흡으로 프로젝트 초기 분석 결과가 지워졌습니다. 그렇지만 프로젝트가 진행되던 중반쯤인 10월경의 자료가 있어 현재의 분석 결과와 비교하여 보여드리겠습니다.</p><ol><li><strong>2019년 10월 분석 결과</strong></li></ol><p><img src="/images/%EB%A0%88%EA%B1%B0%EC%8B%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%A0%90%EC%A7%84%EC%A0%81%EC%9C%BC%EB%A1%9C-%EA%B0%9C%EC%84%A0%EC%8B%9C%ED%82%A8-%EA%B2%BD%ED%97%98/sonarqube_1.png" alt="SonarQube 분석 결과 1"></p><ol start="2"><li><strong>2020년 02월 분석 결과</strong></li></ol><p><img src="/images/%EB%A0%88%EA%B1%B0%EC%8B%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%A0%90%EC%A7%84%EC%A0%81%EC%9C%BC%EB%A1%9C-%EA%B0%9C%EC%84%A0%EC%8B%9C%ED%82%A8-%EA%B2%BD%ED%97%98/sonarqube_2.png" alt="SonarQube 분석 결과 2"></p><p>결과를 보시다시피 프로젝트의 규모는 31% 증가하여 ‘Small’에서 ‘Medium’으로 변경되었습니다. 미완성된 기능들을 개발했을뿐더러 새로운 요구사항이 지속해서 생겨나 규모가 커지게 되었죠. 그에 반해 ‘Bugs’는 사라졌고, 취약점도 38개가 줄어들어 기존보다 68% 감소하였습니다. 또한 코드 악취는 459개가 줄어들어 기존보다 87% 감소하였습니다. 그뿐만 아니라 테스트 커버리지는 0%에서 19.6%로 증가하였습니다. 테스트 코드는 새로운 기능을 개발할 때는 필수로 작성하고 있으며 틈틈이 기존 기능들에 대해서도 지속해서 작성하고 있습니다. 코드 중복도 1.5%에서 0.5%로 줄어들었네요.</p><p>요약하자면 프로젝트 규모는 기존보다 커졌지만, 코드 품질은 좋아졌습니다. 이 같은 결과는 새로운 코드들의 품질만 신경 써서 이루어진 것이 아닌 기존 코드들을 지속해서 가다듬었기에 가능했습니다. 돌이켜 보면 개선해온 과정이 항상 즐겁지만은 않았습니다. 때론 지루하고, 때론 흥미롭고, 때론 답답하고, 때론 고통스러웠고, 때론 상쾌했습니다. 확실한 것은 개인적인 성장에 큰 도움이 되었다는 것입니다. 이제, 제가 어떻게 코드들을 개선 시켰는지 간단히 소개해드리겠습니다. 모든 내용을 제가 설명하기에는 글이 너무나 길어질 것 같아 각 항목에 제가 참고한 글들을 링크해 두겠습니다. 좋은 글들을 작성해주신 모든 분께 감사의 인사를 드립니다.</p><h2 id="스프링-레거시-코드를-개선하는데-실천한-13가지-방법"><a href="#스프링-레거시-코드를-개선하는데-실천한-13가지-방법" class="headerlink" title="스프링 레거시 코드를 개선하는데 실천한 13가지 방법"></a>스프링 레거시 코드를 개선하는데 실천한 13가지 방법</h2><p>이제, 제가 프로젝트의 코드를 개선하는데 사용한 13가지 방법을 소개할 것인데요, 그 전에 프로젝트의 환경을 간단히 말씀드리면 좋겠네요. Spring4 기반의 웹 프로젝트로 SQL Mapper로 Mybatis를 사용하는 환경입니다. 이 글이 최신 SpringBoot2, JPA, Querydsl 등을 업무상 사용하지 못하는 분들께도 큰 도움이 되었으면 좋겠습니다.</p><h3 id="1-테스트-코드-작성"><a href="#1-테스트-코드-작성" class="headerlink" title="1. 테스트 코드 작성"></a>1. 테스트 코드 작성</h3><p>기존 코드에는 테스트 코드가 없었습니다. 특히, 코드 리팩토링을 진행할 때 테스트 코드가 필수라고 생각되어 최대한 작성하려고 노력하였습니다. 그리고 신규 추가되는 기능들에는 필수적으로 테스트 코드를 작성했습니다. 처음에는 의무적으로 테스트 코드를 작성하였는데요. 작성하다 보니 테스트 코드의 순기능에 대해 많이 공감하게 되었습니다. 프로그램을 재시작(톰캣 재시작 등)하지 않고 피드백을 받을 수 있다 보니 훨씬 안정적으로 코드를 작성할 수 있었습니다. 또한, 테스트 코드를 이리저리 돌려보며 프레임워크나 라이브러리의 내부 동작 원리에 대한 이해도도 높아졌습니다. 이제는 신규 라이브러리를 사용하게 될 때면 테스트 코드를 통해 테스트를 먼저 해보는 습관도 생긴 것 같네요. 물론, 아직 작성해야 할 테스트 코드가 많이 남았습니다.</p><blockquote><p>참고: <a href="http://kwangshin.pe.kr/blog/2018/06/26/software-development-productivity-difficulties-and-challanges/" rel="external nofollow noopener noreferrer" target="_blank">소프트웨어 개발의 생산성, 그 어려움과 도전…</a></p><p>참고: <a href="https://www.slideshare.net/SpringCentral/testing-with-spring-framework-4x" rel="external nofollow noopener noreferrer" target="_blank">Testing with Spring Framework 4.x</a></p><p>참고: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#unit-testing" rel="external nofollow noopener noreferrer" target="_blank">Spring 공식 문서 - Testing</a></p><p>참고: <a href="https://thswave.github.io/java/2015/03/02/spring-mvc-test.html" rel="external nofollow noopener noreferrer" target="_blank">How to Spring MVC Unit Test 스프링 MVC 단위 테스트</a></p><p>참고: <a href="https://dreambringer.tistory.com/14" rel="external nofollow noopener noreferrer" target="_blank">spring mvc 에서 unit test 구현 (Controller, Service, DAO)</a></p><p>참고: <a href="https://igorski.co/java/junit/mixing-junit-4-and-junit-5-tests/" rel="external nofollow noopener noreferrer" target="_blank">Mixing JUnit 4 and JUnit 5 tests</a></p></blockquote><p>이전까지 SpringBoot 환경에서만 테스트 코드를 작성해보다가 Spring4 환경에서 작성하려니 테스트 코드의 환경을 설정하는 것에서부터 어려움이 많았고 그만큼 시행착오도 많았습니다. 이제 테스트 코드의 형태가 안정되었는데요. 기회가 된다면 Spring4와 같은 레거시 환경에서 테스트 코드를 작성하는 방법도 공유할 생각입니다.</p><h3 id="2-단순히-값을-나타내는-객체가-아닌-역할을-갖는-객체로-변경"><a href="#2-단순히-값을-나타내는-객체가-아닌-역할을-갖는-객체로-변경" class="headerlink" title="2. 단순히 값을 나타내는 객체가 아닌 역할을 갖는 객체로 변경"></a>2. 단순히 값을 나타내는 객체가 아닌 역할을 갖는 객체로 변경</h3><p>이전 코드들에서는 객체 중심의 코드가 아닌 데이터 중심의 코드가 많았습니다. 특히 객체들이 특별한 역할 없이 getter와 setter로 이루어진 경우가 많았죠. 객체들이 수행해야 할 것들이 객체 외부에서 getter와 setter를 통해 이루어지고 있었던 것입니다. 그래서 저는 다음의 활동을 통해 리팩토링을 해나갔습니다.</p><ol><li><p>단순히 값을 나타내는 VO 객체를 제거하였습니다.</p></li><li><p>객체 외부에 존재하는 로직을 객체 내부로 옮겼습니다.</p></li><li><p>model 객체에 대한 테스트를 작성하였습니다.</p></li><li><p>비슷한 역할을 갖고 있으면 interface를 통해 적극적으로 추상화를 하였습니다.</p></li><li><p>setter를 제거하였습니다.</p><blockquote><p>참고: <a href="https://jojoldu.tistory.com/407" rel="external nofollow noopener noreferrer" target="_blank">@Reuqest Body에서는 Setter가 필요없다?</a></p></blockquote></li><li><p>getter의 사용을 최소화 하였습니다.</p></li></ol><p>관련해서는 제가 작성했던 글인 ‘<a href="https://sogoagain.github.io/2019/09/25/AWS도-Setter를-사용하지-않는다/">AWS도 Setter를 사용하지 않는다</a>‘를 참고하면 좋을 것 같습니다.</p><h3 id="3-static-클래스를-Bean과-Component로-변경"><a href="#3-static-클래스를-Bean과-Component로-변경" class="headerlink" title="3. static 클래스를 Bean과 Component로 변경"></a>3. static 클래스를 Bean과 Component로 변경</h3><p>기존 코드에 static 메서드만 존재하는 static 클래스가 많았습니다. 그런데, static 함수나 클래스는 사용하는 곳에서 의존성을 외부로 드러내지 않고 내부로 감추게 됩니다. 이는 마치 전역 변수, 전역 함수를 사용하는 것과 같은 문제가 발생하게 되죠. 변경의 여파를 파악하기 힘들어지며 복잡성이 증가합니다. 그래서 저는 static 클래스들을 Spring에서 지원하는 Bean과 Component로 변경하였습니다.</p><blockquote><p>참고: <a href="http://kwon37xi.egloos.com/4844149" rel="external nofollow noopener noreferrer" target="_blank">언제 static 함수 모음 Class를 만들어야 할까?</a></p><p>참고: <a href="https://docs.microsoft.com/ko-kr/archive/blogs/nickmalik/are-helper-classes-evil" rel="external nofollow noopener noreferrer" target="_blank">Are Helper Classes Evil?</a></p><p>참고: <a href="https://docs.microsoft.com/ko-kr/archive/blogs/nickmalik/killing-the-helper-class-part-two" rel="external nofollow noopener noreferrer" target="_blank">Killing the Helper class, part two</a></p></blockquote><h3 id="4-Controller-Service-Model의-계층-구조를-명확히"><a href="#4-Controller-Service-Model의-계층-구조를-명확히" class="headerlink" title="4. Controller, Service, Model의 계층 구조를 명확히"></a>4. Controller, Service, Model의 계층 구조를 명확히</h3><p>기존 코드에서 Controller에 비즈니스 로직이 있거나, Model에 있어야 할 로직이 Service에 있거나 하는 사항이 발견되었습니다. 저는 이러한 점들을 해결하기 위해 ‘3계층 구조(3 Tier)’에 근거하여 각각의 역할을 나름대로 정의하여 프로젝트를 진행하였습니다.</p><ol><li><p>Controller는 Presentation 계층으로서 입력값 검증, Application 계층에서 필요한 객체를 준비, 결괏값을 요청한 곳에 반환하는 역할로 규정하였습니다.</p><blockquote><p>참고: <a href="https://www.baeldung.com/spring-boot-bean-validation" rel="external nofollow noopener noreferrer" target="_blank">Validation in Spring Boot</a></p></blockquote></li><li><p>Service는 Application 계층으로서 정보를 처리하고 원하는 결과를 만들어내는 역할로 객체들이 협력하는 장소라고 규정하였습니다.</p></li><li><p>Model은 domain의 비즈니스 로직을 구현하는 역할로 규정하였습니다.</p></li></ol><h3 id="5-Java의-Best-Practice-적용"><a href="#5-Java의-Best-Practice-적용" class="headerlink" title="5. Java의 Best Practice 적용"></a>5. Java의 Best Practice 적용</h3><p>기존 코드는 Java의 Best Practice와 거리가 먼 코드들이 있었습니다. 특히 ‘LocalDate, LocalDateTime’ 대신 ‘Date’와 ‘Calander’를 사용하여 시간 관련된 로직을 처리하고 있었죠. 이 밖에도 ‘정적 팩토리 메서드’와 같은 Effective Java에 나오는 실천 사항들이 지켜지지 않고 있었습니다. 뿐만 아니라 디자인 패턴의 활용도도 낮았습니다. 그래서 아래의 개선 활동을 하였습니다.</p><ol><li>‘Date’, ‘Calander’를 ‘LocalDate’, ‘LocalDateTime’을 사용하도록 변경하였습니다.</li><li>Effective Java에 나오는 실천 사항을 지키며 점진적으로 개선하였습니다.</li><li>팩토리 패턴, 전략 패턴 등 디자인 패턴을 활용 하였습니다.</li></ol><h3 id="6-Spring의-Best-Practice-적용"><a href="#6-Spring의-Best-Practice-적용" class="headerlink" title="6. Spring의 Best Practice 적용"></a>6. Spring의 Best Practice 적용</h3><p>기존 코드에서는 Spring을 사용할 때 Best Practice와는 거리가 먼 코드들이 몇몇 있었습니다. DI를 활용할 때 Field Injection을 활용하거나 Service에 불필요하게 1:1 매핑된 인터페이스가 존재하였죠. 그래서 이를 개선하였습니다.</p><ol><li><p>Field Injection을 Constructor Injection으로 변경</p><blockquote><p>참고: <a href="https://www.vojtechruzicka.com/field-dependency-injection-considered-harmful/" rel="external nofollow noopener noreferrer" target="_blank">Field Dependency Injection Considered Harmful</a></p><p>참고: <a href="https://zorba91.tistory.com/238" rel="external nofollow noopener noreferrer" target="_blank">[Spring]필드 주입(Field Injection) 대신 생성자 주입(Constructor Injection)을 사용해야 하는 이유</a> </p></blockquote></li><li><p>불필요하게 Service와 1:1 매핑된 interface 제거하고 필요한 interface를 추출</p><blockquote><p>참고: <a href="https://www.slipp.net/questions/19" rel="external nofollow noopener noreferrer" target="_blank">Business Layer에 Interface를 만들어야 할까?</a></p></blockquote></li></ol><h3 id="7-Annotation-전략"><a href="#7-Annotation-전략" class="headerlink" title="7. Annotation 전략"></a>7. Annotation 전략</h3><p>기존 코드에서 Lombok을 사용하고 있었습니다. 그런데, 대부분의 객체에 @Data와 @AllArgsConstructor 등의 사용을 자제해야 하는 Annotaion들이 작성되어 있었습니다. 그래서 @Data대신 @Getter만을 사용하도록 하는 등의 변경하였습니다. 최대한 변경의 여파가 크지 않도록 필요한 것들만 보수적으로 Annotaion을 적용하였죠. 그뿐만 아니라 객체들의 역할에 따라 어느 정도 Annotaion들이 일관성을 띠게 되어 나름대로 Annotaion 전략도 수립하였죠.</p><blockquote><p>참고: <a href="https://popit.kr/실무에서-lombok-사용법/" rel="external nofollow noopener noreferrer" target="_blank">실무에서 Lombok 사용법</a></p><p>참고: <a href="https://kwonnam.pe.kr/wiki/java/lombok/pitfall" rel="external nofollow noopener noreferrer" target="_blank">Lombok 사용상 주의점(Pitfall)</a></p></blockquote><h3 id="8-Exception-전략"><a href="#8-Exception-전략" class="headerlink" title="8. Exception 전략"></a>8. Exception 전략</h3><p>기존 코드에서도 ControllerAdvice를 이용하여 에러를 처리하고 있었습니다만, API 요청을 처리하던 중에 발생한 오류인지 페이지 요청을 처리하던 중에 발생한 오류인지 구분하지 않고 처리를 하고 있었습니다. 또한, 오류에 대한 상세 내용이 명확히 정의되어 있지 않아 개선하였습니다. 참고 글들을 참고해 나름의 Exception 전략을 세우고 Error 응답에 대해서는 통일된 형식의 응답을 반환하도록 개선했습니다.</p><blockquote><p>참고: <a href="https://cheese10yun.github.io/spring-guide-exception/" rel="external nofollow noopener noreferrer" target="_blank">Spring Guide - Exception 전략</a></p><p>참고: <a href="https://www.slipp.net/questions/600" rel="external nofollow noopener noreferrer" target="_blank">Spring에서 @ControllerAdvice를 활용한 Exception 처리</a></p><p>참고: <a href="https://stackoverflow.com/questions/43325685/spring-different-exception-handler-for-restcontroller-and-controller" rel="external nofollow noopener noreferrer" target="_blank">Spring: Different exception handler for RestController and Controller</a></p></blockquote><h3 id="9-Logging-정책"><a href="#9-Logging-정책" class="headerlink" title="9. Logging 정책"></a>9. Logging 정책</h3><p>기존 코드는 서로 다른 Controller마다 메서드에서 비슷한 유형의 로깅 관련 코드가 중복되어 존재하였습니다. Controller 도입부에는 넘어온 파라미터를 로깅하고 처리가 끝났을 때는 반환하는 값을 로깅하고 있었죠. 저는 Spring의 큰 장점인 AOP를 활용하여 Controller 단의 로깅을 공통으로 처리하도록 개선하였습니다.</p><blockquote><p>참고: <a href="https://jeong-pro.tistory.com/171" rel="external nofollow noopener noreferrer" target="_blank">Spring AOP 스프링이 해줄건데 너가 왜 어려워 해? Spring boot에서 aop logging 사용법 제일 쉽게 알려드립니다!</a></p><p>참고: <a href="https://blog.azulpintor.io/entry/spring4-aop-usage-example-simply" rel="external nofollow noopener noreferrer" target="_blank">Spring4 AOP 간단한 사용예제</a></p><p>참고: <a href="https://aljjabaegi.tistory.com/278" rel="external nofollow noopener noreferrer" target="_blank">AOP 설정을 활용한 세션체크 AOP Session Check</a></p><p>참고: <a href="https://makeinjava.com/logging-aspect-restful-web-service-spring-aop-request-response/" rel="external nofollow noopener noreferrer" target="_blank">Logging aspect in RESTful web service – spring aop (log requests/responses)</a></p></blockquote><h3 id="10-Mybatis-연관-관계-매핑-사용"><a href="#10-Mybatis-연관-관계-매핑-사용" class="headerlink" title="10. Mybatis 연관 관계 매핑 사용"></a>10. Mybatis 연관 관계 매핑 사용</h3><p>제가 맡은 프로젝트가 JPA를 사용하지 않는 환경이라 아쉬움이 많았습니다. Mybatis는 SQL의 결과를 객체에 할당해주기는 하지만 JPA의 Entity 개념이 아니기 때문에 객체들과의 연관관계나 객체의 동일성 등을 표현하는 데 어려움이 있었기 때문입니다. 그래도 저는 기존 환경에서 최대한 개선을 해보고자 JPA와 비슷하게 매핑하려고 노력하였습니다. 특히, 기존 코드는 연관 관계 매핑을 활용하고 있지 않았습니다. 저는 Mybatis에서 제공하는 연관 관계 매핑을 적극적으로 사용하여 객체지향 적으로 코드를 작성하기 위해 노력했습니다. 물론, JPA에서 제공하는 것처럼 객체 그래프가 완벽하진 않지만 나름대로 만족하며 사용하고 있습니다. JPA보다 개발 공수가 더 든다는 것이 굉장히 아쉽습니다.</p><blockquote><p>참고: <a href="https://mybatis.org/mybatis-3/ko/sqlmap-xml.html" rel="external nofollow noopener noreferrer" target="_blank">Mapper XML 파일</a></p><p>참고: <a href="http://vincent4chen.com/mybatis/install/MyBatis-One-to-One-Mapping/" rel="external nofollow noopener noreferrer" target="_blank">MyBatis One to One Mapping</a></p></blockquote><p>연관 관계 매핑을 적용하던 중 Enum 매핑을 할 때 애를 먹었습니다. 예를 들면 DB에 0이 저장되어 있을 때 ‘ProductType’의 ‘Phone’이 매핑되고 1이 저장되어 있을 때 ‘ProductType’의 ‘Pad’가 저장되는 식의 구현이죠. Type Handler를 구현하여 문제를 해결했는데 그 과정에서 다음의 글이 큰 도움을 주었습니다.</p><blockquote><p>참고: <a href="https://github.com/mybatis/mybatis-3/issues/42" rel="external nofollow noopener noreferrer" target="_blank">Proposal for an enum type handler which persists specified value rather than ordinal or name.</a></p></blockquote><p>연관 매핑을 사용하기 위해서 Mybatis 공식 문서를 자세히 읽게 되었는데요. 이때 Mybatis 번역과 관련되어 이슈를 제기하기도 하였네요. 어쩌다 보니 오픈 소스 프로젝트에 첫 이슈를 제기해보는 경험도 하게 되었습니다.</p><blockquote><p><a href="https://github.com/mybatis/mybatis-3/issues/1602" rel="external nofollow noopener noreferrer" target="_blank">The contents of the ‘caption’ tag are garbled In the Korean translation document</a></p></blockquote><h3 id="11-비동기-로직-활용"><a href="#11-비동기-로직-활용" class="headerlink" title="11. 비동기 로직 활용"></a>11. 비동기 로직 활용</h3><p>제가 작성한 글 ‘<a href="https://sogoagain.github.io/2019/09/25/AWS도-Setter를-사용하지-않는다/">AWS도 Setter를 사용하지 않는다</a>‘에서도 간단히 언급한 적이 있지만, 기존 코드에서는 외부 API를 호출하고 수행하는 로직들이 동기 방식으로 구현되어 있어 처리 속도 면에서 불리한 점들이 있었습니다. 외부 API를 호출하는 로직 중 비동기로 전환할 수 있는 것들에 대해서 적극적으로 비동기로 전환하였습니다. 이렇게 개선하는 중에 @Async와 @Transactional을 동시에 사용할 수 없다는 것도 알게 되었죠. 그래서 API 호출하는 Service와 DB 작업을 하는 Service를 분리하였습니다. API 호출하는 서비스에서 DB 작업을 하는 서비스를 호출하여 로직을 처리하도록 구현했습니다.</p><blockquote><p>참고: <a href="https://www.slipp.net/questions/123" rel="external nofollow noopener noreferrer" target="_blank">spring transaction을 활용해 async로 데이터를 처리할 때의 이슈</a></p></blockquote><h3 id="12-정적-소스-코드-분석-툴-도입"><a href="#12-정적-소스-코드-분석-툴-도입" class="headerlink" title="12. 정적 소스 코드 분석 툴 도입"></a>12. 정적 소스 코드 분석 툴 도입</h3><p>제 나름대로 제가 갖고 있던 지식과 인터넷에서 얻은 지식 그리고 주변 사람들로부터 얻은 지식을 종합해 프로젝트를 개선하고 있었습니다. 그런데, 정말로 제가 가는 길이 올바른 길인지 의문점이 들었습니다. 그때 소스코드를 정적으로 분석해주는 툴을 알게 되었고 그러한 프로그램 중 하나인 SonarQube를 docker를 활용해 제 로컬 환경에 구축하였습니다. IDE인 IntelliJ와 연동하여 실시간으로 제가 작성한 코드에 문제가 없는지 확인하고 있으며 개발이 끝나면 코드 분석을 돌려 코드 품질이 어떤지 확인하며 피드백을 받고 있습니다.</p><blockquote><p>참고: <a href="https://daddyprogrammer.org/post/817/sonarqube-analysis-intergrated-intellij/" rel="external nofollow noopener noreferrer" target="_blank">소나큐브(Sonarqube)를 통한 코드 분석 및 코드 품질 향상</a></p><p>참고: <a href="http://www.chidoo.me/index.php/2016/03/21/sonarqube-for-ci/" rel="external nofollow noopener noreferrer" target="_blank">SonarQube 이용해서 만드는 CI</a></p><p>참고: <a href="https://github.com/screwdriver-cd-test/sonar-coverage-example-java" rel="external nofollow noopener noreferrer" target="_blank">sonar-coverage-example-java</a></p></blockquote><h3 id="13-도메인-기반-패키지-구조"><a href="#13-도메인-기반-패키지-구조" class="headerlink" title="13. 도메인 기반 패키지 구조"></a>13. 도메인 기반 패키지 구조</h3><p>기존 코드는 기능 중심의 계층형 패키지 구조로 되어 있었습니다. Controller들은 controller 패키지에, Service들은 service 패키지에 위치한 모습이었죠. 처음에는 큰 문제가 없었으나 프로젝트의 크기가 커지고 각각의 요소들이 많아지게 되자 문제가 발생했습니다. 저는 특정 도메인과 관련된 코드를 수정하고 싶을 뿐인데 도메인과 관련된 클래스 파일들이 흩어져있어기에 관련된 클래스들만 찾는데도 큰 노력이 들었습니다. 또한, 이전 코드는 하나의 Controller에서 여러 도메인에 대해 처리를 하기도 하였습니다. 이대로 가면 안 되겠다 싶어 개선을 진행했습니다.</p><p>일단, 여러 도메인이 섞여 있는 Controller와 같은 클래스들에 대해서 도메인 별로 분리하였습니다. 그리고 전체 디렉터리 구조를 도메인 기반으로 변경하였죠. 이렇게 구조를 변경하니 개발뿐만 아니라 차후 유지보수를 하는 데도 편하였습니다. 기능 하나를 수정하기 위해 여러 클래스를 찾아다니는 노력이 많이 줄었죠.</p><blockquote><p>참고: <a href="https://cheese10yun.github.io/spring-guide-directory/" rel="external nofollow noopener noreferrer" target="_blank">Spring Guide - Directory</a></p><p>참고: <a href="https://github.com/spring-projects/spring-petclinic" rel="external nofollow noopener noreferrer" target="_blank">spring-petclinic</a></p></blockquote><h2 id="회고"><a href="#회고" class="headerlink" title="회고"></a>회고</h2><p>긴 글이 될 것이라 예상은 했기에 감안하고 최대한 축약하여 표현하였습니다. 그런데도 예상을 뛰어넘는 긴 글이 되어 버렸네요. 글에서는 각각의 항목을 몇 줄로 표현하였지만, 당시 저는 각각의 항목을 개선하기 위해 고민과 노력을 굉장히 많이 하였습니다. 생각보다 쉽지 않더라고요. 솔직히 고통스러웠습니다. 중간에 ‘포기하고 기존 코드들을 유지한 채로 개발을 진행할까?’라는 고민을 수도 없이 했습니다.</p><p>하지만 개발자라면 해야 하는 일이라고 생각하여 참고 진행했습니다. 모두가 언제나 완벽히 클린한 코드를 원하지만, 현실은 누군가 ‘처음’ 작성한 코드를 이어받고 서비스를 운영하는 입장에 놓이게 되니까요. 이번에 제가 제 나름대로 개선했다고 생각하는 코드도 누군가에게는 레거시 코드로 느껴지리라 생각합니다. 어쩌면 이번 경험을 평생 해나가야 하는 게 개발자가 아닌가 생각도 해봅니다. 고통스러운 과정이었지만 개선된 모습을 보고 나니 너무나 뿌듯하네요. 특히 SonarQube를 통해 확연히 변한 결과를 보니 더욱더 뿌듯했습니다. 개선하면서 배운 것도 참 많았다는 생각도 합니다. 위 개선 사항 중 하나만 꼽으라면 저는 ‘테스트 코드 작성’을 꼽겠습니다. 아직 테스트 코드를 작성해보지 않으신 다른 개발자분들도 시도해 보셨으면 합니다. 피드백을 필요할 때 빠르게 받으니 장점이 많았습니다.</p><p>물론, 아직 가야 할 길이 많습니다. 개선하고 싶은 부분도 많고요.  개선을 진행할 때마다 제가 수정하는 방향이 옳은 것인지 확신을 가지려고 자료 참고도 많이 하였습니다. 그런데도 부족한 점이나 잘못된 부분들이 있을 것입니다. 혹시나 다른 생각을 하고 계신 분들은 의견 공유해주시면 그것을 피드백 삼아 더 나은 코드를 작성하는 데 노력하겠습니다. 긴 글인데 여기까지 읽어주셔서 감사합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;프로젝트를-이어받다&quot;&gt;&lt;a href=&quot;#프로젝트를-이어받다&quot; class=&quot;headerlink&quot; title=&quot;프로젝트를 이어받다.&quot;&gt;&lt;/a&gt;프로젝트를 이어받다.&lt;/h2&gt;&lt;p&gt;저는 작년(2019년) 6월 말에 새로운 회사로 이직하였습니다. 
      
    
    </summary>
    
      <category term="객체지향" scheme="https://sogoagain.github.io/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
    
      <category term="java" scheme="https://sogoagain.github.io/tags/java/"/>
    
      <category term="OOP" scheme="https://sogoagain.github.io/tags/OOP/"/>
    
      <category term="TDD" scheme="https://sogoagain.github.io/tags/TDD/"/>
    
      <category term="객체지향" scheme="https://sogoagain.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
      <category term="클린코드" scheme="https://sogoagain.github.io/tags/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/"/>
    
      <category term="Spring" scheme="https://sogoagain.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>삶에 애자일 도입하기</title>
    <link href="https://sogoagain.github.io/2020/01/12/%EC%82%B6%EC%97%90-%EC%95%A0%EC%9E%90%EC%9D%BC-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0/"/>
    <id>https://sogoagain.github.io/2020/01/12/삶에-애자일-도입하기/</id>
    <published>2020-01-12T14:41:22.000Z</published>
    <updated>2020-01-13T16:05:29.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="김창준님의-‘함께-자라기-애자일로-가는-길’을-읽고"><a href="#김창준님의-‘함께-자라기-애자일로-가는-길’을-읽고" class="headerlink" title="김창준님의 ‘함께 자라기 - 애자일로 가는 길’을 읽고"></a>김창준님의 ‘함께 자라기 - 애자일로 가는 길’을 읽고</h2><h3 id="애자일-잡힐-듯-잡히지-않는-것"><a href="#애자일-잡힐-듯-잡히지-않는-것" class="headerlink" title="애자일, 잡힐 듯 잡히지 않는 것"></a>애자일, 잡힐 듯 잡히지 않는 것</h3><p>대학 시절 ‘동양철학’을 다루는 강의를 수강한 적이 있습니다. 전체적으로 굉장히 어려운 내용이었지만 그중에서도 특히 ‘도가사상’이 기억에 많이 남습니다. 도를 설명하는 부분이 난해했기 때문입니다. 호접지몽(나비 꿈)으로 유명한 장자가 도란 어디에 있는 것인지 묻는 동곽자라는 사람의 질문에 이렇게 말했다고 합니다. “도는 있지 않은 곳이 없다. 땅강아지나 개미에도 돌피나 피 따위에도 기왓장이나 벽돌 조각에도 똥이나 오줌 속에도 있다.”&lt;지북유(知北遊)&gt;라고 말이죠. 이해가 되나요? 도를 정의하면서 도란 명확히 무엇인지 말해주지는 않습니다.</p><p>그런데, 제가 애자일 이라는 것을 접하면서도 장자가 설명하는 도와 비슷한 느낌을 받았습니다. ‘애자일은 문화다’, ‘애자일은 애자일 적인 조직에서 나온다.’, ‘방법론만 도입해서는 애자일이 아니다.’ 등 모두 애자일을 설명하는 문서나 발표를 보면 많이 나오는 문장입니다. 어딘가 도의 정의와 비슷하지 않나요? 애자일을 설명하면서 애자일이 명확히 무엇인지는 말해주지 않습니다.</p><p>저는 애자일을 대학 시절 ‘소프트웨어 공학’ 강의에서 처음 접하였습니다. 당시 소프트웨어 공학 서적과 인터넷에 있는 자료를 바탕으로 나름대로 정리해서 블로그에 글을 작성하기도 하였습니다. 찾아보니 제가 블로그에 작성한 첫 글이네요.</p><blockquote><p><a href="https://sogoagain.github.io/2017/01/05/애자일-소프트웨어-개발/">애자일 소프트웨어 개발</a></p></blockquote><p>이 당시에는 애자일을 폭포수 모델, 프로토타이핑, 나선형 모델 등등 처럼 하나의 이론적인 방법론으로 받아들였습니다. 단순히 작은 일들을 짧은 주기로 반복하며 개발해 나가는 방식이라고만 생각했던 것이죠. 그런데, 시간이 지남에 따라 책과 자료들을 접하게 되면서 애자일이 단순히 개발 방법론만을 뜻하는 것이 아닌 하나의 문화라는 것을 알게 되었습니다. 이러한 과정에서 존경하는 선배 개발자분들(켄트 백, 마틴 파울러 등)이 외치는 애자일이라는 것을 더 알고 싶게 되었죠. 그러다 김창준 님의 ‘함께 자라기’ 책을 읽게 되었습니다. 이 책을 통해 이제는 애자일이 어떠한 것인지 깨닫게 되었습니다. (도가 사상도 언젠가 깨닫게 되는 날이 오면 좋겠네요. 😂) 더 나아가 애자일을 제 삶에 도입해야겠다고 다짐하게 되었습니다.</p><h3 id="함께-자라기"><a href="#함께-자라기" class="headerlink" title="함께 자라기"></a>함께 자라기</h3><p>이 책의 제목은 함께 자라기입니다. 저자는 책 제목이 애자일의 핵심이라고 합니다. 함께는 ‘협력’을, 자라기는 ‘학습’을 의미한다고 하네요. 그리고 책 제목에는 빠져 있지만, 책의 내용을 통해 추론해보면 ‘함께 자라기’ 앞에 ‘매일매일’이라는 단어가 생략된 것 같습니다. ‘매일매일’은 ‘함께 자라기’의 접근 방법을 뜻한다고 합니다.</p><p>저는 이 책을 읽기 전까지 ‘학습’과 ‘협력’에 대해서 따로따로 고민은 많이 해봤지만, 같이 해본 적은 없는 것 같습니다. 그래서 지금은 당연한 문장인 ‘함께 자라기’가 제게는 큰 화젯거리로 다가왔습니다. 어떤 일을 진행할 때 각자가 혼자 학습을 하고, 학습이 끝난 뒤 모여서 협력을 통해 결과물을 내는 것이라고 생각했던 것이죠. 즉, 학습은 개인의 책임으로 치부했던 것이고 협력은 학습과는 별개로 이루어진다고 보았습니다. 하지만 이 책을 통해 생각을 바로잡을 수 있었습니다. 같이 학습할 수 있다는 것을 알게 되었고 더 나아가 혼자 학습할 때 보다 같이할 때 더 큰 효과를 볼 수 있다는 것을 알게 되었습니다. 책에서 아래의 ‘워드 커닝햄, 우리는 팀인가요?’의 인용문이 나오는데 함께의 힘을 잘 설명하는 것 같습니다.</p><blockquote><p>(생략) 사람들이 하나의 문제를 해결하기 위해 각자의 경험을 동원할 수 있도록 허락했을 때 그들이 무슨 일을 할지 한 사람으로서는 상상하기가 무척이나 어렵기 때문입니다.</p><p>(생략)</p><p>‘관심사의 섞임(mingling of concerns)’을 통해 서로에 대해 엄청나게 많은 것을 매우 빨리 배울 수 있기 때문입니다.</p><ul><li>김창준. 함께 자라기:185-186 (워드 커닝햄, 우리는 팀인가요?의 인용문 재인용)</li></ul></blockquote><h3 id="내-삶에-애자일을-도입하기"><a href="#내-삶에-애자일을-도입하기" class="headerlink" title="내 삶에 애자일을 도입하기"></a>내 삶에 애자일을 도입하기</h3><p>저는 책을 읽고 ‘함께 자라기’를 제 삶 속에서 지속해서 실천하리라 다짐하였습니다. 어제보다 나은 내가, 동료가, 팀이, 회사가 매일매일 우리를 반긴다면 너무나 행복한 삶이 될 것이라 생각하기 때문입니다. 이를 위해 책에서 제시해주는 지침들을 실천해보고자 합니다.</p><p>책에서는 우리의 고정관념을 깨뜨리는 사실들을 통해 어떻게 삶에 ‘함께 자라기’ 즉 애자일을 녹일 수 있는지 접근 방법을 제시해주고 있습니다. 이 방법들을 하나하나 읽다보면 저자의 내공에 감탄을 하게 됩니다. 책에서 주장하는 내용들은 모두 객관적인 근거가 있습니다. 그리고 그 객관적인 근거들을 쉽게 풀어 설명하고 해석해주며 독자로 하여금 인사이트를 얻게 해주기 때문입니다. 책을 읽는 내내 감사한 마음이 들었습니다. 그리고 저를 돌아보게 되고 앞으로 어떻게 행동해야할 지 떠오르게 되었습니다.</p><h4 id="“자라기”에-대해서"><a href="#“자라기”에-대해서" class="headerlink" title="“자라기”에 대해서"></a>“자라기”에 대해서</h4><p>책에서는 먼저 ‘’자라기’’에 대해서 말합니다. 자신의 연차가 실력을 말해주지 않는다는 뼈아픈 소리와 함께 자기 계발의 중요성과 어떤 마인드로 어떻게 수련 해야 하는 지를 알려줍니다. 이 내용은 제가 앞서 읽었던 “1만 시간의 재발견: 노력은 왜 우리를 배신하는가” 책과 비슷한 맥락을 가지고 있다고 생각합니다.</p><blockquote><p>“1만 시간의 재발견” 독후감: <a href="https://sogoagain.github.io/2019/10/22/의식적인-연습에-기반한-나의-앞으로의-학습/">의식적인 연습에 기반한 나의 앞으로의 학습</a></p></blockquote><p>책에서는 ‘인지적 작업 분석’이라는 개념을 알려줍니다. 제가 받아들이기에 ‘인지적 작업 분석’은 ‘1만 시간의 재발견’ 책에서 말하는 심적 표상과도 연관이 있는 것 같았습니다. ‘인지적 작업 분석’은 문제를 해결할 때 어떤 과정을 거치는지 질문을 던지고 분석하는 것인데요, 이는 곧 심적 표상을 다듬는 과정으로 볼 수 있기 때문입니다. 전문가의 심적 표상을 어떻게 하면 구체적으로 얻을 수 있을까 고민이 많았는데 힌트를 하나 얻은 것 같아 상쾌했습니다.</p><h4 id="“함께”에-대해서"><a href="#“함께”에-대해서" class="headerlink" title="“함께”에 대해서"></a>“함께”에 대해서</h4><p>‘함께’를 설명하는 장에서는 저의 고정관념이 많이 깨졌습니다. 무조건 공유를 하면 신뢰가 향상될 것이라는 믿음이 대표적입니다. 저는 일을 진행하는 데 있어서 투명한 것이 좋다고 생각하였는데 항상 그렇지 않다는 것을 알게 되었고 투명하게 공유를 하되 어떻게 공유하면 좋을지 생각해보게 되었습니다. 그 외에도 전문가는 고독하다는 생각, 전문가팀은 업무를 할 때 하향식으로 체계적으로 접근한다는 생각 등 많은 고정관념이 깨지고 생각의 변화가 몰아쳤습니다.</p><h3 id="중요한-것은-사람"><a href="#중요한-것은-사람" class="headerlink" title="중요한 것은 사람"></a>중요한 것은 사람</h3><p>책을 읽으면서 가장 크게 느낀 것은 결국 사람이라는 것입니다. 나와 우리는 모두 사람입니다. 즉, 나와 우리 모두를 변화시키려면 ‘사람’에 대한 이해는 필수라는 것을 깨닫게 된 것이죠. 특히, 책에서 ‘객관성의 주관성’이라는 내용을 읽으며 이 사실을 더욱 공감할 수 있었습니다. 그리고 ‘이것도 모르세요?’ 장에서 나오는 ‘술퍼맨과 홍춘이’의 일화를 통해 ‘공감하고 이해하려는 대화’와 ‘행동을 유도하는 대화’에 큰 감명을 받았습니다. 나의 말 한마디가 다른 사람에게 큰 영향이 된다는 것과 조금만 노력하면 엄청난 가치를 상대에게 전해줄 수 있다는 것은 굉장히 중요한 사실인 것 같습니다.</p><p>책을 읽고난 뒤 저는 어떤 사람이 되어야 할 것인가에 대해 깊은 고민을 하였습니다. 결론적으로 저는 세상의 소용돌이에 영향을 받는 사람이 아닌 내가 세상에 영향을 주는 사람이 되기로 다짐했습니다. 세부적으로는 이 책에서 말하는 ‘함께 자라기’를 실천하면서 말이죠. 학습을 통해 외부 세계가 소용돌이쳐도 상황에 맞게 대응할 수 있는 힘을 기를 것입니다. 그리고 이를 통해 저 스스로 ‘애자일 코치’가 되기를 자처하여 제가 속한 조직에 좋은 영향을 지속해서 줄 것입니다. 이러한 과정에서 저 혼자만이 아닌 제가 속한 조직과 함께 소용돌이치는 외부 세계에 대응하며 긍정적인 영향을 주는 삶을 살고 싶습니다.</p><h3 id="가치-그-중요성"><a href="#가치-그-중요성" class="headerlink" title="가치, 그 중요성"></a>가치, 그 중요성</h3><p>책 마지막에는 애자일을 싹틔울 수 있는 씨앗을 한 문장으로 요약하여 전달해줍니다.</p><blockquote><p>고객에게 매일 가치를 전하라</p><ul><li>김창준. 함께 자라기:198</li></ul></blockquote><p>위의 문장에서 나오는 단어 하나하나들이 모두 중요합니다. 책에서는 각각의 단어들로 어떤 것들을 생각할 수 있는지도 제시해줍니다. 저는 이 중에서도 “가치”에 조금 더 중요성을 두고 싶습니다. 제가 느끼기에 가치라는 단어는 굉장히 중요하고 그 무게감이 상당하다고 생각합니다. 제가 가치라는 단어를 중요시하는 이유는 세상이 가치로 발전한다고 생각하기 때문입니다.</p><p>가치를 전하려는 사람들의 행동이 모여 더 나은 세상을 만들어나가는 것 같습니다. 가치라는 단어 자체는 중요하고 무겁지만, 그것을 실천하는 것은 그리 어렵지 않습니다. 출근길 지하철에서 노약자에게 자리를 양보하는 것은 그분께 가치를 전한 것입니다. 길에 있는 쓰레기를 치우는 것 또한 세상에 가치를 전한 것입니다. 회사에서 내 옆자리에 앉아있는 동료가 어려움에 처했을 때 같이 고민하고 해결하는 것을 도와주면 저는 그 동료에게 가치를 전한 것입니다. 회사가 제공하는 서비스로 고객의 삶이 한층 더 풍요로워졌다면 회사는 그 고객에게 가치를 전한 것입니다.</p><p>하지만, 우리는 가치를 제공해야 한다고 생각하면 너무 크게만 생각하는 것 같습니다. 무언가 대단한 것들을 해야 가치를 전할 수 있다고 생각하는 것이지요. 너무 어렵게 생각하지 말고 각자가 제공할 수 있는 작은 가치들을 가족에게, 친구에게, 애인에게, 동료에게, 고객에게, 세상에 제공해보면 어떨까요? 우리가 세상에 가치를 제공한 만큼 세상은 발전하게 될 것이고 결국 세상이 우리에게 더 큰 가치를 줄 것이라고 저는 믿어 의심치 않습니다.</p><p>책으로 ‘함께 자라기’라는 큰 가치를 제공해준 저자 김창준 님께 감사의 말씀을 전하고 싶습니다. 저는 이 책을 현재까지 두 번 읽었습니다. 그뿐만 아니라, 회사에서 전 직원이 참여하는 독서 모임 시간에 이 책을 다루고자 직원분들께 추천해 드렸습니다. 아직 책을 읽지 않으신 분들은 꼭 한번 읽어보기를 권합니다.</p><h3 id="참고문헌"><a href="#참고문헌" class="headerlink" title="참고문헌"></a>참고문헌</h3><p><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=14341885" rel="external nofollow noopener noreferrer" target="_blank">김창준. 『함께 자라기 (애자일로 가는 길)』. 인사이트. 2018.</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;김창준님의-‘함께-자라기-애자일로-가는-길’을-읽고&quot;&gt;&lt;a href=&quot;#김창준님의-‘함께-자라기-애자일로-가는-길’을-읽고&quot; class=&quot;headerlink&quot; title=&quot;김창준님의 ‘함께 자라기 - 애자일로 가는 길’을 읽고&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="독서" scheme="https://sogoagain.github.io/categories/%EB%8F%85%EC%84%9C/"/>
    
    
      <category term="생각" scheme="https://sogoagain.github.io/tags/%EC%83%9D%EA%B0%81/"/>
    
      <category term="Software engineering" scheme="https://sogoagain.github.io/tags/Software-engineering/"/>
    
      <category term="독서" scheme="https://sogoagain.github.io/tags/%EB%8F%85%EC%84%9C/"/>
    
      <category term="애자일" scheme="https://sogoagain.github.io/tags/%EC%95%A0%EC%9E%90%EC%9D%BC/"/>
    
  </entry>
  
  <entry>
    <title>2019년 회고</title>
    <link href="https://sogoagain.github.io/2020/01/11/2019%EB%85%84-%ED%9A%8C%EA%B3%A0/"/>
    <id>https://sogoagain.github.io/2020/01/11/2019년-회고/</id>
    <published>2020-01-11T13:50:57.000Z</published>
    <updated>2020-01-12T14:32:04.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="조금-늦어진-회고"><a href="#조금-늦어진-회고" class="headerlink" title="조금 늦어진 회고"></a>조금 늦어진 회고</h2><p>2020년 1월 11일인 지금에서야 블로그에 회고 글을 작성하게 되었습니다. 작년 말에 많은 분들이 작성한 회고 글을 보면서 자극과 도움을 동시에 얻을 수 있었습니다. 사실 작년 한 해를 돌아보는 시간과 올해의 계획을 작성하는 시간을 개인적으로 가지긴 했습니다. 블로그에 회고 글을 작성할까도 생각해보았지만 부끄러움이 밀려와 블로그 작성은 포기했습니다. 그런데 결국 저는 회고 글을 작성하고 있네요.</p><p>벌써 2020년을 맞이한 지 10일이 지났습니다. 한 해의 비율로 따지면 대략 1/36 정도를 지나온 셈입니다. 이렇게 계산해보니 1년이 참 짧은 기간이라는 게 몸소 와닿네요. 2020년이 10일밖에 지나지 않았지만, 지금 지내온 기간을 35번만 반복하면 한 해가 지난다는 뜻이니까요. 제가 회고 글을 작성하게 된 계기가 여기에 있습니다. 이렇게 소중한 10일이지만, 10일 동안 새해에 목표한 계획을 제대로 실천하지 못했기 때문입니다. 그래서 회고 글을 통해 작년을 돌아보고 남은 35번의 10일 주기를 잘 보내기 위해 마음을 다잡고자 합니다.</p><h2 id="2019년-전체적인-소감"><a href="#2019년-전체적인-소감" class="headerlink" title="2019년 전체적인 소감"></a>2019년 전체적인 소감</h2><p>2019년은 제게 있어 큰 성장이 되었던 한 해였습니다. 눈으로 보이는 결과물로는 이직이 대표적이겠지만 그 이면에 있는 많은 것들이 저를  성장시켜주었습니다. 개발자의 길을 가야겠다고 다짐하게 되었던 TDD 스터디, 원하는 개발을 할 수 있는 회사로 이직, 개발자로 어떤 삶을 살아가야 행복할 것인지 생각하는 계기가 되었던 박재성 교수님의 ‘NEXTSTEP TDD, Refactoring, Clean Code 5기’ 강의 수강, 소소한 기여를 통한 오픈소스 세계로의 발돋움, 제가 성장하는 데 큰 도움이 되었던 좋은 강의와 책 그리고 사람들, 나와는 거리가 멀다고 생각했지만, 지금은 서서히 재미를 알아가고 있는 운동, 마지막으로 성장하는 활동을 꾸준히 실천하려고 노력했던 저의 모습들이 모두 2019년을 보람차게 만들어 주었습니다.</p><p>물론 모든 것이 완벽하지는 않았습니다. 아쉬웠던 부분들도 있었는데요. 매일매일 학습을 실천하기는 했지만, 그 절대적인 양이 많이 부족 했다는 생각이 듭니다. 완전한 개인 프로젝트를 진행하지 못한 것, 읽고 싶어 사다 놓은 책은 많았지만 읽지 않은 책이 많은 것, 블로그에 작성할 글들을 머릿속에서만 생각하고 실천으로 옮기지 못한 것, 원하던 분야의 공부를 완수하지 못한 것 등이 대표적으로 아쉬웠습니다. 2020년에는 이러한 아쉬움이 덜 하도록 목표를 세우고 실천하고자 합니다.</p><h2 id="TDD-스터디-2019-01-2019-06"><a href="#TDD-스터디-2019-01-2019-06" class="headerlink" title="TDD 스터디 (2019.01 ~ 2019.06)"></a>TDD 스터디 (2019.01 ~ 2019.06)</h2><blockquote><p>스터디 프로젝트 저장소: <a href="https://github.com/sogoagain/tdd-exercises" rel="external nofollow noopener noreferrer" target="_blank">테스트 주도 개발 (Test-driven development) 실천 연습 저장소</a></p></blockquote><p>TDD 스터디는 2019년에 제가 했던 활동 중에 가장 잘한 것이고 가장 제게 영향을 많이 주었던 것이 아닌가 싶습니다. 스터디하게 된 계기부터 말씀드리면 좋을 것 같습니다. 저는 2018년 대학 졸업과 동시에 나름 대기업군으로 분류되는 기업 공채에 합격하여 취업하였습니다. 당시에 저는 회사 생활을 하다 보면 자연스레 SW 개발 분야의 전문가가 되어 있을 것이라는 막연한 생각을 하고 있었습니다. 그렇게 부푼 기대를 안고 첫 사회생활을 시작하였습니다. 열심히 회사에서 업무를 수행하였고 회사 생활이 1년 정도 되었을 때 저를 돌아보는 시간을 가졌습니다. SW 개발 분야 외의 다른 쪽으로는 많이 배우고 성장했지만, SW 개발 분야에서는 오히려 취업 전보다 퇴보한 것 같다는 느낌을 받았습니다. 제가 하던 업무가 개발보다는 관리에 초점이 맞춰져 있었기에 더욱 위기감을 느낀 것도 있습니다. 이유야 어찌 되었든 전문가가 되기 위해서는 회사에서 주어진 업무만 하는 것이 아니라 스스로 자신을 발전시키기 위해 노력해야 한다는 것을 깨닫게 되었습니다. 더는 누군가가 나를 가르쳐주는 학교에 있는 것이 아니라 내가 나를 성장시켜야 하는 사회에 있다는 것을 몸소 느끼게 된 것입니다.</p><p>내가 나를 성장시켜야 한다고 생각하게 되었을 때 어떤 것을 시도해볼지 고민을 하였습니다. 그렇게 개발자 커뮤니티를 기웃거리다가 우연히 OKKY에서 주최하는 컨퍼런스를 통해 TDD를 접하게 되었습니다. 평소 객체지향 설계와 디자인 패턴에 관심이 많았는데 컨퍼런스 영상을 보는 순간 더 나은 설계를 위해서 TDD에 도전해보자는 생각을 하였습니다. 이제 TDD에 어떻게 도전하면 좋을 지 고민하던 중 우연히 TDD 스터디원을 모집하는 글을 보게 되었고 지원한 뒤 참여하게 되었습니다.</p><blockquote><p><a href="https://www.youtube.com/playlist?list=PLhSAACiXcoKK318PRta9AmxgdkPB9q9Sm" rel="external nofollow noopener noreferrer" target="_blank">OKKYCON: 2018 (The Real <strong>TDD</strong>) 발표 영상</a></p></blockquote><p>TDD 스터디를 통해 정말 많은 것을 배우고 나누고 소통할 수 있었습니다. 스터디를 통해 코드리뷰를 처음 접해보았으며 객체지향의 개념을 이론에서 꺼내와 현실에서 이야기도 처음 해보았습니다. 그뿐만 아니라 테스트 코드를 어떻게 하면 더 잘 작성할 수 있을까? TDD를 어떻게 실천할 수 있을까? 객체지향 설계는 어떻게 해야 하는 것일까? 등 많은 고민과 생각을 하게 된 계기가 되었습니다. 좋은 사람들이 있었기에 좋은 생각과 고민을 많이 할 수 있었고 많이 배웠습니다. 정말 값진 경험이었습니다.</p><h2 id="새로운-직장-2019-06"><a href="#새로운-직장-2019-06" class="headerlink" title="새로운 직장 (2019.06)"></a>새로운 직장 (2019.06)</h2><p>TDD 스터디를 참여하고 개인적으로 공부도 하면서 개발을 주 업무로 할 수 있는 회사로 가고 싶은 마음이 컸습니다. 첫 회사는 개발의 비중이 극히 작았고 대부분은 관리 업무를 하며 시간을 보냈기 때문에 더욱 개발에 대한 갈증이 컸던 것 같습니다. 그래서 이직을 결심하게 되었습니다. 그리고 첫 취업과 달리 회사를 선택하는 기준을 하나 더 정하였습니다. 제가 하는 업무가 단순히 이해관계 속에서 일어나고 큰 의미 없이 사라지는 것이 아닌 누군가에게 가치가 되었으면 좋겠다는 생각이 들었습니다. 그래서 회사가 사회에 가치를 전달하고 있는지를 기준으로 잡았습니다. 회사가 사회에 진실로 가치를 전하고 있다면 저의 업무가 누군가에게 가치 있게 다가가고 있다는 것이니까요. 이후 여러 절차를 거쳐 현재의 회사로 이직을 하게 되었습니다.</p><p>현재의 회사에서 많은 영감과 자극을 받고 있습니다. 특히 개개인이 업무의 책임자로서 자율적으로 의사결정 하는 전문가의 모습은 굉장히 인상 깊었으며 본받고 있습니다. 또한 매주 주간회의 시간에 한 명씩 돌아가면서 공유하고 싶은 내용을 주제로 발표하는 시간을 갖는 등 성장에 있어서도 큰 도움이 되고 있습니다. 벌써 저는 2가지 주제를 발표하였는데요. ‘TDD’와 ‘SOLID’를 주제로 발표하였습니다. 기회가 되면 블로그에도 정리하는 시간을 가져보도록 하겠습니다.</p><h2 id="NEXTSTEP-TDD-Refactoring-Clean-Code-5기-2019-06-2019-07"><a href="#NEXTSTEP-TDD-Refactoring-Clean-Code-5기-2019-06-2019-07" class="headerlink" title="NEXTSTEP TDD, Refactoring, Clean Code 5기 (2019.06 - 2019.07)"></a>NEXTSTEP TDD, Refactoring, Clean Code 5기 (2019.06 - 2019.07)</h2><p>TDD 스터디에 참여하면서 객체지향 설계와 클린코드에 더욱 관심을 갖게 되었습니다. 어떻게 더 성장할 수 있을까 고민을 하던 중 스터디 원 중 한 분이 NEXTSTEP에서 진행하는 TDD 강의를 소개해주었고 수강하게 되었습니다. 기존 TDD 스터디보다 더욱 엄격하게 코드리뷰를 받으며 한층 더 성장할 수 있었습니다. 그뿐만 아니라 앞으로 어떤 개발자의 모습으로 살아가야 할지 마음속 깊이 생각하게 된 강의였습니다.</p><h2 id="오픈소스-세계로의-발돋움"><a href="#오픈소스-세계로의-발돋움" class="headerlink" title="오픈소스 세계로의 발돋움"></a>오픈소스 세계로의 발돋움</h2><p>오픈소스 프로젝트에 참여하고 싶었지만, 그 방법을 경험하지 못하여 막막하던 때에 마침 OSS개발자포럼에서 컨퍼런스(2019 오픈소스개발자이야기)를 연다는 소식을 듣고 참가하였습니다. 본업을 하면서 오픈소스에 기여하는 개발자들, 본업이 오픈소스 프로젝트인 개발자분들의 발표를 들으며 언젠가 오픈소스에 기여하겠다는 마음을 먹었습니다. 그리고 현재까지 회사생활을 하며 작은 기여 2번을 하였습니다. mybatis 프로젝트에 번역 이슈 등록과 웹 에디터 오픈소스인 ‘summernote’ 플러그인 중 하나에 한국어 번역 기여를 하였습니다. 이슈 등록과 번역이라는 자그마한 기여지만, 오픈소스 세계로 첫발을 내디뎠다는 사실 자체가 너무 행복했습니다. 특히, mybatis에 번역 이슈를 등록했을 때는 설레는 마음에 잠을 설치기도 하였습니다. 또한 오픈소스로 전 세계의 개발자들과 소통할 수 있다는 것을 현실로 느끼게 되었습니다. 2019년의 작은 발돋움을 계기로 2020년에는 제대로 된 코드로 기여를 해보고 싶습니다.</p><blockquote><ol><li><a href="https://github.com/mybatis/mybatis-3/issues/1602" rel="external nofollow noopener noreferrer" target="_blank">The contents of the ‘caption’ tag are garbled In the Korean translation document</a></li><li><a href="https://github.com/DiemenDesign/summernote-image-attributes/pull/57" rel="external nofollow noopener noreferrer" target="_blank">Korean translation</a></li></ol></blockquote><h2 id="운동-2019-07"><a href="#운동-2019-07" class="headerlink" title="운동 (2019.07 -)"></a>운동 (2019.07 -)</h2><p>회사생활, 스터디, 강의, 개인 학습 등의 일정을 소화하다 보니 체력적인 한계를 느끼게 되었습니다. 이대로는 안 되겠다 싶어 7월에 헬스장 PT를 끊었습니다. 이전까지는 운동과 거리가 먼 삶을 살아오다 보니 혼자서 운동하는 방법 자체를 몰라 무턱대고 퇴근길에 보이는 헬스장에 들어가 PT 상담을 받고 결제까지 하였습니다. 사실 결제 직전 금액이 너무 커서 망설였지만 눈 딱 감고 질렀습니다. 이때의 결정은 정말로 잘한 결정인 것 같습니다. 무언가를 얻기 위해 고통이 수반된다는 것을 운동을 통해 절실히 느끼고 있습니다. 이런 부분에서 운동을 통해 많은 영감을 받고 있습니다. 또한 체력이 많이 증가한 것이 느껴지며 이전보다 활기찬 하루를 보내고 있습니다.</p><h2 id="독서"><a href="#독서" class="headerlink" title="독서"></a>독서</h2><p>2020년에는 2019년에 아쉬웠던 부분들을 보완하여 더욱더 알찬 한 해를 보내도록 할 것입니다. 그중 하나가 독후감입니다. 2019년에 좋은 책들을 읽었지만, 기록으로 남기지 못해 아쉬움이 많이 남았습니다. 그래서 2020년에는 책을 읽고 블로그에 독후감을 남기려고 합니다. 이를 위해서 Github에 Bookshelf라는 저장소를 만들어 독서 목록을 관리하고 있습니다.</p><blockquote><p><a href="https://github.com/sogoagain/bookshelf" rel="external nofollow noopener noreferrer" target="_blank">Bookshelf 저장소</a></p></blockquote><h2 id="꾸준한-실천"><a href="#꾸준한-실천" class="headerlink" title="꾸준한 실천"></a>꾸준한 실천</h2><p>2019년 새해 목표로 ‘매일 5분 학습하기’가 있었습니다. 5분이라고는 했지만, 이는 지속을 위한 상징적인 시간이었습니다. 5분을 위해 책상에 앉으면 5분을 넘겨 30분, 한 시간 공부하던 날이 많았습니다. 이전까지 새해 목표는 작심삼일이었던 경우가 많았습니다. 그런데, 올해는 달랐습니다. 돌이켜보면 2018년 첫 취업 후 1년이 지난 시점에서 느낀 위기감이 저를 움직이게 하였고 꾸준한 실천이라는 목표를 완수할 수 있지 않았나 싶습니다. 아래는 저의 Github 잔디밭입니다. 중간에 개인적인 사정과 저장소 삭제 등의 이유로 11번 잔디를 심지 못하였습니다. 11일을 제외한 354일은 꾸준히 학습을 실천하였습니다.</p><p><img src="/images/2019-%ED%9A%8C%EA%B3%A0/2019-jandi.png" alt="2019-jandi"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;조금-늦어진-회고&quot;&gt;&lt;a href=&quot;#조금-늦어진-회고&quot; class=&quot;headerlink&quot; title=&quot;조금 늦어진 회고&quot;&gt;&lt;/a&gt;조금 늦어진 회고&lt;/h2&gt;&lt;p&gt;2020년 1월 11일인 지금에서야 블로그에 회고 글을 작성하게 되었습니다.
      
    
    </summary>
    
      <category term="생각" scheme="https://sogoagain.github.io/categories/%EC%83%9D%EA%B0%81/"/>
    
    
      <category term="회고" scheme="https://sogoagain.github.io/tags/%ED%9A%8C%EA%B3%A0/"/>
    
      <category term="생각" scheme="https://sogoagain.github.io/tags/%EC%83%9D%EA%B0%81/"/>
    
  </entry>
  
  <entry>
    <title>[실수노트] 캐싱된 메서드는 변경 불가능한(Immutable) 객체를 반환토록 하자</title>
    <link href="https://sogoagain.github.io/2019/12/06/%EC%8B%A4%EC%88%98%EB%85%B8%ED%8A%B8-%EC%BA%90%EC%8B%B1%EB%90%9C-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EB%B3%80%EA%B2%BD-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%9C-Immutable-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%B0%98%ED%99%98%ED%86%A0%EB%A1%9D-%ED%95%98%EC%9E%90/"/>
    <id>https://sogoagain.github.io/2019/12/06/실수노트-캐싱된-메서드는-변경-불가능한-Immutable-객체를-반환토록-하자/</id>
    <published>2019-12-05T15:38:23.000Z</published>
    <updated>2019-12-05T15:57:03.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="상황"><a href="#상황" class="headerlink" title="상황"></a>상황</h2><p>호출될 때마다 같은 값을 반환할 것으로 기대되는 Service의 한 메서드를 캐싱 처리 하였다. 캐싱 처리한 메서드는 카테고리 데이터를 DB에서 가져와 리스트 형태로 반환하는 메서드였다. 카테고리 데이터가 자주 바뀌지 않아 긴시간 동안 같은 결과값을 반환하는데 매번 DB를 조회하는 것은 리소스를 낭비하는 것이기에 캐싱 처리를 하였다.</p><p>그런데, 배포를 하고보니 데이터 출력이 이상했다. 특정 화면에서 카테고리를 조회할 때 새로운 카테고리가 생기고 조회를 계속 할수록 새롭게 생긴 카테고리는 중복되어 출력되었다. 여기서 끝이 아니라, 중복되어 생긴 카테고리는 오류가 발생하는 화면에서만 보이는 것이 아니라 카테고리를 조회하는 곳이면 어디서든 출력되고 있었다.</p><p>예를들면 [‘태블릿’, ‘휴대전화’] 2개 카테고리만 출력되어야 하는데 [‘태블릿, ‘휴대전화’, ‘이벤트’, ‘이벤트’, ‘이벤트’, ‘이벤트’]와 같이 출력되는 오류가 발생하였다.</p><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>캐싱된 메서드는 Service단 메서드로써 아래와 같이 Repository에서 모든 데이터를 가져와 List 형식으로 반환한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(<span class="string">"categories"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Category&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> categoryRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>대부분의 경우 Controller단에서는 위 getAll() 메서드로 반환된 List를 변경없이 사용하여 Client단으로 내려주었는데 이 경우에는 문제가 발생하지 않았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">public</span> Header&lt;List&lt;Category&gt;&gt; readAll() &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Category&gt; categories = categoryService.getAll();</span><br><span class="line">    <span class="keyword">return</span> Header.OK(categories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>호출될 때 마다 특정 카테고리가 중복으로 생기는 페이지에서 호출하는 api를 따라가보니 아래와 같이 Controller가 작성되어 있었다. getAll()메서드로 반환된 List에 데이터를 추가하여 Client단으로 내려주고 있었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">public</span> Header&lt;List&lt;Category&gt;&gt; readAllWithEventCategory() &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Category&gt; categories = categoryService.getAll();</span><br><span class="line">    <span class="keyword">final</span> Category eventCategory = Category.createEventCategory();</span><br><span class="line">    categories.add(eventCategory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Header.OK(categories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문제의 원인은 이곳에 있었다. 이전까지는 CategoryService의 getAll()을 호출하게 되면 그때 마다 db에 접근하여 새롭게 List를 만들어 반환하였다. 그렇기 때문에 List에 담긴 데이터 정보는 동일하겠지만 각 호출시 반환받은 List는 서로 다른 객체였다. 그러나 CategoryService의 getAll()을 캐싱처리 하면서 한 번 호출된 결과를 메모리 상에 가지고 있다가 다음번 호출 때 메모리 상에 저장해둔 List 객체를 반환하게 되었다. 즉 캐싱처리를 하면서 CategoryService의 getAll()을 호출하는 곳이면 메모리 상에 같은 주소를 가리키는 같은 List 객체를 반환받게 되었다.</p><p>이를 확인하고자 아래의 간단한 테스트 코드를 작성하였다. 메서드를 캐싱처리 하였을 때 아래의 테스트 코드는 정상적으로 통과했지만 캐싱처리를 하지 않았을 때는 통과하지 못했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CategoryService categoryService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CategoryRepository categoryRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"캐싱된 getAll()로 반환받은 리스트 객체는 동일하다."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAll_WithCaching_isSame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Category&gt; firstList = categoryService.getAll();</span><br><span class="line">        <span class="keyword">final</span> List&lt;Category&gt; secondList = categoryService.getAll();</span><br><span class="line"></span><br><span class="line">        assertThat(firstList).isEqualTo(secondList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 CategoryService의 getAll() 메서드를 호출하는 곳에서는 동일한 List 객체를 반환받다 보니 어느 한곳에서라도 반환받은 List에 데이터를 추가하거나 삭제 혹은 변경해버리면 그 여파가 getAll() 메서드를 호출하는 모든 곳으로 전파되버린다. 이 또한 아래의 테스트 코드로 검증할 수 있다. getAll() 메서드를 캐싱하지 않으면 아래의 테스트 케이스는 실패한다. 즉, getAll()을 호출할 때마다 새로운 리스트가 만들어져 반환되기 때문에 firstList와 secondList의 데이터 갯수가 다르다. 그러나 getAll() 메서드를 캐싱처리하면 테스트 케이스는 통과한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"캐싱된 getAll()로 반환받은 리스트에 데이터를 추가하면 이후 호출된 결과에도 데이터가 추가된 리스트가 반환된다."</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAll_AddingCategoryToList_AddedListIsReturned</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Category tempCategory = Category.builder().id(-<span class="number">1L</span>).type(<span class="string">"TEMP"</span>).title(<span class="string">"임시"</span>).build();</span><br><span class="line">    <span class="keyword">final</span> List&lt;Category&gt; firstList = categoryService.getAll();</span><br><span class="line">    firstList.add(tempCategory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;Category&gt; secondList = categoryService.getAll();</span><br><span class="line"></span><br><span class="line">    assertThat(firstList.size()).isEqualTo(secondList.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉, 내가 겪은 상황의 경우 Controller의 readAllWithEventCategory() 요청이 호출될 때 마다 ‘eventCategory’라는 임시 객체를 메모리 상에 캐싱된 리스트 객체에 추가해버리니 호출 횟수만큼 List에는 ‘eventCategory’가 중복되어 추가되었고 CategoryService의 getAll()를 호출하는 모든 곳에서 문제가 발생하였다.</p><h2 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h2><p>캐싱된 메서드는 변경 불가능한(Immutable) 객체를 반환하도록 정의한다. List의 경우에 아래 코드와 같이 Collections.unmodifiableList 메서드를 통해 데이터 추가/삭제/변경이 제한되는 List로 만들어 반환토록 한다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(<span class="string">"categories"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Category&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(categoryRepository.findAll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UnmodifiableCollection의 경우 add, remove 메서드와 같이 저장된 데이터를 변경하고자 하면 ‘UnsupportedOperationException’를 발생시키기 때문에 이를 사용하는 곳에선 데이터 변경이 불가능하다. 따라서 위에서 오류를 발생시킨 Controller의 경우에 코드를 아래와 같이 수정해야한다. categoryService.getAll()로 반환받은 리스트를 바탕으로 categoriesWithEvent 리스트를 새롭게 생성한다. 그리고 List의 데이터 추가 삭제는 새롭게 생성한 categoriesWithEvent에서 이루어 지도록 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">public</span> Header&lt;List&lt;Category&gt;&gt; readAllWithEventCategory() &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Category&gt; categories = categoryService.getAll();</span><br><span class="line">    <span class="keyword">final</span> Category eventCategory = Category.createEventCategory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;Category&gt; categoriesWithEvent = <span class="keyword">new</span> ArrayList&lt;&gt;(categories);</span><br><span class="line">    categoriesWithEvent.add(eventCategory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Header.OK(categories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="실천방안"><a href="#실천방안" class="headerlink" title="실천방안"></a>실천방안</h2><p>메서드 캐싱은 항상 같은 결과값을 반환하는 것으로 기대되는 곳에서만 사용하도록 하며 캐싱된 메서드에서는 변경 불가능한 객체(Immutable)를 반환하도록 정의한다. 또한 캐싱된 메서드의 반환값에 대해서 변경이 필요하다면 꼭 필요한 변경인지, 변경을 우회할 수 있는 더 좋은 방법은 없는지 고민해본다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;상황&quot;&gt;&lt;a href=&quot;#상황&quot; class=&quot;headerlink&quot; title=&quot;상황&quot;&gt;&lt;/a&gt;상황&lt;/h2&gt;&lt;p&gt;호출될 때마다 같은 값을 반환할 것으로 기대되는 Service의 한 메서드를 캐싱 처리 하였다. 캐싱 처리한 메서드는 카테고리
      
    
    </summary>
    
      <category term="실수노트" scheme="https://sogoagain.github.io/categories/%EC%8B%A4%EC%88%98%EB%85%B8%ED%8A%B8/"/>
    
    
      <category term="Spring" scheme="https://sogoagain.github.io/tags/Spring/"/>
    
      <category term="실수노트" scheme="https://sogoagain.github.io/tags/%EC%8B%A4%EC%88%98%EB%85%B8%ED%8A%B8/"/>
    
      <category term="Immutable" scheme="https://sogoagain.github.io/tags/Immutable/"/>
    
      <category term="Cache" scheme="https://sogoagain.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>의식적인 연습에 기반한 나의 앞으로의 학습</title>
    <link href="https://sogoagain.github.io/2019/10/22/%EC%9D%98%EC%8B%9D%EC%A0%81%EC%9D%B8-%EC%97%B0%EC%8A%B5%EC%97%90-%EA%B8%B0%EB%B0%98%ED%95%9C-%EB%82%98%EC%9D%98-%EC%95%9E%EC%9C%BC%EB%A1%9C%EC%9D%98-%ED%95%99%EC%8A%B5/"/>
    <id>https://sogoagain.github.io/2019/10/22/의식적인-연습에-기반한-나의-앞으로의-학습/</id>
    <published>2019-10-21T15:43:11.000Z</published>
    <updated>2020-01-12T15:36:11.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="무언가-문제가-생긴-나의-학습-방법"><a href="#무언가-문제가-생긴-나의-학습-방법" class="headerlink" title="무언가 문제가 생긴 나의 학습 방법"></a>무언가 문제가 생긴 나의 학습 방법</h2><h3 id="2019년-목표-매일-5분-학습하기"><a href="#2019년-목표-매일-5분-학습하기" class="headerlink" title="2019년 목표: 매일 5분 학습하기"></a>2019년 목표: 매일 5분 학습하기</h3><p>학생 신분을 벗어나 사회인으로 하루하루 살아가던 어느날, 뒤 돌아보니 나의 상태는 그대로인 것 같은데 시간은 훌쩍 지나가 버린 것 같은 느낌이 들었다. 이에 대해 위기감이 느껴진 나는 2019년 1월 1일, 새해를 맞이하여 ‘매일 학습하기’를 2019년의 목표로 삼았다. 정확히는 ‘매일 <strong>5분</strong> 이상 학습하기’ 였다. 목표로한 학습 시간이 5분으로 매우 짧은데, 이렇게 짧은 시간을 목표로 설정한 이유는 ‘학습의 양’보다 <strong>‘학습의 지속’</strong>에 초점을 맞췄기 때문이다. 뿐만 아니라 5분 학습을 위해 시간을 투자하면 자연스레 30분, 1시간, 2시간 학습을 이어나갈 것이라 생각하였다.</p><h3 id="정말로-5분씩만…"><a href="#정말로-5분씩만…" class="headerlink" title="정말로 5분씩만…"></a>정말로 5분씩만…</h3><p>5분만이라도 학습을 하기 위해 의자에 앉으면 자연스레 학습 시간이 길어질 것이란 생각은 나의 큰 착각이었다. 최근 나의 학습 내역들을 보면 정말로 5분만 학습을 하고 있었다. 물론, 5분만 해도 어제보다 나은 내가 되겠지만 목표치에는 한없이 모자란 학습량이다. 무언가 문제가 생긴 것 같았다. 이대로는 내가 되고 싶은 미래 내 모습에 발 끝도 못 따라갈 것만 같았다.</p><h3 id="해결책을-찾아야-해"><a href="#해결책을-찾아야-해" class="headerlink" title="해결책을 찾아야 해"></a>해결책을 찾아야 해</h3><p>나는 단지 책상에 앉아서 학습을 해야한다는 목표만을 세웠을 뿐 어떻게 학습을 해야할 지에 대해서는 큰 고민을 하지 않았다. 그래서 이런 문제가 발생한 것 같았다. 5분 학습 사태를 해결하기 위해 어떻게 해야하는지 고민을 하다가 존경하는 개발자 중 한분인 ‘박재성 교수님’께서 추천한 도서인 <strong>‘1만 시간의 재발견: 노력은 왜 우리를 배신하는가?’</strong>가 떠올랐다. 박재성 교수님의 TDD 발표, 유튜브 스프링 부트 강의를 보면 ‘의식적인 연습’에 대한 이야기를 자주 하신다. 때문에 ‘의식적인 연습’이 컴포트 존을 벗어나려는 노력 인 것을 어렴풋이 알고 있었다.</p><blockquote><p>나는 2019년 초에 박재성님의 okky 세미나 영상으로 TDD를 처음 접하였다. 영상에 감명을 받은 나는 TDD 스터디에 들어갔고, 스터디원들의 도움으로 크게 성장하였다. 함께 했던 스터디원들에게 감사한 마음이 많이 든다. 뿐만 아니라 박재성님의 유튜브 강의로 스프링 부트를 처음 접하였고 .NET을 운영하던 내가 지금은 스프링 기반으로 개발을 하고 있다.</p><p>정말 인생에 많은 영향과 영감을 받았고 또 받고 있다. 또한 NEXTSTEP 오프라인 TDD를 수강 하였다.  (아직 완료 못한 마지막 과제가 남아 있는데 빠른 시일 내에 완료해야겠다.)</p></blockquote><p>현재 5분이라는 컴포트 존에 사로잡힌 내게 필요한 것이 ‘의식적인 연습’이라는 생각이 들었고 곧장 책을 읽게 되었다. 이 책이 현재 상황을 해결할 수 있는 실마리를 제공해 줄 것만 같았기 때문이다. 그리고 그 예상은 정확히 맞아 떨어졌다.</p><h2 id="1만-시간의-재발견-노력은-왜-우리를-배신하는가"><a href="#1만-시간의-재발견-노력은-왜-우리를-배신하는가" class="headerlink" title="1만 시간의 재발견: 노력은 왜 우리를 배신하는가?"></a>1만 시간의 재발견: 노력은 왜 우리를 배신하는가?</h2><p>책 내용을 요약하며 앞으로의 나의 학습 방향을 예시로 작성 해보고자 한다. 글을 쓰는 시점에서는 책을 읽은지 얼마 되지 않아 책 내용들을 인지하고 있지만 시간이 흐른 뒤 이 내용들을 잊고 살아갈 확률이 높은 미래의 나를 위해서라도 요약을 해야할 것 같다.</p><h3 id="타고난-재능은-없고-노력-만이-답이다"><a href="#타고난-재능은-없고-노력-만이-답이다" class="headerlink" title="타고난 재능은 없고 노력 만이 답이다."></a>타고난 재능은 없고 노력 만이 답이다.</h3><p>이 책의 저자는 30년 이상 특정 분야(운동선수, 연주자, 체스 기사 등)의 전문가들을 연구 하였는데 ‘선천적인 재능’이 그들을 세계적인 전문가로 만든 것이 아님을 밝혀냈다. 예를 들면 체스 기사가 되기 위해서는 높은 IQ를 가진 사람이 유리할 것이라 일반적으로 생각하는데 이러한 생각이 틀렸다는 것이다. 실제 책에서 인용한 체스 연구를 보면 높은 IQ를 가진 사람이 체스를 배우는 초기에는 이점을 가지고 있을지 모르지만 시간이 지날수록 IQ 보다는 노력의 양과 질이 더 중요했다고 한다.</p><p>또한, 사람은 적응의 동물이다. 의식적인 훈련, 의식적인 연습을 통해 원하는 방향으로 뇌를 변화시키는 것이 가능하다고 한다. 성인의 뇌는 더이상 세포들이 분열하지 않기 때문에 변화하지 않다고 생각할 수 있다. 그러나, 성인의 뇌는 신경조직망을 다양한 방법으로 재배열하여 변화에 적응해 나간다.</p><h3 id="어떻게-노력해야-하는가"><a href="#어떻게-노력해야-하는가" class="headerlink" title="어떻게 노력해야 하는가?"></a>어떻게 노력해야 하는가?</h3><p>그럼, 무조건 노력만 해서 전문가가 될 수 있을까? 이 책의 제목처럼 어떤 분야에 1만 시간을 투자하면 그 분야의 뛰어난 전문가가 될 수 있을까? 즉 <strong>‘단순한 연습(naive practice)’</strong>로 전문가가 될 수 있을까? 그렇지 않다. 노력에도 전략이 필요하며 <strong>전략적인 노력을 꾸준히</strong> 해야 뛰어난 전문가가 될 수 있다고 이야기 한다. 이 책에서는 그 방법으로 <strong>‘의식적인 연습’</strong> 을 제안한다.</p><h3 id="목적의식-있는-연습-Purposeful-Practice"><a href="#목적의식-있는-연습-Purposeful-Practice" class="headerlink" title="목적의식 있는 연습 (Purposeful Practice)"></a>목적의식 있는 연습 (Purposeful Practice)</h3><p>‘의식적인 연습’을 설명하기 전에 ‘목적의식 있는 연습’을 먼저 알아보자. ‘목적의식 있는 연습’은 ‘의식적인 연습’으로 가기 전 단계다.<br>‘목적의식 있는 연습’ 특징은 다음과 같다. 예시로 든 사례들은 코틀린을 학습하기 위해 내가 생각하고 있는 목적의식 있는 연습 계획이다.</p><ol><li>명확하고 구체적인 목표를 가지고 있다. <blockquote><p>전반적인 목표(수행능력 향상) + 구체적인 목표 + 계획</p><p>예) 코틀린에 익숙해지기 위해 코틀린으로 간단한 계산기 console application을 10월 30일 까지 구현한다.</p></blockquote></li><li>집중이 필요하다.<blockquote><p>동기부여를 유지할 방법도 파악해야 한다.</p><p>예) 코틀린을 주제로 회사에서 발표를 한다. 기존에 자바로 작성했던 TDD 연습 프로젝트를 코틀린으로 구현해보며 자바와 코틀린의 차이점을 분석해 보거나 코틀린에서 제공하는 문법들을 활용하여 더 깔끔한 코드를 작성해본다. 코틀린으로 스프링 부트 환경의 application을 구현하는 것이 최종 목표다.</p></blockquote></li><li>피드백이 필요하다.<blockquote><p>정확히 어디가 어떻게 부족한지 알게 해주는 피드백이 필요하다. 또한 피드백은 진척 정도를 추적 관찰할 수단이 된다.</p><p>예) 피드백은 사람에게 받으면 좋으나 현재 환경에서는 어려움이 있기에 도서를 통해 best practice와 나의 소스코드를 비교해본다. (이펙티브 자바), 코틀린으로 작성된 코드를 리뷰하는 스터디에 참여한다.</p></blockquote></li><li>컴포트 존에서 벗어나야 한다.<blockquote><p>이전에는 하지 못했던 것을 시도하는 것이다. 컴포트 존에서 너무 많이 벗어나면 안된다. 스위트 스폿(sweet spot)에서 가장 빠르게 성장한다.</p><p>예) 기존의 자바처럼 코드를 작성하는 것이 아닌 코틀린 reference를 참고하며 새로운 문법들을 계속해서 시도해 나간다. console application으로 연습이 되었으면 스프링 환경에서 코틀린으로 토이 프로젝트를 진행한다.</p></blockquote></li></ol><h3 id="의식적인-연습-Deliberate-Practice"><a href="#의식적인-연습-Deliberate-Practice" class="headerlink" title="의식적인 연습 (Deliberate Practice)"></a>의식적인 연습 (Deliberate Practice)</h3><p>‘의식적인 연습’은 최종적으로 우리가 따라야 하는 연습의 방법이다. ‘목적의식 있는 연습’은 개인의 잠재력에 도달하는 것에 방향이 맞춰져 있는데 <strong>‘의식적인 연습’은 잠재력을 개발하고 만들어 내어 이전에는 불가능 했던 것을 가능</strong>하도록 하는데 목적이 있다. 그렇다면 ‘의식적인 연습’이란 무엇일까? ‘의식적인 연습’을 이해하는 데 가장 중요한 것은 <strong>‘심적 표상(mental representations)’</strong>이다. 의식적인 연습의 최종적인 목표는 심적 표상을 개발하는 것이기 때문이다.</p><h3 id="심적-표상"><a href="#심적-표상" class="headerlink" title="심적 표상"></a>심적 표상</h3><p>심적 표상이란 어떤 물건, 행위 등에 대해 마음속에 떠오르는 것이다. 간단한 예로 ‘강아지’라는 단어를 들었을 때 개개인 마다 떠오르는 생각이 다를 것이다. 어떤 사람은 강아지에 대해 굉장히 구체적인 묘사를 떠올릴 수도 있고 어떤 사람은 강아지에게서 느껴지는 귀여운 감정이 떠오를 수 있다.</p><p>심적 표상은 행위도 대상이 될 수 있다. 책에서는 체스를 예로 드는데, 체스 마스터들은 체스판을 보았을 때 체스말 하나하나를 분석하는 것이 아니라 체스판 전체를 하나의 패턴을 본다고 한다. 이렇게 패턴으로 인식하면 어떻게 수를 두어야 유리한지 바로 떠올릴 수 있다고 한다.</p><p>내가 이해한 만큼 심적 표상을 설명해 보겠다. 특정 요구사항을 구현해야하는 상황에서 개발자마다 떠오르는 생각이 다를 것이다. 예를 들면 요구사항에 맞는 도메인 객체는 어떤 것들을 추출하고 이것들을 어떻게 협력하게 할 것 인지, 어떤 컨벤션을 지키는 코드가 깔끔한 코드인지, 어떤 디자인 패턴을 쓸 것인지 등의 생각들이 각자가 갖고 있는 심적 표상이다.</p><p>심적 표상이 중요한 이유는 단기기억으로 정보를 처리하는 것보다 훨씬 신속하고 효울적으로 반응하기 때문이다. 예를 들어 레거시 코드를 리팩토링 한다고 가정해보자. 리팩토링에 대한 심적 표상의 양과 질이 떨어지면 우리는 우리가 가지고 있는 지식(자료, 도서) 등을 이용하여 리팩토링을 진행해야 한다. 리팩토링 책을 보며 비슷한 사례를 찾고 이를 적용해보고 좋지 않은 방법이면 다시 원복하고 또 새로운 사례를 찾는 행위를 반복해나가야 한다. 하지만, 리팩토링에 대한 심적 표상이 굉장히 구체적인 전문가는 레거시 코드를 보는 순간 코드 전체를 패턴으로 인지하여 개선해야할 부분을 빠르고 정확하게 찾으며 깔끔하게 리팩토링을 진행한다.</p><p>즉, 전문가의 눈에는 우리가 보았을 때 아무런 규칙이 없는 것처럼 보이거나 의미없는 나열들로 보이는 것을 의미있는 하나의 패턴으로 인식하는 능력이 있다. 이 능력은 고도로 개발된 심적 표상에서 나온다.</p><h3 id="심적-표상을-통한-피드백"><a href="#심적-표상을-통한-피드백" class="headerlink" title="심적 표상을 통한 피드백"></a>심적 표상을 통한 피드백</h3><p>앞서 살펴본 ‘목적의식 있는 연습’의 특징에서 ‘피드백’이 필요하다는 특징이 있다. 피드백이 있어야 자신의 잘못된 것을 바로 잡고 컴포트 존을 벗어나 더 나은 방향으로 나아갈 수 있기 때문이다. 피드백은 외부에서만 받을 수 있다고 생각할 수 있다. 하지만, 심적 표상이 고도로 발달된 전문가들은 자신들의 심적 표상을 이용해 스스로에게 피드백을 제공한다.</p><p>소프트웨어 개발 행위로 내가 이해한 만큼 예를 들어 보겠다. 심적 표상이 매우 섬세하고 상세하게 발달된 전문가는 소프트웨어 개발 과정 동안 자신의 심적 표상으로 자기 스스로에게 피드백을 제공한다. 코드를 작성할 때 어떤 규칙들을 지켜야 하는지, 객체지향적인 코드가 어떤 모습인지, 현재 개발중인 단계가 전체 개발 프로세스 중 어디에 위치해 있는지, 지금 개발중인 단계보다 더 나아지려면 어떻게 해야하는 지 등 자신이 생각하는 이상적인 프로그램의 모습, 개발 과정이 패턴 형식으로 자연스레 떠오르는 것이다. 이를 통해 자신의 개발과정에서 이상적인 패턴과 멀어지면 수정하고 이상적인 패턴에 도달하기 위해 노력한다.</p><p>즉, 심적 표상은 자신에게 피드백을 제공해준 다는 점에서 ‘의식적인 연습’에서 필수적인 요소다. 앞에서 ‘의식적인 연습’의 최종적인 목표가 심적 표상을 개발하는 것이라고 하였는데 지금와서 심적 표상이 ‘의식적인 연습’에 필수적인 요소라니… 무언가 말이 안맞는 것 같지만 이게 사실이다. 심적 표상과 ‘의식적인 연습’은 선순환 관계에 있고 이런 선순환 관계 속에서 개인은 계속해서 발전하는 것이다.</p><h3 id="의식적인-연습-7가지-원칙"><a href="#의식적인-연습-7가지-원칙" class="headerlink" title="의식적인 연습 7가지 원칙"></a>의식적인 연습 7가지 원칙</h3><p>의식적인 연습에 조금 더 다가가기 위해 7가지 원칙을 살펴보며 나의 학습 방향에 대한 예시를 함께 들도록 하겠다.</p><ol><li>효과적인 훈련 기법이 존재하는 기술을 연마하는 방법이다.</li><li>컴포트 존을 벗어난 지점에서 진행되며 현재 능력을 살짝 넘어서는 작업을 지속적으로 시도해야 한다.</li><li>명확하고 구체적인 목표를 가지고 진행된다.</li><li>신중하고 계획적이다.</li><li>피드백과 피드백에 따른 행동 변경을 수반한다.</li><li>효과적인 심적 표상을 만들어내는 한편으로 거기에 의존한다.</li><li>기존에 습득한 기술의 특정 부분을 집중적으로 개선함으로써 이를 한층 발전 시키거나 수정하는 과정이 수반된다.</li></ol><p>위 원칙들은 엄격한 의미에서의 ‘의식적인 연습’에서 발견되는 원칙이다. 엄격한 의미의 ‘의식적인 연습’에서는 이미 고도로 발달된 훈련 기법이 존재하고 이를 지도해주는 교사나 코치가 필요하는 등 실제 자신이 몸담고 있는 분야에 적용하기 힘든 내용들이 있다. 그러나, 엄격한 의미에서의 ‘의식적인 연습’이 불가능한 영역이라고 해도 위 원칙들을 일종의 안내서로 활용하여 ‘의식적인 연습’을 해나갈 수 있다.</p><h3 id="나의-‘의식적인-연습’을-위한-준비"><a href="#나의-‘의식적인-연습’을-위한-준비" class="headerlink" title="나의 ‘의식적인 연습’을 위한 준비"></a>나의 ‘의식적인 연습’을 위한 준비</h3><ol><li><p>지침서가 될 레퍼런스 찾기</p><blockquote><p>예를 들면 학습 하고자 하는 내용에 대한 질 좋은 포스팅을 제공하는 블로그를 찾고 해당 블로그에서 소개하는 기술들을 실제 프로젝트에 적용 시켜볼 것이다. 즉, 블로그가 나의 지침서이자 피드백 요소가 되는 것이다.</p><p>뿐만 오픈소스, 공식 문서 등을 지침서로 삼고 지침서에서 제공하는 내용들이 심적 표상으로 다가올 수 있도록 연습할 계획이다.</p></blockquote></li></ol><ol start="2"><li><p>연습 시간 할애하기</p><blockquote><p>앞에서 학습할 대상에 대한 지침서를 찾았다면 지침서 중 일부를 습득하는 것을 구체적인 목표로 잡고 일정 시간 몰입하여 연습할 계획이다. 심적 표상이 어느정도 구체화 될 때 까지 연습하며 구체화가 되었다면 발표, 블로그 포스팅 등을 통해 내가 이해한 만큼 설명을 해볼 것이다. 설명을 하던 중 막히는 부분이 있으면 이를 피드백으로 삼고 심적 표상을 더욱 구체화 하도록 하겠다.</p><p>오후에 시간을 할애하면 방해요소가 많기 때문에 출근 전인 오전에 최소 한시간 연습하는 시간을 갖도록 할 것이다.</p></blockquote></li></ol><ol start="3"><li><p>피드백 받을 수 있는 환경에 참여하기</p><blockquote><p>회사, 스터디, 강의 등 피드백을 받을 수 있는 기회를 최대한 찾고 피드백을 받도록 노력할 것이다.</p></blockquote></li></ol><ol start="4"><li><p>요구사항 개발 전 심적 표상을 미리 만드는 연습</p><blockquote><p>프로그램을 작성 하기 전에 심적 표상을 미리 만들고 이후 작업들을 미리 만든 심적 표상을 통해 모니터링 하며 평가하고 수정하는 습관을 들일 것이다.</p></blockquote></li></ol><h3 id="엄청-힘들-것-같은데"><a href="#엄청-힘들-것-같은데" class="headerlink" title="엄청 힘들 것 같은데?"></a>엄청 힘들 것 같은데?</h3><p>책의 저자는 이 ‘의식적인 연습’이 굉장히 힘들고 어려운 과정이라고 말한다. 실제로 특정 분야의 전문가에게도 의식적인 연습을 실천하는 것이 매우 힘든 일이라고 한다. 하지만, 그러한 노력이 있었기에 전문가가 된 것이다. 나는 이 책을 접하기 전까지 특정 분야에서 뛰어난 성과를 내는 사람은 그럴만한 재능이 있어서 그러한 일들을 해내는 것이란 생각을 은연중에 하고 있었다. 하지만 이 책에서 전문가들이 자신들의 위치에 오르기 까지 엄청난 노력이 하고 있었다는 사실을 접하면서 나의 기존 생각에 대해 반성하게 되었다. 재능이라는 단어로 그들의 노력을 어쩌면 깍아 내린 것 같았기 때문이다. 뿐만 아니라 의식적인 연습을 실천하면 전문가가 될 수 있다는 사실은 나에게 희망적인 요소로 다가왔다. 힘들겠지만 내가 되고싶은 전문가의 모습에 도달할 수 있는 방법을 찾은 것 같기 때문이다. 지금의 마음가짐은 위에서 계획한 대로 실천하는 것이지만 시간이 흘르면 어느샌가 다시 5분 학습에 굴레에 빠지게 될 가능성이 높다. 그때면 이 블로그 글을 피드백 삼아 지속적으로 ‘의식적인 연습’을 실천하는 개발자가 되도록 해야겠다.</p><h3 id="참고문헌"><a href="#참고문헌" class="headerlink" title="참고문헌"></a>참고문헌</h3><p><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=10765371" rel="external nofollow noopener noreferrer" target="_blank">안데르스 에릭슨, 로버트 풀. 『1만 시간의 재발견』. 강혜정(역). 비즈니스북스, 2016.</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;무언가-문제가-생긴-나의-학습-방법&quot;&gt;&lt;a href=&quot;#무언가-문제가-생긴-나의-학습-방법&quot; class=&quot;headerlink&quot; title=&quot;무언가 문제가 생긴 나의 학습 방법&quot;&gt;&lt;/a&gt;무언가 문제가 생긴 나의 학습 방법&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="독서" scheme="https://sogoagain.github.io/categories/%EB%8F%85%EC%84%9C/"/>
    
    
      <category term="생각" scheme="https://sogoagain.github.io/tags/%EC%83%9D%EA%B0%81/"/>
    
      <category term="독서" scheme="https://sogoagain.github.io/tags/%EB%8F%85%EC%84%9C/"/>
    
      <category term="학습" scheme="https://sogoagain.github.io/tags/%ED%95%99%EC%8A%B5/"/>
    
  </entry>
  
  <entry>
    <title>AWS도 Setter를 사용하지 않는다</title>
    <link href="https://sogoagain.github.io/2019/09/25/AWS%EB%8F%84-Setter%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4/"/>
    <id>https://sogoagain.github.io/2019/09/25/AWS도-Setter를-사용하지-않는다/</id>
    <published>2019-09-25T14:27:05.000Z</published>
    <updated>2019-09-27T13:01:06.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AWS도-Setter를-사용하지-않는다"><a href="#AWS도-Setter를-사용하지-않는다" class="headerlink" title="AWS도 Setter를 사용하지 않는다."></a>AWS도 Setter를 사용하지 않는다.</h2><h3 id="AWS-SDK-버전을-‘1-11-x’에서-‘2-x’로"><a href="#AWS-SDK-버전을-‘1-11-x’에서-‘2-x’로" class="headerlink" title="AWS SDK 버전을 ‘1.11.x’에서 ‘2.x’로"></a>AWS SDK 버전을 ‘1.11.x’에서 ‘2.x’로</h3><p>최근 회사 프로젝트의 AWS SDK(Java) 버전을 ‘1.11.x’에서 ‘2.x’으로 올리는 작업을 진행하였다.<br>사내 시스템에 다량의 Email을 발송하는 기능이 있는데 실행 시간이 오래 걸렸기 때문에 개선이 필요하였다.</p><p>메일 발송 기능은 AWS SES 서비스를 사용하고 있었고 실행 시간을 단축하고자 메일 발송 로직 전체를 비동기로 변경하려고 알아보던 중 AWS SDK 버전이 2.x로 들어서면서 Nonblocking I/O를 지원하는 것을 알게 되었고 업데이트를 단행하였다.</p><blockquote><p>The AWS SDK for Java 2.x utilizes a new, nonblocking SDK architecture built on Netty to support true nonblocking I/O. <a href="https://aws.amazon.com/ko/blogs/developer/aws-sdk-for-java-2-x-released/" rel="external nofollow noopener noreferrer" target="_blank">(AWS SDK for Java 2.x released)</a></p></blockquote><p>시스템에서는 AWS의 SES뿐만 아니라 다른 서비스도 사용하고 있었기에 수정 범위가 꽤 커졌지만, 코드 리팩토링과 함께 AWS SDK가 어떻게 달라졌나를 코드로 느끼며 진행했기에 흥미로운 경험이 되었다.</p><h3 id="‘2-x’는-Setter를-사용하지-않는다"><a href="#‘2-x’는-Setter를-사용하지-않는다" class="headerlink" title="‘2.x’는 Setter를 사용하지 않는다."></a>‘2.x’는 Setter를 사용하지 않는다.</h3><p>전체적으로 AWS SDK 2.0의 코드는 1.11.x보다 세련되었고 많은 부분이 변화하였다. 그중 내게 눈에 띈 변화는 바로 <strong>Setter를 없앤 사실</strong>이다.</p><blockquote><p>In the SDK for Java 2.x, setter method names don’t include the “set” or “with” prefix. <a href="https://docs.aws.amazon.com/en_pv/sdk-for-java/v2/migration-guide/whats-different.html" rel="external nofollow noopener noreferrer" target="_blank">(What’s Different between the SDK for Java 1.11.x and 2.x)</a></p></blockquote><p>생성자 호출 대신 Builder를 통해 객체를 생성하는 등 좋은 변화는 당연히 많았지만 나는 유독 Setter를 없앴다는 사실이 굉장히 반가웠다.</p><p>그동안 Setter를 사용하지 않고 프로그램을 작성할 수 있으며 더 좋은 코드를 위해서는 Setter는 사용하지 말아야 한다는 이야기를 종종 하고 다녔다. 하지만, 이 이야기를 하면 대부분 의심의 눈초리와 함께 예시를 요구한다.</p><p>사실 내가 예시를 들어도 의심의 눈초리는 쉽게 사그라지지 않는다. 하지만 그 예시가 AWS라면 다를 것이라 생각이 들었다. 이 생각은 정확히 맞아 들었다. 최근 모각코를 함께하는 분들께 AWS SDK 사례와 함께 ‘Getter, Setter’에 대한 유해성을 말씀드렸더니 큰 관심을 두고 이야기를 들어주었다.</p><p>일단 Getter와 Setter에 대해 자세한 이야기를 하기 전에 AWS SDK에서 Setter가 어떻게 없어졌고 Setter 없이 코드를 어떻게 작성하는지 살펴보자.</p><p>예를 들어 SDK 1.11.x에서 request를 업데이트하는 코드는 다음과 같았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DescribeAlarmsRequest request = <span class="keyword">new</span> DescribeAlarmsRequest();</span><br><span class="line">DescribeAlarmsResult response = cw.describeAlarms(request);</span><br><span class="line"></span><br><span class="line">request.setNextToken(response.getNextToken());</span><br></pre></td></tr></table></figure><p>하지만, SDK 2.x에서 request를 업데이트 하는 코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DescribeAlarmsRequest request = DescribeAlarmsRequest.builder().build();</span><br><span class="line">DescribeAlarmsResponse response = cw.describeAlarms(request);</span><br><span class="line"></span><br><span class="line">request = DescribeAlarmsRequest.builder()</span><br><span class="line">        .nextToken(new_token)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>SDK 2.x에서는 Setter 메서드를 제공하지 않기 때문에 request에 할당된 객체의 상태를 변경할 수 없다. request를 업데이트 하기 위해서는 객체를 새로 생성하여 할당하는 방법 뿐이다. 즉, 한번 생성된 객체는 변경 불가능한(Immutable POJO) 것이다.</p><p>바로 뒤 캡슐화 이야기를 하면서 자세히 설명하겠지만, 변경 불가능한 성질은 request 객체가 외부에서 예상치 못하게 변경될 수 있는 여지 자체를 없애주기 때문에 더욱 견고한 프로그램을 작성할 수 있도록 도와준다.</p><h2 id="Getter-Setter의-유해성"><a href="#Getter-Setter의-유해성" class="headerlink" title="Getter, Setter의 유해성"></a>Getter, Setter의 유해성</h2><p>AWS SDK는 왜 Setter를 제공하지 않도록 바뀐 것일까? 이에 대한 답이 우리가 Getter와 Setter를 피해야 하는 이유다.<br>결론부터 말하면 Getter와 Setter를 사용하는 순간 우리는 <strong>객체지향적</strong> 코드와 멀어지게 되며 객체지향이 주는 장점을 누릴 수 없게 된다.<br>객체지향적 코드와 멀어진다는 것은 데이터를 직접 조작하는 <strong>절차지향적</strong>으로 프로그램을 작성하게 된다는 것이다.</p><p>Getter, Setter의 유해성을 말하기 전에 Getter, Setter가 불필요한 이유를 간단히 살펴보자.<br>객체 안에 있는 것들을 꺼내서(Getter) 밖에서 처리한 뒤 다시 객체에 넣는(Setter) 행위는 조금만 생각해보면 굉장히 번거로운 작업임을 알 수 있다.<br>객체 내부에서 바로 처리하면 될 것을 굳이 왜 꺼내고 넣고 해야 하는가. 처리하는 행위를 객체 안에서 하면 ‘Getter’와 ‘Setter’는 자연스레 필요가 없어진다.</p><p>객체지향적인 사고로는 자연스레 Getter와 Setter가 필요 없는 것이다.<br>Getter와 Setter가 불필요한 이유 중 이만큼 중요하고 간단한 설명은 없는 것 같다.</p><p>조금 더 자세히 들여다보면 Getter와 Setter를 쓴다는 것은 외부에 객체가 어떻게 구현되어 있는지를 드러내는 것이다. 이는 구현을 내부로 숨기는 캡슐화에 어긋나는 것이다. 즉, Getter와 Setter를 사용하게 되면 캡슐화의 장점을 누릴 수 없게 된다.</p><p>객체지향은 캡슐화를 통해서 변경의 범위를 객체 내부로 한정 지을 수 있다. 그러나, Getter와 Setter가 사용되는 순간 객체 자신도 모르는 사이 자신의 내부 속성들이 외부 어디선가 사용되게 된다.</p><p>이렇게 외부에서 객체의 속성들을 사용하고 변경하는 환경에서 객체의 내부 구현이 변경되면 그 여파가 굉장히 커진다. 그리고 이러한 여파로 기능 추가 및 개선이 어렵게 되며 이는 곧 유지보수 비용이 커지는 결과를 초래한다.</p><p>특히, Setter는 Getter보다 더 위험하다. 외부에 객체의 상태를 변경할 방법을 제공하는 것이기 때문에 객체의 상태가 언제 어디서 어떻게 변할지 예측할 수 없다. 복잡한 비즈니스 로직을 제공하는 서비스나 협업하는 상황에서는 setter를 제공하는 객체의 상태 변화에 대한 추적이 더욱 어려워진다.</p><h2 id="객체가-해야할-일은-객체가-스스로-할-수-있도록-책임을-부여하자"><a href="#객체가-해야할-일은-객체가-스스로-할-수-있도록-책임을-부여하자" class="headerlink" title="객체가 해야할 일은 객체가 스스로 할 수 있도록 책임을 부여하자"></a>객체가 해야할 일은 객체가 스스로 할 수 있도록 책임을 부여하자</h2><p>그렇다면 우리는 어떻게 해야 할까? 당연히 앞서 말했다시피 AWS를 본받아 Getter와 Setter가 사용된 로직을 찾고 그 로직을 객체 내부로 옮겨야 한다.<br>이렇게 객체 외부에서 내부로 옮겨진 로직은 객체가 제공하는 책임이 되며 캡슐화된 로직이 된다.<br>캡슐화된 로직은 구현 변경에 있어서 유연함이 생긴다. 객체 외부에 존재하던 로직보다 변경의 여파가 적으며 중복된 코드도 줄여줄 수 있다. 또한 코드의 가독성도 올라간다.</p><h3 id="Getter를-제거한-리팩토링-사례"><a href="#Getter를-제거한-리팩토링-사례" class="headerlink" title="Getter를 제거한 리팩토링 사례"></a>Getter를 제거한 리팩토링 사례</h3><p>실제로 나는 리팩토링 할 곳을 찾을 때 중점적으로 보는 것 중 하나가 Getter와 Setter가 사용되는 곳이다.</p><p>사내 시스템에 데이터를 Excel 형식으로 추출하여 다운받을 수 있는 기능이 있다. 기존에는 Excel로 추출할 수 있는 도메인 각각에 대응되는 Excel 파일 작성 로직이 존재하였다. 즉 A라는 데이터를 추출하기 위한 로직 하나, B라는 데이터를 추출하기 위한 로직 하나 등등 여러 개의 Excel 파일 작성 로직이 존재하였다.</p><p>Excel 파일 작성 로직은 도메인 모델의 getter를 호출하여 Excel 파일을 만들고 있었다. 나는 이 로직들을 보고 Getter를 없애자는 목표로 리팩토링을 수행하였다.</p><p>먼저 Excel 파일 작성에 필요한 데이터를 나타내는 ExcelData라는 객체를 새로 만들고 Excel로 추출할 수 있는 객체들 내부에서 데이터를 조합하여 ExcelData를 반환토록 하였다. (Getter의 제거)<br>그리고 Excel로 추출할 수 있는 객체들을 공통된 인터페이스로 묶었다. (추상화/다형성)<br>그 결과 도메인 별로 1:1 매핑되어 존재하던 Excel 파일 작성 로직을 단 하나로 간추릴 수 있었다.</p><h2 id="Tell-Don’t-Ask"><a href="#Tell-Don’t-Ask" class="headerlink" title="Tell, Don’t Ask"></a>Tell, Don’t Ask</h2><p>객체지향 캡슐화와 관련되어 유명한 규칙 중 하나가 ‘Tell, Don’t Ask’다. 객체에게 ‘넌 뭘 갖고 있니?’라고 묻지 말고 ‘이것 좀 해줘’라고 말하라는 규칙이다.<br>객체가 갖고 있는 데이터를 읽는 순간 우리는 객체지향이 아닌 절차지향을 만나게 된다. 객체에 대해서 파고들지 말고 객체를 믿고 객체에게 묻는 것이 객체지향의 출발점이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AWS도-Setter를-사용하지-않는다&quot;&gt;&lt;a href=&quot;#AWS도-Setter를-사용하지-않는다&quot; class=&quot;headerlink&quot; title=&quot;AWS도 Setter를 사용하지 않는다.&quot;&gt;&lt;/a&gt;AWS도 Setter를 사용하지 않는다.
      
    
    </summary>
    
      <category term="객체지향" scheme="https://sogoagain.github.io/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
    
      <category term="java" scheme="https://sogoagain.github.io/tags/java/"/>
    
      <category term="OOP" scheme="https://sogoagain.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>코틀린(Kotlin)에서의 null 안전 처리</title>
    <link href="https://sogoagain.github.io/2019/08/20/%EC%BD%94%ED%8B%80%EB%A6%B0-Kotlin-%EC%97%90%EC%84%9C%EC%9D%98-null-%EC%95%88%EC%A0%84-%EC%B2%98%EB%A6%AC/"/>
    <id>https://sogoagain.github.io/2019/08/20/코틀린-Kotlin-에서의-null-안전-처리/</id>
    <published>2019-08-20T12:33:32.000Z</published>
    <updated>2019-08-21T14:56:55.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="코틀린-타입-시스템에서의-null"><a href="#코틀린-타입-시스템에서의-null" class="headerlink" title="코틀린 타입 시스템에서의 null"></a>코틀린 타입 시스템에서의 null</h2><p> 코틀린의 타입은 기본적으로 null 불가능(non-nullable)이다. 코틀린의 타입 시스템은 코드에서 NPE(NullPointerException)가 발생하지 않도록 설계되었다. 아래의 코틀린 Reference를 살펴보면 NPE가 발생하는 경우가 한정 되어 있다는 것을 확인할 수 있다.</p><blockquote><p><a href="https://kotlinlang.org/docs/reference/null-safety.html" rel="external nofollow noopener noreferrer" target="_blank">Kotlin Reference - Null Safety</a></p></blockquote><h2 id="명시적-null-타입"><a href="#명시적-null-타입" class="headerlink" title="명시적 null 타입"></a>명시적 null 타입</h2><p> 코틀린 시스템에서 기본적으로 null이 불가능하도록 강제하고 있지만, 자바와의 상호 운용성 등의 이유로 코틀린에서도 null이 사용되므로 null이 가능한(nullable)한 타입을 제공하고 있다. 일반 타입 뒤에 ‘?’를 붙이면 null을 할당할 수 있는 타입을 의미한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nonNullableText: String = <span class="string">"null을 할당할 수 없다."</span></span><br><span class="line">nonNullableText = <span class="literal">null</span> <span class="comment">// 컴파일 에러</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="string">"null을 할당할 수 있다."</span></span><br><span class="line">nullableText = <span class="literal">null</span> <span class="comment">// 컴파일 성공</span></span><br></pre></td></tr></table></figure><h2 id="nullable한-타입이-있어도-JAVA-보다는-괜찮다"><a href="#nullable한-타입이-있어도-JAVA-보다는-괜찮다" class="headerlink" title="nullable한 타입이 있어도 JAVA 보다는 괜찮다."></a>nullable한 타입이 있어도 JAVA 보다는 괜찮다.</h2><p>위의 예에서 보듯 코틀린의 타입은 기본적으로 non-nullable하므로 명시적 null 타입이 아닌 이상 null을 할당하려고 하면 <strong>컴파일 에러</strong>를 발생시킨다. 자바는 null로 인한 컴파일 에러는 발생하지 않는다. 자바에서의 null 오류는 <strong>런타임 에러</strong>다.</p><h3 id="JAVA보다-낫다지만-null이-가능한데…"><a href="#JAVA보다-낫다지만-null이-가능한데…" class="headerlink" title="JAVA보다 낫다지만 null이 가능한데…"></a>JAVA보다 낫다지만 null이 가능한데…</h3><p>위에서 보듯 어찌 되었든 코틀린에서는 null을 할당할 수 있는 타입을 사용할 수 있고 우리는 null에 대비를 해야한다. 우리가 사용하는 라이브러리가 nullable한 타입을 반환할 수 있다. 그럼, 코틀린에서는 어떤 방식으로 null을 안전하게 처리하는지 크게 4가지로 알아보자.</p><hr><h2 id="1-if로-null인지-검사하기"><a href="#1-if로-null인지-검사하기" class="headerlink" title="1. if로 null인지 검사하기"></a>1. if로 null인지 검사하기</h2><p>제일 쉽게 떠올릴 수 있는 방법이다. 다른 프로그래밍 언어에서와 마찬가지로 if를 사용해 변수에 null이 할당되었는지 확인하는 방법이다. </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nullableText != <span class="literal">null</span>) &#123;</span><br><span class="line">    println(nullableText)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">"null입니다."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 간단한 방법이기는 하나 그리 세련되지는 않은 것 같다. 이후 방법들에서는 코틀린에서 제공하는 연산자를 통해 null을 처리해보자</p><h2 id="2-double-bang-연산자-non-null-단언-연산자"><a href="#2-double-bang-연산자-non-null-단언-연산자" class="headerlink" title="2. double-bang 연산자 (non-null 단언 연산자)"></a>2. double-bang 연산자 (non-null 단언 연산자)</h2><p>double-bang 연산자라고 불리는 ‘!!’ non-null 단언 연산자를 이용하여 null을 처리할 수 있다. 이 연산자 이름에 단언(assertion)이 붙은것과 형태가 강한 느낌을 주는 느낌표 두개인 것을 통해 유추할 수 있듯이 이 연산자 nullable 변수에 쓰면 다음의 의미를 뜻한다. ‘비록 nullable 변수이지만 여기에 null이 절대 할당되지 않았음을 내가 단언한다.’ 사용은 아래와 같이 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> lengthOfText = nullableText!!.length</span><br></pre></td></tr></table></figure><p>그런데, double-bang 연산자는 치명적인 단점이 있다. 단언한 것 처럼 null이 아니면 상관 없는데, 단언과 다르게 null이 할당되어 있으면 NPE를 발생시킨다. double-bang 연산자는 nullable 타입이 호출할 수 없는 메서드를 강제로 호출하려고 할때 사용되는 느낌이다.</p><p> NPE를 발생시킬 수 있으므로 주의 깊게 사용해야 하는데, 미리 어디선가 해당 변수에 대해 null값을 검사하여 null이 절대 할당되지 않는다고 보장될 때 사용하면 될 것 같다.<br>또는 역발상으로 NPE가 어디서 발생하는지 디버깅 하는 용도로 사용될 수도 있을 것 같다.</p><h2 id="3-안전-호출-연산자-safe-call-operator"><a href="#3-안전-호출-연산자-safe-call-operator" class="headerlink" title="3. 안전 호출 연산자 (safe call operator)"></a>3. 안전 호출 연산자 (safe call operator)</h2><p>코틀린에서 nullable한 변수를 처리할 때 가장 자주 사용되는 방법인 것 같다. 안전 호출 연산자는 ‘?.’이며 null 값을 검사하여 null이면 건너뛰고 null이 아닐 때는 호출된 연산을 실행한다. 사용 방법은 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line">nullableText = nullableText?.capitalize()</span><br></pre></td></tr></table></figure><blockquote><p>String이 제공하는 메서드 중 capitalize()는 첫글자만 영문 대문자로 변경해준다.</p></blockquote><p>안전 호출 연산자를 사용하면 null 검사 후 null이 아닐 때만 로직을 실행하므로 NPE가 발생하지 않는다.</p><h2 id="4-Elvis-연산자-null-복합-연산자"><a href="#4-Elvis-연산자-null-복합-연산자" class="headerlink" title="4. Elvis 연산자 (null 복합 연산자)"></a>4. Elvis 연산자 (null 복합 연산자)</h2><p>null 복합 연산자는 ‘?:’ 이다. 연산자 모양이 가수 ‘엘비스 프레슬리’와 닮았다고 하여 Elvis 연산자라고도 불린다. Elvis 연산자는 Java에서 삼항 연산자로 null을 체크하는 로직을 단축한 것과 유사하다. Elvis 연산자의 왼쪽 피연산자가 null이면 오른쪽 피연산자를 실행하고 아니면 왼쪽 피연산자의 결과를 반환한다. 예로 살펴보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> nonNullableText: String = nullableText ?: <span class="string">"nullableText에 null이 할당되어 이게 반환됩니다."</span></span><br></pre></td></tr></table></figure><p>위 예에서 nullableText가 null이므로 오른쪽 피연산자인 “nullableText”가 반환된다. 엘비스 연산자의 동작 방식을 Java의 삼항 연산자로 표현하면 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String nullableText = <span class="keyword">null</span>;</span><br><span class="line">String nonNullableText = (nullableText != <span class="keyword">null</span> ? nullableText : <span class="string">"nullableText에 null이 할당되어 이게 반환됩니다."</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="위-4가지-방식-중-어떤-것을-사용해야-할까"><a href="#위-4가지-방식-중-어떤-것을-사용해야-할까" class="headerlink" title="위 4가지 방식 중 어떤 것을 사용해야 할까?"></a>위 4가지 방식 중 어떤 것을 사용해야 할까?</h2><p>정답은 없고 상황에 따라 다르겠지만 주로 세 번째 방법(안전 호출 연산자)와 네 번째 방법(Elvis 연산자)를 사용하면 보다 kotlin스럽게 코드를 작성할 수 있을 것 같다. 추가적으로 첫 번째 방법으로 소개했던 if로 null을 검사하는 로직도 ‘안전 호출 연산자’, ‘Elvis 연산자’, 그리고 ‘let’ 함수를 사용하여 동일한 로직을 아래와 같이 표현할 수 있다.</p><ul><li><p>if로 null 검사하기</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nullableText != <span class="literal">null</span>) &#123;</span><br><span class="line">    println(nullableText)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">"null입니다."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>‘안전 호출 연산자’, ‘Elvis 연산자’, ‘let’ 함수로 동일하게</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableText: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">nullableText?.let &#123;</span><br><span class="line">    println(nullableText)</span><br><span class="line">&#125; ?: println(<span class="string">"null입니다."</span>)</span><br></pre></td></tr></table></figure></li></ul><p>이렇게 if로 null을 검사하는 코드도 kotlin의 방법으로 대체할 수 있으니 되도록이면 kotlin에서 제공하는 방법으로 null을 처리해보는 것이 어떨까?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;코틀린-타입-시스템에서의-null&quot;&gt;&lt;a href=&quot;#코틀린-타입-시스템에서의-null&quot; class=&quot;headerlink&quot; title=&quot;코틀린 타입 시스템에서의 null&quot;&gt;&lt;/a&gt;코틀린 타입 시스템에서의 null&lt;/h2&gt;&lt;p&gt; 코틀린의 
      
    
    </summary>
    
      <category term="Kotlin" scheme="https://sogoagain.github.io/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="https://sogoagain.github.io/tags/Kotlin/"/>
    
      <category term="null처리" scheme="https://sogoagain.github.io/tags/null%EC%B2%98%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 메시지 - HTTP Requests</title>
    <link href="https://sogoagain.github.io/2019/08/03/HTTP-%EB%A9%94%EC%8B%9C%EC%A7%80-HTTP-Requests/"/>
    <id>https://sogoagain.github.io/2019/08/03/HTTP-메시지-HTTP-Requests/</id>
    <published>2019-08-03T14:02:16.000Z</published>
    <updated>2019-08-03T14:30:03.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-요청"><a href="#HTTP-요청" class="headerlink" title="HTTP 요청"></a>HTTP 요청</h2><p>웹에서 서버와 클라이언트 간 데이터를 주고받기 위해 HTTP 통신 규약을 사용한다. 오늘은 그중 클라이언트가 서버로 요청을 보내 어떤 행위가 일어나게끔 하는 HTTP 메시지 중 하나인 <strong>HTTP 요청 메시지</strong>에 대해 알아보기로 한다.</p><h2 id="HTTP-Requests"><a href="#HTTP-Requests" class="headerlink" title="HTTP Requests"></a>HTTP Requests</h2><ul><li>예시<figure class="highlight"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/user/create</span> HTTP/1.1</span><br><span class="line"><span class="attribute">HOST</span>: localhost:8080</span><br><span class="line"><span class="attribute">Connection-Length</span>: 59</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"></span><br><span class="line">userId=testUser&amp;password=testPassword</span><br></pre></td></tr></table></figure></li></ul><h3 id="요청-라인-Request-Line"><a href="#요청-라인-Request-Line" class="headerlink" title="요청 라인 (Request Line)"></a>요청 라인 (Request Line)</h3><p>Http request 메시지의 첫 줄을 요청 라인(Request Line)이라고 부른다. 요청 라인의 첫 번째는 HTTP 메서드(GET, PUT, POST 등)가 작성되며 그 뒤를 따라 URI, 마지막으로 HTTP 버전 정보가 작성된다.</p><h3 id="요청-헤더-Request-Header"><a href="#요청-헤더-Request-Header" class="headerlink" title="요청 헤더 (Request Header)"></a>요청 헤더 (Request Header)</h3><p>요청 라인 이후부터 공백 줄 사이까지 요청 헤더(Request Header)라고 부른다. 예시에서 2번째 줄 부터 5번재 줄이 요청 헤더다. 요청 헤더는 HTTP 헤더의 기본 구조를 따르는데 ‘&lt;필드 이름&gt; : &lt;필드 값&gt;’ 쌍으로 이루어져 있다. 필드 이름은 대소문자 구분 없는 문자열이며 필드 값이 여러 개일 경우 ‘,’로 구분한다.</p><h3 id="요청-본문-Request-Body"><a href="#요청-본문-Request-Body" class="headerlink" title="요청 본문 (Request Body)"></a>요청 본문 (Request Body)</h3><p>요청 헤더 이후 공백 줄 다음을 요청 헤더(Request Header)라고 부른다. 예시에서는 7번째 줄이 요청 본문에 해당한다. 모든 요청에 본문이 들어가는 것은 아니며 보통 POST 요청 시 요청 본문에 데이터를 적재하여 전송한다. 보통 GET과 같이 리소스를 가져오는 요청은 본문이 필요하지 않다.</p><blockquote><p>참고자료</p><ol><li>박재성, 자바 웹 프로그래밍 Next Step, 로드북(2016), p118~p119</li><li>MDN web docs, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages" rel="external nofollow noopener noreferrer" target="_blank">HTTP Messages</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP-요청&quot;&gt;&lt;a href=&quot;#HTTP-요청&quot; class=&quot;headerlink&quot; title=&quot;HTTP 요청&quot;&gt;&lt;/a&gt;HTTP 요청&lt;/h2&gt;&lt;p&gt;웹에서 서버와 클라이언트 간 데이터를 주고받기 위해 HTTP 통신 규약을 사용한다. 오늘은
      
    
    </summary>
    
      <category term="WEB" scheme="https://sogoagain.github.io/categories/WEB/"/>
    
    
      <category term="WEB" scheme="https://sogoagain.github.io/tags/WEB/"/>
    
      <category term="HTTP" scheme="https://sogoagain.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JUnit5, @ParameterizedTest 사용 예</title>
    <link href="https://sogoagain.github.io/2019/06/17/JUnit5-ParameterizedTest-%EC%82%AC%EC%9A%A9-%EC%98%88/"/>
    <id>https://sogoagain.github.io/2019/06/17/JUnit5-ParameterizedTest-사용-예/</id>
    <published>2019-06-16T18:25:04.000Z</published>
    <updated>2019-07-28T14:28:56.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUnit5에서-ParameterizedTest를-사용하여-여러번의-테스트-케이스-수행하기"><a href="#JUnit5에서-ParameterizedTest를-사용하여-여러번의-테스트-케이스-수행하기" class="headerlink" title="JUnit5에서 ParameterizedTest를 사용하여 여러번의 테스트 케이스 수행하기"></a>JUnit5에서 ParameterizedTest를 사용하여 여러번의 테스트 케이스 수행하기</h2><ul><li><p>테스트 메서드에 입력값만 전달할 경우</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource</span>(strings = &#123;</span><br><span class="line">        <span class="string">"123"</span>,</span><br><span class="line">        <span class="string">"1 - 2"</span>,</span><br><span class="line">        <span class="string">"1 + 2 + 3"</span>,</span><br><span class="line">        <span class="string">"2 + 3 * 4 / 2"</span>,</span><br><span class="line">        <span class="string">"1343 + 231 * 2 / 4"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">void</span> 올바른_형식의_수식으로_다항식_생성_테스트(String expression) &#123;</span><br><span class="line">Polynomial polynomial = Polynomial.createPolynomialWithExpression(expression);</span><br><span class="line"></span><br><span class="line">assertThat(polynomial).isInstanceOf(Polynomial.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>테스트 메서드에 입력값 뿐만 아니라 결과값도 전달할 필요가 있을 때</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource</span>(&#123;</span><br><span class="line">        <span class="string">"'1 - 2', -1"</span>,</span><br><span class="line">        <span class="string">"'1 + 2 + 3', 6"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">void</span> 다항식_연산_수행_테스트(String expression, <span class="keyword">int</span> expectedResult) &#123;</span><br><span class="line">Polynomial polynomial = Polynomial.createPolynomialWithExpression(expression);</span><br><span class="line"></span><br><span class="line">assertThat(polynomial.calculate()).isEqualTo(expectedResult);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JUnit5에서-ParameterizedTest를-사용하여-여러번의-테스트-케이스-수행하기&quot;&gt;&lt;a href=&quot;#JUnit5에서-ParameterizedTest를-사용하여-여러번의-테스트-케이스-수행하기&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="테스트주도개발" scheme="https://sogoagain.github.io/categories/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C/"/>
    
    
      <category term="junit" scheme="https://sogoagain.github.io/tags/junit/"/>
    
      <category term="TDD" scheme="https://sogoagain.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>가볍게 정리하는 git 기본</title>
    <link href="https://sogoagain.github.io/2019/06/12/%EA%B0%80%EB%B3%8D%EA%B2%8C-%EC%A0%95%EB%A6%AC%ED%95%98%EB%8A%94-git-%EA%B8%B0%EB%B3%B8/"/>
    <id>https://sogoagain.github.io/2019/06/12/가볍게-정리하는-git-기본/</id>
    <published>2019-06-11T18:18:16.000Z</published>
    <updated>2019-07-26T18:57:46.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-기본-내용-정리"><a href="#Git-기본-내용-정리" class="headerlink" title="Git 기본 내용 정리"></a>Git 기본 내용 정리</h2><p>Git과 Github를 사용하고 있지만 단순히 commit, pull/push, branch 정도의 기능만 사용하고 있었을 뿐 아니라 Git GUI 도구를 활용했기에 명령줄 환경에서 git을 잘 다루지 못하였다. Git의 여러 기능을 명령줄 환경에서 능숙하게 사용하여 버전관리 및 협업을 제대로 하고 싶은 바람이 마음속 깊숙이 자리 잡고 있었다. 미루고 미루다 이번에 기회가 되어 Git의 내용을 정리해보는 시간을 가졌다.</p><p>명령어 중심으로 정리를 한 것이라 Git을 처음 사용하시는 분들은 포스팅에 참고한 아래 2개의 링크를 통해 Git의 기본적인 사용법을 익히는 것을 추천한다.<br>생활코딩의 <a href="https://www.opentutorials.org/course/2708" rel="external nofollow noopener noreferrer" target="_blank">지옥에서 온 Git</a>강의와 <a href="http://rogerdudler.github.io/git-guide/index.ko.html" rel="external nofollow noopener noreferrer" target="_blank">git - 간편 안내서</a>를 참고하였다.</p><h2 id="Git-이란"><a href="#Git-이란" class="headerlink" title="Git 이란?"></a>Git 이란?</h2><ul><li>버전관리 시스템 중 하나 (구체적인 제품)</li><li>소스코드의 ‘백업’, ‘복원’, ‘협업’을 효율적으로 할 수 있도록 해주는 프로그램이다.</li></ul><h3 id="git-환경설정"><a href="#git-환경설정" class="headerlink" title="git 환경설정"></a>git 환경설정</h3><ul><li>git을 사용하는 사용자 이름이나 email 주소를 설정해놓을 수 있다. 이런 설정을 해놓아야 협업을 할 때 작업한 사람을 식별하는데 용이하다.</li></ul><ol><li>config 정보 확인<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li></ol><ul><li>config list를 확인한 후 exit를 하고 싶을 땐 ‘:q’를 입력하면 된다.</li></ul><ol start="2"><li><p>config 설정하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "이름"</span><br><span class="line">git config --global user.email "이메일"</span><br></pre></td></tr></table></figure></li><li><p>config 삭제하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --unset --global user.name</span><br><span class="line">git config --unset --global user.email</span><br></pre></td></tr></table></figure></li></ol><h3 id="저장소-만들기"><a href="#저장소-만들기" class="headerlink" title="저장소 만들기"></a>저장소 만들기</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>위 명령어를 실행하면 현재 디렉터리에 ‘.git’ 이라는 디렉터리가 생성된다.</li><li>‘.git’ 디렉터리는 버전정보와 관련된 내용들이 저장되는 디렉터리다.</li></ul><h3 id="저장소-상태보기"><a href="#저장소-상태보기" class="headerlink" title="저장소 상태보기"></a>저장소 상태보기</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="버전관리"><a href="#버전관리" class="headerlink" title="버전관리"></a>버전관리</h2><h3 id="파일을-인덱스에-추가하기-파일-tracking"><a href="#파일을-인덱스에-추가하기-파일-tracking" class="headerlink" title="파일을 인덱스에 추가하기 (파일 tracking)"></a>파일을 인덱스에 추가하기 (파일 tracking)</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file name&gt;</span><br></pre></td></tr></table></figure><ul><li>commit을 하기전에 하나의 버전으로 묶을 파일들을 add를 통해 인덱스에 추가해 놓아야 한다.</li><li>add는 프로젝트의 수많은 수정사항들 중에 하나의 작업 단위에 속하는 파일들끼리 묶어서 commit할 수 있도록 도와준다.</li><li>git add된 파일들은 “staging area”에 속하게 된다.</li></ul><h3 id="변경내용-확정하기-버전-만들기"><a href="#변경내용-확정하기-버전-만들기" class="headerlink" title="변경내용 확정하기 (버전 만들기)"></a>변경내용 확정하기 (버전 만들기)</h3><ul><li>버전은 ‘의미 있는 변화, 변화가 완결된 상태’ 정도로 이해할 수 있으며, 좋은 버전의 단위는 고민해봐야할 사항이다.</li><li>commit은 하나의 작업을 담고 있는 것이 좋다.</li><li>commit된 파일들은 “repository”에 속하게 된다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><ul><li>git index에 추가된 파일이 존재할 경우 위 명령어를 실행하면 vi 편집기가 실행된다. 맨 윗줄에 버전에 대한 설명을 적고 저장하면 commit이 완료된다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "버전에 대한 설명"</span><br></pre></td></tr></table></figure><ul><li>vi 편집기를 사용하지 않고 ‘m’ 옵션을  이용해서 바로 commit할 수 있다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m "버전에 대한 설명"</span><br></pre></td></tr></table></figure><ul><li>매번 git add 후에 git commit을 하는 것이 번거로울 수 있다. 그럴땐 ‘a’ 옵션을 통해 add와 commit을 동시에 할 수 있다.</li><li>‘a’ 옵션은 변경된 파일을 인덱스에 추가한 뒤 커밋한다. 이때, 신규로 추가된 파일(한번도 add를 하지 않은 파일)은 제외된다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><ul><li>amend 옵션을 통해 커밋 메세지를 수정할 수 있다.</li><li>단, 원격 저장소에 올리기 전에 수정해야한다.</li></ul><h3 id="commit-로그-확인"><a href="#commit-로그-확인" class="headerlink" title="commit 로그 확인"></a>commit 로그 확인</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><ul><li>commit 로그를 확인할 수 있다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><ul><li>reset 기록을 확인할 수 있다.</li></ul><h3 id="변경사항-확인하기"><a href="#변경사항-확인하기" class="headerlink" title="변경사항 확인하기"></a>변경사항 확인하기</h3><ol><li>차이점 확인</li></ol><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure><ul><li>각각의 커밋과 커밋 사이의 소스 차이를 확인 할 수 있다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit id&gt;..&lt;commit id&gt;</span><br></pre></td></tr></table></figure><ul><li>특정한 두 커밋 사이의 차이점을 확인 할 수 있다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><ul><li>제일 최근의 커밋된 버전과 현재 작업한 수정 내역과의 차이점을 확인할 수 있다.</li><li>수정된 파일들을 git add하게 되면 확인할 수 없다.</li></ul><h3 id="변경내용-되돌리기"><a href="#변경내용-되돌리기" class="headerlink" title="변경내용 되돌리기"></a>변경내용 되돌리기</h3><ol><li>reset<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit id&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>reset은 되돌리려는 commit으로 상태가 돌아간다. 되돌리려는 commit 이후의 이력은 숨겨진다.</p></li><li><p>reset 명령어에서 사용할 수 있는 옵션은 ‘soft, mixed, hard’ 등이 있다.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard ORIG_HEAD</span><br></pre></td></tr></table></figure></li><li><p>reset 하기 전으로 되돌리고 싶다면 ‘ORIG_HEAD’로 reset 하면 된다.</p></li></ul><ol start="2"><li>revert<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert</span><br></pre></td></tr></table></figure></li></ol><ul><li>revert는 돌아가려는 commit을 기반으로 새로운 commit을 생성하며 작업 상태를 되돌리는 명령어다.</li><li>즉, commit 이력을 유지하면서 내용을 되돌린다고 볼 수 있다.</li></ul><ol start="3"><li>checkout<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit id&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>checkout은 본래 branch를 변경할 때 사용하는 명령어인데, 아래와 같은 방법으로 변경 내용을 되돌릴 수 있다.</li><li>HEAD가 branch를 가리키는 것이 아닌 직접 commit을 가리키게 된다.</li><li>git branch 명령어를 통해서 위 내용을 확인할 수 있다.</li></ul><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><h3 id="가지-branch-치기"><a href="#가지-branch-치기" class="headerlink" title="가지(branch) 치기"></a>가지(branch) 치기</h3><ul><li>branch는 원래 버전관리 되던 작업을 통째로 복사한 뒤 독립적으로 개발하여 또 다른 버전의 줄기를 만드는 것이다.</li></ul><ol><li><p>branch 확인하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>branch 생성하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch name&gt;</span><br><span class="line">git checkout -b &lt;branch name&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>checkout 명령어에 ‘b’ 옵션을 통해 branch를 생성하면서 바로 생성된 branch로 checkout 할 수 있다.</li></ul><ol start="3"><li><p>branch 갈아타기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch name&gt;</span><br></pre></td></tr></table></figure></li><li><p>모든 branch의 커밋 로그 확인하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --branches --decorate --graph --oneline</span><br></pre></td></tr></table></figure></li><li><p>branch 사이의 commit 차이점 확인하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;branch1 name&gt;..&lt;branch2 name&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>branch1에는 없고 branch2에는 있는 commit 로그를 보여준다.</li><li>‘p’ 옵션을 통해 소스코드의 차이점도 볼 수 있다.</li></ul><ol start="6"><li>diff 명령어를 이용하여 branch 사이의 상태 비교<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;branch1 name&gt;..&lt;branch2 name&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>diff 명령어를 통해서 branch1과 branch2의 현재 상태들을 비교할 수 있다.</li></ul><h3 id="branch-병합하기"><a href="#branch-병합하기" class="headerlink" title="branch 병합하기"></a>branch 병합하기</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch2 name&gt;</span><br></pre></td></tr></table></figure><ul><li>branch2에서 branch1으로 병합을 하기 위해선 아래의 절차를 밟아야 한다.</li></ul><ol><li>branch1으로 checkout</li><li>branch1에서 merge 명령을 한다.</li><li>병합된 commit이 새로 생성된다.</li></ol><ul><li>merge tool을 이용한 병합</li></ul><ol><li><p>git 설정</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool &lt;tool name&gt;</span><br></pre></td></tr></table></figure></li><li><p>merge 후 conflict가 발생</p></li><li><p>mergetool 실행 후 conflict 해결</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mergetool</span><br></pre></td></tr></table></figure></li><li><p>conflict를 해결하면 바로 commit 되는데, <filename>.orig 라는 백업 파일이 생성되므로 차후에 삭제를 권장한다.</filename></p></li></ol><h3 id="branch-삭제하기"><a href="#branch-삭제하기" class="headerlink" title="branch 삭제하기"></a>branch 삭제하기</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch name&gt;</span><br></pre></td></tr></table></figure><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash --help</span><br></pre></td></tr></table></figure><ul><li>현재 branch에서 작업을 하는 중에 다른 branch로 변경하여 작업을 해야할 일이 있을 때 사용하는 명령어다.</li><li>작업중이었던 내용을 어딘가 저장하여 감추는 기능을 한다.</li><li>git stash 명령은 버전관리가 되고 있는 파일에 대해서만 사용 가능하다.</li></ul><ol><li><p>작업 내용 숨기기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save</span><br></pre></td></tr></table></figure></li><li><p>stash 목록 확인하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure></li><li><p>숨겼던 작업 내용 적용하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure></li><li><p>가장 최신 stash 삭제하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop</span><br></pre></td></tr></table></figure></li><li><p>stash 했던 작업 내용을 적용한 뒤 바로 삭제하기</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li></ol><h3 id="원격-저장소"><a href="#원격-저장소" class="headerlink" title="원격 저장소"></a>원격 저장소</h3><ul><li>원격 저장소는 지역(local) 저장소 반대에 있는 개념으로 ‘소스 백업’ 및 ‘협업’을 가능케 한다.</li></ul><ol><li>원격 저장소 생성<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init --bare &lt;remote directory&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>원격 저장소를 만드려는 디렉터리에 위 명령어를 입력한다.</li><li>init의 bare 옵션은 작업이 불가능한(working directory가 없는) 저장소를 생성한다.</li><li>즉, 순수한 저장의 기능을 하는 저장소가 생성된다.</li></ul><ol start="2"><li>원격 저장소 연결<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;원격 저장소 별칭&gt; &lt;원격 저장소 경로&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>지역(local) 저장소와 원격 저장소를 연결한다.</li><li>보통 원격 저장소 별칭은 ‘origin’을 사용한다.</li></ul><ol start="3"><li><p>원격 저장소 확인</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li><li><p>연결된 원격 저장소 제거</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove &lt;원격 저장소 별칭&gt;</span><br></pre></td></tr></table></figure></li><li><p>원격 저장소 복제</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;원격 저장소 주소&gt; &lt;로컬 저장소 경로&gt;</span><br></pre></td></tr></table></figure></li><li><p>원격 저장소로 전송</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;원격 저장소 별칭&gt; &lt;branch 이름&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>‘–set-upstream’ 옵션을 사용하면 현재 branch와 원격저장소의 branch를 연결하여 다음 명령 부터는 원격 저장소와 원격 저장소의 branch를 명시할 필요가 없도록 해주는 옵션이다.</li><li>즉, 첫 push에 ‘–set-upstream’ 옵션을 주면 이후부터는 ‘git push’를 통해 원격 저장소로 전송이 가능하다.</li></ul><ol start="7"><li>원격 저장소 내용 가져오기<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>pull 명령어는 원격 저장소의 내용을 로컬 저장소로 가져와 병합 작업 후 작업 내용을 반영한다.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure></li><li><p>fetch 명령어는 원격 저장소의 내용을 로컬 저장소로 가져오기는 하지만 새로운 브랜치로 가져오기 때문에 로컬 저장소에 반영이 되지 않는다.</p></li><li><p>fetch로 가져온 새로운 브랜치는 ‘FETCH_HEAD’ 이름으로 체크아웃 가능하다.</p></li></ul><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;branch name&gt;</span><br></pre></td></tr></table></figure><ul><li>서로 다른 브랜치를 병합하는 기능을 하는 명령어다.</li><li>merge 명령어와 다르게 병합하는 브랜치의 커밋 이력을 유지할 수 있다.</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><ul><li>rebase 명령어 실행 중 conflict가 일어나면 해결 후 continue 옵션을 통해 계속해서 병합을 실행한다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-기본-내용-정리&quot;&gt;&lt;a href=&quot;#Git-기본-내용-정리&quot; class=&quot;headerlink&quot; title=&quot;Git 기본 내용 정리&quot;&gt;&lt;/a&gt;Git 기본 내용 정리&lt;/h2&gt;&lt;p&gt;Git과 Github를 사용하고 있지만 단순히 comm
      
    
    </summary>
    
      <category term="도구Tip" scheme="https://sogoagain.github.io/categories/%EB%8F%84%EA%B5%ACTip/"/>
    
    
      <category term="git" scheme="https://sogoagain.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>문화와 기술</title>
    <link href="https://sogoagain.github.io/2019/06/07/%EB%AC%B8%ED%99%94%EC%99%80-%EA%B8%B0%EC%88%A0/"/>
    <id>https://sogoagain.github.io/2019/06/07/문화와-기술/</id>
    <published>2019-06-06T18:16:35.000Z</published>
    <updated>2019-10-20T14:05:32.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문화와-기술"><a href="#문화와-기술" class="headerlink" title="문화와 기술"></a>문화와 기술</h3><p>최근 읽고 있는 ‘임백준의 대살개문’에서 다음과 같은 문구를 접하게 되었다.</p><blockquote><p>문화는 흙이고 기술은 꽃이다. - 임백준의 대살개문 中</p></blockquote><p>책 제목 자체가 ‘대한민국을 살리는 개발자 문화’의 약자다.<br>기술의 꽃이 필 수 있도록 좋은 개발 문화를 만드는데 일조를 하고 싶다.<br>그렇기에, 나와 내 주변으로부터 시작해 어제보다 한 걸음 더 앞서 있을 수 있도록 노력할 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문화와-기술&quot;&gt;&lt;a href=&quot;#문화와-기술&quot; class=&quot;headerlink&quot; title=&quot;문화와 기술&quot;&gt;&lt;/a&gt;문화와 기술&lt;/h3&gt;&lt;p&gt;최근 읽고 있는 ‘임백준의 대살개문’에서 다음과 같은 문구를 접하게 되었다.&lt;/p&gt;
&lt;blockq
      
    
    </summary>
    
      <category term="독서" scheme="https://sogoagain.github.io/categories/%EB%8F%85%EC%84%9C/"/>
    
    
      <category term="독서" scheme="https://sogoagain.github.io/tags/%EB%8F%85%EC%84%9C/"/>
    
      <category term="개발문화" scheme="https://sogoagain.github.io/tags/%EA%B0%9C%EB%B0%9C%EB%AC%B8%ED%99%94/"/>
    
      <category term="etc" scheme="https://sogoagain.github.io/tags/etc/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm 문제 Java Code Snippet</title>
    <link href="https://sogoagain.github.io/2019/05/01/Algorithm-%EB%AC%B8%EC%A0%9C%EC%97%90%EC%84%9C-%EB%82%B4%EA%B0%80-%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-Java-Code-Snippet/"/>
    <id>https://sogoagain.github.io/2019/05/01/Algorithm-문제에서-내가-자주-사용하는-Java-Code-Snippet/</id>
    <published>2019-04-30T18:13:54.000Z</published>
    <updated>2019-07-26T18:16:02.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="알고리즘-문제-풀이-시-자주-사용-되는-Code-Snippet-정리"><a href="#알고리즘-문제-풀이-시-자주-사용-되는-Code-Snippet-정리" class="headerlink" title="알고리즘 문제 풀이 시 자주 사용 되는 Code Snippet 정리"></a>알고리즘 문제 풀이 시 자주 사용 되는 Code Snippet 정리</h2><p>한동안 풀었던 알고리즘 문제들의 소스 코드를 스스로 리뷰해보는 시간을 가졌다.<br>알고리즘 문제를 풀 때면 비슷한 코드 조각들을 작성하게 되는데, 그때그때 찾아보거나 생각해서 작성하려니 시간 소요가 생각보다 커지게 되었다. 이와 같은 이유로 이제껏 작성한 코드에서 자주 사용되는 조각들을 추출하여 정리해보았다.</p><p>정리해보니 자료구조의 사용과 관련된 코드들이 많았다. 앞으로 Collection과 람다를 깊게 공부하여 더 좋은 방법이 있으면 바로바로 업데이트할 생각이다.</p><h2 id="HashMap-사용"><a href="#HashMap-사용" class="headerlink" title="HashMap 사용"></a>HashMap 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">results.putIfAbsent(rank, <span class="number">0</span>);</span><br><span class="line">results.computeIfPresent(rank, (k, v) -&gt; ++v);</span><br></pre></td></tr></table></figure><hr><h2 id="List-사용"><a href="#List-사용" class="headerlink" title="List 사용"></a>List 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allCases.removeIf(i -&gt; !Arrays.equals(result, simulate(i, ball)));</span><br></pre></td></tr></table></figure><hr><h2 id="우선순위-큐-사용"><a href="#우선순위-큐-사용" class="headerlink" title="우선순위 큐 사용"></a>우선순위 큐 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumAverageProcessingTime</span><span class="params">(<span class="keyword">int</span>[][] jobs)</span> </span>&#123;</span><br><span class="line">Queue&lt;Job&gt; scheduleQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparing(j -&gt; j.requestedTime));</span><br><span class="line">Arrays.stream(jobs).forEach(j -&gt; scheduleQueue.add(<span class="keyword">new</span> Job(j[<span class="number">0</span>], j[<span class="number">1</span>])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.naturalOrder());</span><br><span class="line">Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.reverseOrder());</span><br></pre></td></tr></table></figure><hr><h2 id="Array를-List로"><a href="#Array를-List로" class="headerlink" title="Array를 List로"></a>Array를 List로</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; participantList = Arrays.asList(participant);</span><br><span class="line">List&lt;Integer&gt; lostStudents = Arrays.stream(lost)</span><br><span class="line">                        .boxed()</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">List&lt;Integer&gt; lostStudents = IntStream.of(lost)</span><br><span class="line">                        .boxed()</span><br><span class="line">                        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; peopleList = Arrays.stream(people)</span><br><span class="line">                    .boxed()</span><br><span class="line">                    .sorted(Comparator.reverseOrder())</span><br><span class="line">                    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><h2 id="List를-Array로"><a href="#List를-Array로" class="headerlink" title="List를 Array로"></a>List를 Array로</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> numbers.stream()</span><br><span class="line">            .mapToInt(i -&gt; i)</span><br><span class="line">            .toArray();</span><br></pre></td></tr></table></figure><h2 id="Array를-Queue로"><a href="#Array를-Queue로" class="headerlink" title="Array를 Queue로"></a>Array를 Queue로</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; dateQueue = Arrays.stream(dates)</span><br><span class="line">                    .boxed()</span><br><span class="line">                    .collect(Collectors.toCollection(LinkedList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><hr><h2 id="Array-정렬"><a href="#Array-정렬" class="headerlink" title="Array 정렬"></a>Array 정렬</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(cubes, Collections.reverseOrder());</span><br><span class="line">Arrays.sort(costs, Comparator.comparing(cost -&gt; cost[<span class="number">2</span>]));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] sorted = IntStream.of(a)</span><br><span class="line">            .boxed()</span><br><span class="line">            .sorted(Comparator.reverseOrder())</span><br><span class="line">            .mapToInt(i -&gt; i)</span><br><span class="line">            .toArray();</span><br><span class="line"><span class="keyword">int</span>[] sortedNumbers = Arrays.stream(numbers)</span><br><span class="line">            .boxed()</span><br><span class="line">            .sorted((Integer o1, Integer o2) -&gt; Integer.valueOf(o2 + <span class="string">""</span> + o1) - Integer.valueOf(o1 + <span class="string">""</span> + o2))</span><br><span class="line">            .mapToInt(i -&gt; i)</span><br><span class="line">            .toArray();</span><br></pre></td></tr></table></figure><hr><h2 id="List에서-최대-최소값-찾기"><a href="#List에서-최대-최소값-찾기" class="headerlink" title="List에서 최대/최소값 찾기"></a>List에서 최대/최소값 찾기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer max = listOfIntegers</span><br><span class="line">            .stream()</span><br><span class="line">            .mapToInt(v -&gt; v)</span><br><span class="line">            .max().orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person minByAge = people</span><br><span class="line">            .stream()</span><br><span class="line">            .min(Comparator.comparing(Person::getAge))</span><br><span class="line">            .orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;알고리즘-문제-풀이-시-자주-사용-되는-Code-Snippet-정리&quot;&gt;&lt;a href=&quot;#알고리즘-문제-풀이-시-자주-사용-되는-Code-Snippet-정리&quot; class=&quot;headerlink&quot; title=&quot;알고리즘 문제 풀이 시 자주 사용
      
    
    </summary>
    
      <category term="개발Tip" scheme="https://sogoagain.github.io/categories/%EA%B0%9C%EB%B0%9CTip/"/>
    
    
      <category term="java" scheme="https://sogoagain.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ에서 Docker로 Web App 배포하기</title>
    <link href="https://sogoagain.github.io/2019/03/08/IntelliJ%EC%97%90%EC%84%9C-Docker%EB%A1%9C-Web-App-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/"/>
    <id>https://sogoagain.github.io/2019/03/08/IntelliJ에서-Docker로-Web-App-배포하기/</id>
    <published>2019-03-07T18:11:20.000Z</published>
    <updated>2019-07-26T18:12:48.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WAR-artifact-빌드"><a href="#WAR-artifact-빌드" class="headerlink" title="WAR artifact 빌드"></a>WAR artifact 빌드</h2><ul><li><p>Project Settings(⌘;) &gt; Artifacts 메뉴 진입</p></li><li><p>(+) 버튼 &gt; Web Application: Archive &gt; For ‘[Project Name]:war exploded’ 클릭</p></li><li><p>생성된 Artifacts의 속성 설정 후 Apply</p><blockquote><p>Output Layout에서 ‘.war’ 파일의 파일명이 Context Root 명이 되므로 원하는 Context Root가 있을 경우 .war 파일명을 변경합니다.<br>.war의 기본 파일명은 [Project Name]_war.war</p></blockquote></li><li><p>Build 메뉴 &gt; Build Artifacts &gt; 위에서 생성한 Artifacts로 빌드</p></li></ul><h2 id="Docker에-올려진-Tomcat-서버로-배포"><a href="#Docker에-올려진-Tomcat-서버로-배포" class="headerlink" title="Docker에 올려진 Tomcat 서버로 배포"></a>Docker에 올려진 Tomcat 서버로 배포</h2><ul><li><p>IntelliJ 하단 Docker 윈도우로 이동</p><blockquote><p>사전에 IntelliJ와 Docker를 연결해야 합니다.</p></blockquote></li><li><p>Docker에 있는 Tomcat 이미지 우클릭 &gt; Create container &gt; Create…</p></li><li><p>팝업된 ‘Create Docker Configuration’에서 컨테이너 정보를 설정</p><ol><li><p>Container name 설정: 차후에 어떤 프로젝트의 컨테이너인지 식별하기 편합니다.</p></li><li><p>Bind ports</p><ul><li>Host port: 8080</li><li>Container port: 8080</li><li>Host IP: 127.0.0.1</li></ul></li><li><p>Bind mounts</p><ul><li>본 글 첫번째 단계에서 빌드한 WAR artifact과 tomcat 배포 경로를 바인딩합니다.</li><li>Host path: [PROJECT_PATH]/out/artifacts/[WAR File Directory]/<blockquote><p>WAR File Directory: WAR artifact 생성 시 특별한 설정을 하지 않았다면, 기본 디렉터리명은 ‘[Project Name]_war’ 입니다. </p></blockquote></li><li>Container path: /usr/local/tomcat/webapps/</li></ul></li><li><p>Run 클릭</p></li></ol></li></ul><h2 id="배포한-Web-Application으로-접속"><a href="#배포한-Web-Application으로-접속" class="headerlink" title="배포한 Web Application으로 접속"></a>배포한 Web Application으로 접속</h2><ul><li>접속 URL: <a href="http://127.0.0.1:8080/[WAR" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:8080/[WAR</a> artifact File Name]/</li></ul><blockquote><p>참고: <a href="https://www.jetbrains.com/help/idea/deploying-a-web-app-into-an-app-server-container.html" rel="external nofollow noopener noreferrer" target="_blank">Deploy a Java web application inside a Tomcat server container</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WAR-artifact-빌드&quot;&gt;&lt;a href=&quot;#WAR-artifact-빌드&quot; class=&quot;headerlink&quot; title=&quot;WAR artifact 빌드&quot;&gt;&lt;/a&gt;WAR artifact 빌드&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Project S
      
    
    </summary>
    
      <category term="도구Tip" scheme="https://sogoagain.github.io/categories/%EB%8F%84%EA%B5%ACTip/"/>
    
    
      <category term="Docker" scheme="https://sogoagain.github.io/tags/Docker/"/>
    
      <category term="IntelliJ" scheme="https://sogoagain.github.io/tags/IntelliJ/"/>
    
  </entry>
  
  <entry>
    <title>ORA-12505 오류 해결</title>
    <link href="https://sogoagain.github.io/2019/02/22/ORA-12505-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/"/>
    <id>https://sogoagain.github.io/2019/02/22/ORA-12505-오류-해결/</id>
    <published>2019-02-21T18:08:57.000Z</published>
    <updated>2019-07-26T18:09:45.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ORA-12505-오류-발생과-해결"><a href="#ORA-12505-오류-발생과-해결" class="headerlink" title="ORA-12505 오류 발생과 해결"></a>ORA-12505 오류 발생과 해결</h2><ul><li>오류 내용: ORA-12505, TNS:listener does not currently know of SID given in connect descriptor</li><li>업무 중 타 시스템의 Oracle DB와 연동하는 작업을 진행 하였습니다. 이전까지 진행했던 Oracle DB 연결 작업의 절차를 따라 진행 하였음에도 ORA-12505 오류가 발생하며 연결에 차질이 생겼습니다. 이 문제를 해결하며 알게된 SID와 Service Name에 대해서 정리해 보았습니다.</li><li>연결에 차질이 생긴 원인은 SID를 이용한 연결과 Service Name을 이용한 연결의 경우 Connection String이 다르기 구성되기 때문이었습니다.</li><li>즉, 이전까지 진행했던 Oracle DB 연동은 SID를 이용하였으나 이번에는 Service Name을 이용하여 연동 작업을 진행했습니다. 그러나, Connection String을 SID 연동하던 사례를 바탕으로 작성하여 Service Name에 맞게 구성하지 못했기 때문에 ORA-12505오류가 발생하였습니다.<blockquote><p>물론 ORA-12505 오류가 발생하는 케이스는 훨씬 다양합니다. 그러나, 저와 같은 상황에 놓인 분들에게 이 글이 도움이 되었으면 좋겠습니다.</p></blockquote></li></ul><h2 id="SID와-Service-Name"><a href="#SID와-Service-Name" class="headerlink" title="SID와 Service Name"></a>SID와 Service Name</h2><ul><li>SID: System Identifier의 약자로 하나의 특정 DB 인스턴스를 식별하는 ID입니다. 즉, 각 데이터베이스 인스턴스에 부여되는 ID입니다.</li><li>Service Name: 여러개의 인스턴스를 모아 하나의 서비스를 구성한 것을 식별하는 이름입니다.</li></ul><h2 id="Connection-String"><a href="#Connection-String" class="headerlink" title="Connection String"></a>Connection String</h2><ul><li>SID를 통한 연결</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username/password@host:port:SID</span><br></pre></td></tr></table></figure><ul><li>Service Name을 통한 연결</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username/password@host:port/SERVICE_NAME</span><br></pre></td></tr></table></figure><ul><li>즉, SID는 “:”를 통해서 Service Name은 “/“을 통해서 연결합니다.</li><li>문자 하나 차이로 간단하지만 막상 이러한 상황을 만나면 해결하는데 꽤 오랜 시간이 걸립니다. Connection String에 오류가 있다고 깨닫는데는 시간이 조금 걸리기 때문입니다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ORA-12505-오류-발생과-해결&quot;&gt;&lt;a href=&quot;#ORA-12505-오류-발생과-해결&quot; class=&quot;headerlink&quot; title=&quot;ORA-12505 오류 발생과 해결&quot;&gt;&lt;/a&gt;ORA-12505 오류 발생과 해결&lt;/h2&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="데이터베이스" scheme="https://sogoagain.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="DB" scheme="https://sogoagain.github.io/tags/DB/"/>
    
      <category term="Oracle" scheme="https://sogoagain.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D에서 Observer패턴을 이용한 연산량 감소</title>
    <link href="https://sogoagain.github.io/2019/02/06/Unity3D%EC%97%90%EC%84%9C-Observer%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%B0%EC%82%B0%EB%9F%89-%EA%B0%90%EC%86%8C/"/>
    <id>https://sogoagain.github.io/2019/02/06/Unity3D에서-Observer패턴을-이용한-연산량-감소/</id>
    <published>2019-02-05T18:03:59.000Z</published>
    <updated>2019-07-26T18:07:51.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><ul><li>도플러 효과를 이용한 실감 음향 기술을 제안하는 프로젝트를 Unity3D와 아두이노(움직이는 스피커)를 이용하여 진행.</li><li>음원의 이동에 따른 도플러 효과를 고려(계산)하기 위하여 Unity3D내 주요 개체들이 음원 개체의 위치를 매순간 참조</li><li>Unity3D내 주요 개체들이 음원 개체를 매번 참조하는 것이 아닌, 음원 개체의 위치가 변경될 때만 위치를 참조하여 계산을 하도록 설계하면 프로그램 연산량이 감소될 것이라 기대</li></ul><h2 id="기존-구현-방법-및-문제점"><a href="#기존-구현-방법-및-문제점" class="headerlink" title="기존 구현 방법 및 문제점"></a>기존 구현 방법 및 문제점</h2><ul><li><p>Unity3D의 MonoBehaviour 클래스의 Update() 메소드를 이용하여 구현</p><ul><li>Update() 메소드는 매 프레임마다 호출되는 이벤트 함수</li><li>주요 개체(Listener, LeftSpeaker, RightSpeaker, RealSoundEffector 등)들의 Update() 메소드에서 매 프레임마다 음원 개체의 위치를 참조하여 연산</li><li>프레임마다 주요 개체들이 음원 개체와의 거리, 출력량, 회전각도, 도플러 효과 적용 등의 연산을 수행</li></ul></li><li><p>위의 방법은 연산 중복으로 인한 비효율 발생</p><ul><li><p>음원 개체가 정지되어 있거나, 움직이는 속도가 느리면 아래의 그림과 같이 연산 중복이 발생</p><p><img src="/images/Unity3D%EC%97%90%EC%84%9C-Observer%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%B0%EC%82%B0%EB%9F%89-%EA%B0%90%EC%86%8C/Operation_Duplication.png" alt="Operation_Duplication"></p><ul><li>음원 개체가 이전과 같은 위치이기 때문에 연산 결과가 동일함에도 프레임이 변경되었기 때문에 불필요 연산 수행</li></ul></li></ul></li></ul><h2 id="Observer-패턴-적용"><a href="#Observer-패턴-적용" class="headerlink" title="Observer 패턴 적용"></a>Observer 패턴 적용</h2><ul><li><p>Observer 패턴</p><ul><li>Subject의 상태가 변할 때 Observer 객체들이 변화를 통지 받고 연산 수행</li></ul></li><li><p>Observer 패턴 적용</p><ul><li>Subject: 음원 개체 (SoundSource)</li><li>Observer: 청자 개체 (Listener), 스피커 개체 (LeftSpeaker, RightSpeaker), 음향 효과 개체 (RealSoundEffector)</li></ul></li><li><p>음원의 위치가 변경되었을 때에만 연산 수행</p><ul><li>성능 향상 기대</li><li>불필요 데이터 제거로 인한 데이터 분석의 편리함 기대</li></ul></li></ul><h2 id="클래스-관계도"><a href="#클래스-관계도" class="headerlink" title="클래스 관계도"></a>클래스 관계도</h2><p><img src="/images/Unity3D%EC%97%90%EC%84%9C-Observer%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%B0%EC%82%B0%EB%9F%89-%EA%B0%90%EC%86%8C/Class_Diagram.png" alt="Class_Diagram"></p><h2 id="주요-소스코드"><a href="#주요-소스코드" class="headerlink" title="주요 소스코드"></a>주요 소스코드</h2><ul><li>음원 개체 (SoundSource) 클래스<ul><li>List를 이용해 Observer 관리</li><li>RegisterObserver, RemoveObserver, NotifyObservers 구현</li><li>Update() 메소드를 이용해 프레임마다 위치 변화 확인</li></ul></li><li>Observer<ul><li>청자 개체 (Listener), 스피커 개체 (LeftSpeaker, RightSpeaker), 음향 효과 개체 (RealSoundEffector) 등</li><li>OnNotify() 메소드를 통해 상태 변화 전달받음</li><li>기존 Update() 메소드에서 연산 불필요</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    if (OnKeyDown())</span><br><span class="line">    &#123;</span><br><span class="line">        audio.Play();</span><br><span class="line">        command.Execute();</span><br><span class="line">    &#125;</span><br><span class="line">    if (position != gameObject.transform.position)</span><br><span class="line">    &#123;</span><br><span class="line">        position = gameObject.transform.position;</span><br><span class="line">        NotifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul><li>동일 기능 수행 시 비교 결과</li></ul><p><img src="/images/Unity3D%EC%97%90%EC%84%9C-Observer%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%B0%EC%82%B0%EB%9F%89-%EA%B0%90%EC%86%8C/result1.png" alt="result1"></p><ul><li>동일 연산량 수행 시 비교 결과</li></ul><p><img src="/images/Unity3D%EC%97%90%EC%84%9C-Observer%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%B0%EC%82%B0%EB%9F%89-%EA%B0%90%EC%86%8C/result2.png" alt="result1"></p><ul><li>결과 분석<ul><li>동일 수행에 대한 연산량이 약 7배 감소</li><li>FPS (초당 프레임 수) 평균값 증가<ul><li>성능 향상</li></ul></li><li>FPS 표준 편차 감소<ul><li>FPS 안정화</li></ul></li></ul></li><li>기대효과<ul><li>Unity3D를 사용하는 다른 프로젝트에도 적용 가능</li><li>Gamer의 캐릭터를 추적해 쫓는 몬스터<ul><li>몬스터 시야에 Gamer가 들어왔을 때 쫓는 기능을 Observer 패턴으로 구현</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;도플러 효과를 이용한 실감 음향 기술을 제안하는 프로젝트를 Unity3D와 아두이노(움직이는 스피커)를 이용하여 진
      
    
    </summary>
    
      <category term="객체지향" scheme="https://sogoagain.github.io/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
    
      <category term="Unity3D" scheme="https://sogoagain.github.io/tags/Unity3D/"/>
    
      <category term="Design Pattern" scheme="https://sogoagain.github.io/tags/Design-Pattern/"/>
    
      <category term="C#" scheme="https://sogoagain.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>가볍게 정리하는 DB 기본</title>
    <link href="https://sogoagain.github.io/2019/01/22/%EA%B0%80%EB%B3%8D%EA%B2%8C-%EC%A0%95%EB%A6%AC%ED%95%98%EB%8A%94-DB-%EA%B8%B0%EB%B3%B8-%EB%82%B4%EC%9A%A9/"/>
    <id>https://sogoagain.github.io/2019/01/22/가볍게-정리하는-DB-기본-내용/</id>
    <published>2019-01-21T17:59:35.000Z</published>
    <updated>2019-07-26T18:02:19.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h2><ul><li>여러 사용자에 의해 공유되어 사용될 목적으로 통합 관리되는 구조화된 데이터의 집합체</li><li>대표적인 데이터베이스<blockquote><ul><li>관계형 데이터베이스</li><li>개체 지향형 데이터베이스</li><li>개체 관계형 데이터베이스</li></ul></blockquote></li></ul><h3 id="데이터베이스-관리-시스템-DBMS"><a href="#데이터베이스-관리-시스템-DBMS" class="headerlink" title="데이터베이스 관리 시스템 (DBMS)"></a>데이터베이스 관리 시스템 (DBMS)</h3><ul><li>데이터베이스를 쉽고 빠르게 관리(입력, 조회, 수정 및 삭제 등)할 수 있도록 도와주는 소프트웨어(응용 프로그램)</li><li>대표적인 RDBMS<blockquote><ul><li>SQL Server</li><li>Oracle</li><li>Sybase</li><li>Informix</li><li>DB2</li></ul></blockquote></li></ul><h3 id="DB-클라이언트-도구"><a href="#DB-클라이언트-도구" class="headerlink" title="DB 클라이언트 도구"></a>DB 클라이언트 도구</h3><ul><li>DBMS는 기본적으로 서버 프로그램이며, DBMS에 접속하여 데이터 관련 작업을 하는 클라이언트 프로그램이 필요<blockquote><ul><li>MS의 SQL Server Management Studio</li></ul></blockquote></li></ul><hr><h2 id="RDB-관계"><a href="#RDB-관계" class="headerlink" title="RDB 관계"></a>RDB 관계</h2><ul><li>테이블은 다음의 세 가지 방식으로 관계를 맺음<ol><li>1:1</li><li>1:N</li><li>N:N<blockquote><p>1:N(일대다) 관계가 가장 많이 사용됨<br>1:N 관계는 부모:자식 관계 특성을 가짐</p></blockquote></li></ol></li></ul><hr><h2 id="용어-및-TIP"><a href="#용어-및-TIP" class="headerlink" title="용어 및 TIP"></a>용어 및 TIP</h2><ol><li>선택한 영역 주석 처리 / 해제: Ctrl + K, C / Ctrl + K, U</li><li>*는 애스터리스크 또는 별표라고 읽는다.</li><li>레코드(record): RDB에서 하나의 정보는 하나의 행으로 저장되는 데 이 행을 레코드라고 함.</li><li>ERD: Entity Relationship Diagram, 테이블(개체) 간의 관계를 나타낸 다이어그램</li></ol><hr><h2 id="SQL-Structured-Query-Language"><a href="#SQL-Structured-Query-Language" class="headerlink" title="SQL (Structured Query Language)"></a>SQL (Structured Query Language)</h2><blockquote><p> 발음: 시퀄 또는 에스큐엘</p><ul><li>사용자가 DBMS와 의사소통 할 때 사용하는 프로그래밍 언어</li></ul></blockquote><h3 id="INSERT-문"><a href="#INSERT-문" class="headerlink" title="INSERT 문"></a>INSERT 문</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 테이블(열<span class="number">1</span>, 열<span class="number">2</span>, ..., 열n)</span><br><span class="line"><span class="keyword">VALUES</span> (값<span class="number">1</span>, 값<span class="number">2</span>, ..., 값n)</span><br></pre></td></tr></table></figure><h3 id="SELECT-문"><a href="#SELECT-문" class="headerlink" title="SELECT 문"></a>SELECT 문</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 열<span class="number">1</span>, 열<span class="number">2</span>, ..., 열n</span><br><span class="line"><span class="keyword">FROM</span> 테이블</span><br><span class="line">[<span class="keyword">WHERE</span> 조건]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> 정렬기준_열 [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>]]</span><br></pre></td></tr></table></figure><h3 id="UPDATE-문"><a href="#UPDATE-문" class="headerlink" title="UPDATE 문"></a>UPDATE 문</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 테이블</span><br><span class="line"><span class="keyword">SET</span> 열<span class="number">1</span> = <span class="string">'값1'</span>, 열<span class="number">2</span> = <span class="string">'값2'</span>, ..., 열n = <span class="string">'값n'</span></span><br><span class="line">[<span class="keyword">WHERE</span> 조건]</span><br></pre></td></tr></table></figure><h3 id="DELETE-문"><a href="#DELETE-문" class="headerlink" title="DELETE 문"></a>DELETE 문</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 테이블</span><br><span class="line">[<span class="keyword">WHERE</span> 조건]</span><br></pre></td></tr></table></figure><h3 id="JOIN-문"><a href="#JOIN-문" class="headerlink" title="JOIN 문"></a>JOIN 문</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.열<span class="number">1</span>, a.열<span class="number">2</span>, ..., a.열n, b.열<span class="number">1</span>, b.열<span class="number">2</span>, ..., b.열<span class="number">3</span></span><br><span class="line"><span class="keyword">FROM</span> A a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B b</span><br><span class="line"><span class="keyword">ON</span> a.열x = b.열x</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.열<span class="number">1</span>, a.열<span class="number">2</span>, ..., a.열n, b.열<span class="number">1</span>, b.열<span class="number">2</span>, ..., b.열<span class="number">3</span></span><br><span class="line"><span class="keyword">FROM</span> A a <span class="keyword">LEFT</span>[<span class="keyword">RIGHT</span>] <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> B b</span><br><span class="line"><span class="keyword">ON</span> a.열x = b.열x</span><br></pre></td></tr></table></figure><hr><h2 id="저장-프로시저-Stored-Procedure"><a href="#저장-프로시저-Stored-Procedure" class="headerlink" title="저장 프로시저 (Stored Procedure)"></a>저장 프로시저 (Stored Procedure)</h2><ul><li>일련의 SQL 구문을 마치 하나의 함수처럼 실행하기 위해 만들어 둔 SQL 구문의 집합</li><li>장점<ol><li>성능 향상: 캐시 메모리에 저장된 결과를 사용 -&gt; 실행 속도 향상</li><li>보안 강화: 저장 프로시저 실행 권한만 부여하는 등 권한 제어 가능</li><li>네트워크 전송량 감소: SQL문 전체를 전송하지 않고 필요한 매개변수만 전달</li><li>모듈식 프로그래밍: 재사용 용이</li></ol></li></ul><hr><h2 id="트랜잭션-Transaction"><a href="#트랜잭션-Transaction" class="headerlink" title="트랜잭션 (Transaction)"></a>트랜잭션 (Transaction)</h2><ul><li>DB에서 더 이상 쪼갤 수 없는 하나로 묶여진 프로세스 처리(조회, 입력, 수정, 삭제) 단위<blockquote><ul><li>트랜잭션 시작:  BEGIN TRANSACTION</li><li>트랜잭션 적용: COMMIT</li><li>트랜잭션 취소: ROLLBACK</li><li>트랜잭션 예외 처리: TRY…CATCH (SQL Server 2005 이후)</li></ul></blockquote></li></ul><h3 id="저장-프로시저-생성-및-트랜잭션-처리"><a href="#저장-프로시저-생성-및-트랜잭션-처리" class="headerlink" title="저장 프로시저 생성 및 트랜잭션 처리"></a>저장 프로시저 생성 및 트랜잭션 처리</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 프로시저명</span><br><span class="line">    @매개변수 데이터형식</span><br><span class="line"><span class="keyword">AS</span>  <span class="comment">-- 매개변수와 실제 실행될 SQL 구문 구분</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">    <span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span>   <span class="comment">-- 트랜잭션 시작</span></span><br><span class="line"></span><br><span class="line">    (처리 내용)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">COMMIT</span>  <span class="comment">-- 트랜잭션에 존재하는 프로세스의 처리 결과 적용</span></span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> CATCH <span class="comment">-- TRY 블럭의 오류 캐치</span></span><br><span class="line">    <span class="keyword">IF</span>(@@TRANCOUNT &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">ROLLBACK</span>    <span class="comment">--  트랜잭션 처리 내용 취소 (이전 상태로 복원)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- TRY 블럭에서 발생한 오류 로깅</span></span><br><span class="line">    <span class="keyword">DECLARE</span> @ErrorMsg <span class="keyword">nvarchar</span>(<span class="number">4000</span>)    <span class="comment">-- 오류 메시지</span></span><br><span class="line">            , @ErrorSeverity <span class="built_in">int</span>        <span class="comment">-- 오류의 심각도</span></span><br><span class="line">    <span class="keyword">SELECT</span> @ErrorMsg = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY()</span><br><span class="line">    RAISERROR(@ErrorMsg, @ErrorSeverity, <span class="number">1</span>) <span class="comment">-- 오류 정보 등록</span></span><br><span class="line"><span class="keyword">END</span> CATCH</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DB&quot;&gt;&lt;a href=&quot;#DB&quot; class=&quot;headerlink&quot; title=&quot;DB&quot;&gt;&lt;/a&gt;DB&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;여러 사용자에 의해 공유되어 사용될 목적으로 통합 관리되는 구조화된 데이터의 집합체&lt;/li&gt;
&lt;li&gt;대표적인 데이터
      
    
    </summary>
    
      <category term="데이터베이스" scheme="https://sogoagain.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="DB" scheme="https://sogoagain.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>가볍게 구분하는 개체, 객체, 인스턴스</title>
    <link href="https://sogoagain.github.io/2019/01/12/%EA%B0%80%EB%B3%8D%EA%B2%8C-%EA%B5%AC%EB%B6%84%ED%95%98%EB%8A%94-%EA%B0%9C%EC%B2%B4-%EA%B0%9D%EC%B2%B4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4/"/>
    <id>https://sogoagain.github.io/2019/01/12/가볍게-구분하는-개체-객체-인스턴스/</id>
    <published>2019-01-11T17:56:16.000Z</published>
    <updated>2019-07-26T17:57:38.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개체"><a href="#개체" class="headerlink" title="개체"></a>개체</h2><p> 프로그래밍에서 이르는 모든 요소<br> OOP에서는 Class의 Instance</p><h2 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h2><p>개체를 취급할 때 주체 측에서 상대적으로 이르는 말</p><h2 id="인스턴스"><a href="#인스턴스" class="headerlink" title="인스턴스"></a>인스턴스</h2><p>추상화 기법 중 분류/인스턴스화(classification/instantiation) 개념으로 접근<br>인스턴스: 추상적인 개념과 구체적인 실체 사이 <em>관계</em>에 초점</p><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><blockquote><ol><li><a href="https://social.msdn.microsoft.com/Forums/ko-KR/c095ed0e-0f92-4c1b-8251-5950b4a1ca14/ctip-4406052404204913963650752-4406152404234583963651032?forum=visualcsharpko" rel="external nofollow noopener noreferrer" target="_blank">https://social.msdn.microsoft.com/Forums/ko-KR/c095ed0e-0f92-4c1b-8251-5950b4a1ca14/ctip-4406052404204913963650752-4406152404234583963651032?forum=visualcsharpko</a></li><li><a href="https://www.slipp.net/questions/126" rel="external nofollow noopener noreferrer" target="_blank">https://www.slipp.net/questions/126</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개체&quot;&gt;&lt;a href=&quot;#개체&quot; class=&quot;headerlink&quot; title=&quot;개체&quot;&gt;&lt;/a&gt;개체&lt;/h2&gt;&lt;p&gt; 프로그래밍에서 이르는 모든 요소&lt;br&gt; OOP에서는 Class의 Instance&lt;/p&gt;
&lt;h2 id=&quot;객체&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="객체지향" scheme="https://sogoagain.github.io/categories/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
    
      <category term="OOP" scheme="https://sogoagain.github.io/tags/OOP/"/>
    
  </entry>
  
</feed>
